---
id: 1-2-2-Topics
sidebar_position: 2
title: 2.2 - Topics
---
---

# 2.2 Topics: Asynchronous Data Streaming (Publish/Subscribe)

## Learning Objectives
- Explain the asynchronous publish/subscribe communication model in detail.
- Implement ROS 2 publishers and subscribers in Python using `rclpy`.
- Understand and utilize standard ROS 2 message types (e.g., `std_msgs`).
- Learn to define and use custom ROS IDL message types.
- Grasp the significance and application of Quality of Service (QoS) profiles.

## Key Concepts
- **ROS 2 Topics**: Named buses for passing messages between nodes
- **Publisher**: Node that sends messages to a topic
- **Subscriber**: Node that receives messages from a topic
- **Publish/Subscribe Pattern**: Asynchronous communication model
- **Message Types**: Standardized data structures for communication
- **Quality of Service (QoS)**: Policies that define how messages are delivered

This section comprehensively covers topics. It explains the publisher/subscriber roles, how to use `rclpy` to create them, and the importance of message types. Detail standard message types (`std_msgs`) and guide students through creating custom `.msg` files using ROS IDL, building them with `colcon`, and using them in Python. A significant portion is dedicated to QoS profiles, explaining reliability, durability, history, and depth policies with practical examples of their impact on communication.

<!-- DIAGRAM: Detailed Publish/Subscribe communication flow -->

## Basic Publisher Implementation

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS 2: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Basic Subscriber Implementation

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10) # QoS depth
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    minimal_subscriber = MinimalSubscriber()
    rclpy.spin(minimal_subscriber)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Custom Message Implementation

```python
# In my_robot_controller/msg/RobotPose.msg
# float32 x
# float32 y
# float32 theta

# Python publisher using custom message (assuming message built and sourced)
import rclpy
from rclpy.node import Node
from my_robot_controller.msg import RobotPose # Import custom message
import time

class CustomPublisher(Node):
    def __init__(self):
        super().__init__('custom_publisher')
        self.publisher_ = self.create_publisher(RobotPose, 'robot_pose', 10)
        timer_period = 1.0
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.x, self.y, self.theta = 0.0, 0.0, 0.0

    def timer_callback(self):
        msg = RobotPose()
        msg.x = self.x
        msg.y = self.y
        msg.theta = self.theta
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing Pose: x={msg.x:.2f}, y={msg.y:.2f}, theta={msg.theta:.2f}')
        self.x += 0.1
        self.y += 0.05
        self.theta += 0.01

def main(args=None):
    rclpy.init(args=args)
    node = CustomPublisher()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()

# Python subscriber using custom message
import rclpy
from rclpy.node import Node
from my_robot_controller.msg import RobotPose # Import custom message

class CustomSubscriber(Node):
    def __init__(self):
        super().__init__('custom_subscriber')
        self.subscription = self.create_subscription(
            RobotPose,
            'robot_pose',
            self.listener_callback,
            10)

    def listener_callback(self, msg):
        self.get_logger().info(f'Received Pose: x={msg.x:.2f}, y={msg.y:.2f}, theta={msg.theta:.2f}')

def main(args=None):
    rclpy.init(args=args)
    node = CustomSubscriber()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Quality of Service (QoS) Implementation

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy

class QoSPublisher(Node):
    def __init__(self):
        super().__init__('qos_publisher')
        qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE,
            history=HistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST,
            depth=5,
            durability=DurabilityPolicy.RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL
        )
        self.publisher_ = self.create_publisher(String, 'qos_topic', qos_profile)
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'QoS Message {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}" with QoS')
        self.i += 1

class QoSSubscriber(Node):
    def __init__(self):
        super().__init__('qos_subscriber')
        qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE,
            history=HistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST,
            depth=5,
            durability=DurabilityPolicy.RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL
        )
        self.subscription = self.create_subscription(
            String,
            'qos_topic',
            self.listener_callback,
            qos_profile) # Pass QoS profile here

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard (QoS): "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    publisher = QoSPublisher()
    subscriber = QoSSubscriber()

    executor = rclpy.executors.MultiThreadedExecutor()
    executor.add_node(publisher)
    executor.add_node(subscriber)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        executor.shutdown()
        publisher.destroy_node()
        subscriber.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```