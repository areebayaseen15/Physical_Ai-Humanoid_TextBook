---
id: 1-3-3-Services
title: 1 3.3 Services
sidebar_label: 1 3.3 Services
sidebar_position: 0
---
# Chapter 3-03: Python Service Clients and Servers with rclpy

<!-- CHUNK START: Introduction to Services -->
## Introduction to Services in ROS 2

Services in ROS 2 (Robot Operating System 2) provide a synchronous communication pattern between nodes, where one node (the service client) sends a request to another node (the service server) and waits for a response. This request-response pattern is fundamentally different from the publish-subscribe pattern, as it establishes a direct, synchronous connection between the client and server.

Services are ideal for operations that require immediate responses or have well-defined request-response semantics, such as robot configuration, sensor calibration, or executing specific actions with guaranteed completion. Unlike topics, which are asynchronous and decoupled, services create a tight coupling between client and server during the duration of the request.

### Learning Objectives

By the end of this section, you will be able to:

1. Create service servers that respond to requests from clients
2. Create service clients that send requests and handle responses
3. Implement custom service types for specific applications
4. Handle service errors and timeouts gracefully
5. Bridge Python AI agents to ROS controllers using service communication
6. Structure service communication content for RAG (Retrieval-Augmented Generation) indexing

### Key Concepts

- **Service**: A synchronous communication pattern with request-response semantics
- **Service Server**: A node that provides a service and responds to requests
- **Service Client**: A node that sends requests to a service server
- **Service Type**: Defines the structure of requests and responses
- **Synchronous**: The client waits for a response before continuing

<!-- DIAGRAM: Service Pattern - Client Request and Server Response -->
<!-- CHUNK END: Introduction to Services -->

<!-- CHUNK START: Creating Service Servers -->
## Creating Service Servers

Service servers in ROS 2 provide functionality that clients can request synchronously. Creating a service server in `rclpy` involves using the `create_service()` method of a node instance, which requires a service type and a callback function to process requests.

### Basic Service Server Implementation

First, let's define a simple service type. In a real project, this would be in a `.srv` file:

```
# In your_robot_package/srv/AddTwoInts.srv
int64 a
int64 b
---
int64 sum
```

Then implement the service server:

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts  # Standard example service

class BasicServiceServer(Node):
    """
    A basic service server that demonstrates the fundamental concepts of
    creating and implementing a service in ROS 2 using rclpy.
    """

    def __init__(self):
        super().__init__('basic_service_server')

        # Create the service with the service type and callback function
        self.srv = self.create_service(
            AddTwoInts,
            'add_two_ints',
            self.add_two_ints_callback
        )

        self.get_logger().info('Basic Service Server initialized')

    def add_two_ints_callback(self, request, response):
        """
        Callback function that processes service requests.
        This function receives a request object and returns a response object.
        """
        # Perform the service operation
        response.sum = request.a + request.b

        # Log the operation
        self.get_logger().info(
            f'Incoming request: {request.a} + {request.b} = {response.sum}'
        )

        # Return the response (must return the response object)
        return response

def main(args=None):
    rclpy.init(args=args)

    service_server = BasicServiceServer()

    try:
        rclpy.spin(service_server)
    except KeyboardInterrupt:
        service_server.get_logger().info('Interrupted, shutting down...')
    finally:
        service_server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Parameterized Service Server

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
from std_srvs.srv import SetBool
import time

class ParameterizedServiceServer(Node):
    """
    A service server that uses parameters to configure its behavior.
    This demonstrates how to make service servers configurable at runtime.
    """

    def __init__(self):
        super().__init__('parameterized_service_server')

        # Declare parameters for service configuration
        self.declare_parameter('max_calculation_time', 5.0)  # seconds
        self.declare_parameter('service_enabled', True)
        self.declare_parameter('service_name', 'parameterized_calculation')

        # Get parameter values
        self.max_calc_time = self.get_parameter('max_calculation_time').value
        self.service_enabled = self.get_parameter('service_enabled').value
        self.service_name = self.get_parameter('service_name').value

        # Create services with configurable names
        self.calc_service = self.create_service(
            AddTwoInts,
            f'{self.service_name}_add',
            self.calculation_callback
        )

        self.config_service = self.create_service(
            SetBool,
            f'{self.service_name}_config',
            self.config_callback
        )

        # Track service statistics
        self.request_count = 0
        self.error_count = 0

        # Log configuration
        self.get_logger().info(f'Parameterized Service Server initialized')
        self.get_logger().info(f'Service name: {self.service_name}')
        self.get_logger().info(f'Max calculation time: {self.max_calc_time}s')
        self.get_logger().info(f'Service enabled: {self.service_enabled}')

    def calculation_callback(self, request, response):
        """Handle calculation requests with time constraints."""
        start_time = time.time()

        # Check if service is enabled
        if not self.service_enabled:
            response.success = False
            response.message = 'Service is currently disabled'
            self.error_count += 1
            return response

        # Simulate computation time (in a real service, this would be actual work)
        # Add a small delay to simulate processing
        time.sleep(0.1)

        # Perform the calculation
        try:
            result = request.a + request.b

            # Check for computation timeout
            if time.time() - start_time > self.max_calc_time:
                response.success = False
                response.message = f'Calculation took too long: {time.time() - start_time:.2f}s'
                self.error_count += 1
                return response

            response.sum = result
            response.success = True
            response.message = f'Calculated in {time.time() - start_time:.3f}s'

            self.request_count += 1
            self.get_logger().info(
                f'Calculation: {request.a} + {request.b} = {result} '
                f'(Time: {time.time() - start_time:.3f}s)'
            )

        except Exception as e:
            response.success = False
            response.message = f'Calculation error: {str(e)}'
            self.error_count += 1
            self.get_logger().error(f'Calculation error: {e}')

        return response

    def config_callback(self, request, response):
        """Handle configuration requests."""
        if request.data:
            self.service_enabled = True
            response.success = True
            response.message = 'Service enabled'
            self.get_logger().info('Service enabled via configuration')
        else:
            self.service_enabled = False
            response.success = True
            response.message = 'Service disabled'
            self.get_logger().info('Service disabled via configuration')

        return response

def main(args=None):
    rclpy.init(args=args)

    param_server = ParameterizedServiceServer()

    try:
        rclpy.spin(param_server)
    except KeyboardInterrupt:
        param_server.get_logger().info(
            f'Shutting down. Stats - Requests: {param_server.request_count}, '
            f'Errors: {param_server.error_count}'
        )
    finally:
        param_server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Advanced Service Server with Error Handling

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
from std_srvs.srv import Trigger
from rclpy.qos import QoSProfile
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup
import time
import threading
from concurrent.futures import ThreadPoolExecutor
import math

class AdvancedServiceServer(Node):
    """
    An advanced service server with comprehensive error handling,
    threading support, and multiple service types.
    """

    def __init__(self):
        super().__init__('advanced_service_server')

        # Create multiple services with different callback groups
        default_callback_group = MutuallyExclusiveCallbackGroup()
        computation_callback_group = MutuallyExclusiveCallbackGroup()

        # Basic calculation service
        self.calc_service = self.create_service(
            AddTwoInts,
            'advanced_calculation',
            self.advanced_calculation_callback,
            callback_group=default_callback_group
        )

        # Trigger service for simple operations
        self.trigger_service = self.create_service(
            Trigger,
            'system_trigger',
            self.trigger_callback,
            callback_group=default_callback_group
        )

        # Initialize thread pool for long-running operations
        self.executor = ThreadPoolExecutor(max_workers=3)

        # Service statistics
        self.stats = {
            'total_requests': 0,
            'successful_requests': 0,
            'failed_requests': 0,
            'total_calculation_time': 0.0
        }

        self.get_logger().info('Advanced Service Server initialized')

    def advanced_calculation_callback(self, request, response):
        """Handle advanced calculations with error handling."""
        start_time = time.time()
        self.stats['total_requests'] += 1

        try:
            # Validate inputs
            if request.a < -1000000 or request.a > 1000000:
                raise ValueError(f'Input a out of range: {request.a}')
            if request.b < -1000000 or request.b > 1000000:
                raise ValueError(f'Input b out of range: {request.b}')

            # Perform calculation
            result = self.perform_calculation(request.a, request.b)

            # Update statistics
            calc_time = time.time() - start_time
            self.stats['total_calculation_time'] += calc_time
            self.stats['successful_requests'] += 1

            response.sum = result
            response.success = True
            response.message = f'Calculated in {calc_time:.3f}s. Avg: {self.stats["total_calculation_time"]/self.stats["successful_requests"]:.3f}s'

            self.get_logger().info(
                f'Advanced calc: {request.a} + {request.b} = {result} '
                f'(Time: {calc_time:.3f}s)'
            )

        except ValueError as e:
            self.stats['failed_requests'] += 1
            response.success = False
            response.message = f'Input validation error: {str(e)}'
            self.get_logger().warn(f'Input validation error: {e}')

        except OverflowError:
            self.stats['failed_requests'] += 1
            response.success = False
            response.message = 'Calculation would cause overflow'
            self.get_logger().error('Calculation overflow detected')

        except Exception as e:
            self.stats['failed_requests'] += 1
            response.success = False
            response.message = f'Unexpected error: {str(e)}'
            self.get_logger().error(f'Unexpected error in calculation: {e}')

        return response

    def perform_calculation(self, a, b):
        """Perform the actual calculation with additional logic."""
        # In a real system, this might involve complex algorithms
        result = a + b

        # Example of additional processing that might be needed
        if result < 0:
            result = abs(result)  # Example: always return positive
        elif result > 1000000:
            result = result % 1000000  # Example: wrap around for large numbers

        return result

    def trigger_callback(self, request, response):
        """Handle trigger requests."""
        self.get_logger().info('Trigger service called')

        # Perform trigger action
        action_result = self.perform_trigger_action()

        if action_result:
            response.success = True
            response.message = 'Trigger action completed successfully'
        else:
            response.success = False
            response.message = 'Trigger action failed'

        return response

    def perform_trigger_action(self):
        """Perform the actual trigger action."""
        # Simulate some action (in real system, this could be hardware control)
        time.sleep(0.05)  # Simulate processing time
        return True

    def get_stats_callback(self, request, response):
        """Return service statistics."""
        response.success = True
        response.message = (
            f'Total: {self.stats["total_requests"]}, '
            f'Successful: {self.stats["successful_requests"]}, '
            f'Failed: {self.stats["failed_requests"]}, '
            f'Avg time: {self.stats["total_calculation_time"]/max(1, self.stats["successful_requests"]):.3f}s'
        )
        return response

def main(args=None):
    rclpy.init(args=args)

    advanced_server = AdvancedServiceServer()

    try:
        rclpy.spin(advanced_server)
    except KeyboardInterrupt:
        advanced_server.get_logger().info('Interrupted, shutting down...')
        # Print final statistics
        stats = advanced_server.stats
        if stats['successful_requests'] > 0:
            avg_time = stats['total_calculation_time'] / stats['successful_requests']
            advanced_server.get_logger().info(
                f'Final stats - Total: {stats["total_requests"]}, '
                f'Successful: {stats["successful_requests"]}, '
                f'Failed: {stats["failed_requests"]}, '
                f'Avg time: {avg_time:.3f}s'
            )
    finally:
        advanced_server.executor.shutdown(wait=True)
        advanced_server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Server Best Practices

1. **Error Handling**: Always implement proper error handling in service callbacks
2. **Input Validation**: Validate all incoming request parameters
3. **Timeout Management**: Consider implementing timeouts for long-running operations
4. **Resource Management**: Properly manage resources and avoid blocking the main thread
5. **Logging**: Log service calls for debugging and monitoring
6. **Threading**: Use appropriate threading models for CPU-intensive operations

<!-- DIAGRAM: Service Server Architecture - Request Processing and Response -->
<!-- CHUNK END: Creating Service Servers -->

<!-- CHUNK START: Creating Service Clients -->
## Creating Service Clients

Service clients in ROS 2 send requests to service servers and wait for responses. Creating a service client in `rclpy` involves using the `create_client()` method of a node instance, followed by making asynchronous service calls.

### Basic Service Client Implementation

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
import time

class BasicServiceClient(Node):
    """
    A basic service client that demonstrates how to create and use
    service clients in ROS 2 using rclpy.
    """

    def __init__(self):
        super().__init__('basic_service_client')

        # Create the service client
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')

        # Wait for the service to be available
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')

        # Create a request object
        self.request = AddTwoInts.Request()

        # Timer to make periodic service calls
        self.timer = self.create_timer(2.0, self.send_request)

        self.get_logger().info('Basic Service Client initialized')

    def send_request(self):
        """Send a request to the service server."""
        # Set the request parameters
        self.request.a = 42
        self.request.b = 36

        # Make the service call asynchronously
        self.future = self.cli.call_async(self.request)

        # Add a callback to handle the response
        self.future.add_done_callback(self.service_callback)

        self.get_logger().info(f'Requesting {self.request.a} + {self.request.b}')

    def service_callback(self, future):
        """Handle the service response."""
        try:
            response = future.result()
            self.get_logger().info(
                f'Result of {self.request.a} + {self.request.b} = {response.sum}'
            )
        except Exception as e:
            self.get_logger().error(f'Service call failed: {e}')

def main(args=None):
    rclpy.init(args=args)

    service_client = BasicServiceClient()

    try:
        rclpy.spin(service_client)
    except KeyboardInterrupt:
        service_client.get_logger().info('Interrupted, shutting down...')
    finally:
        service_client.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Advanced Service Client with Error Handling

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
from std_srvs.srv import Trigger
import time
import random
from concurrent.futures import TimeoutError

class AdvancedServiceClient(Node):
    """
    An advanced service client with comprehensive error handling,
    timeout management, and multiple service support.
    """

    def __init__(self):
        super().__init__('advanced_service_client')

        # Create multiple service clients
        self.calc_client = self.create_client(AddTwoInts, 'advanced_calculation')
        self.trigger_client = self.create_client(Trigger, 'system_trigger')

        # Wait for services to be available
        self.wait_for_services()

        # Initialize request objects
        self.calc_request = AddTwoInts.Request()
        self.trigger_request = Trigger.Request()

        # Client configuration parameters
        self.declare_parameter('request_frequency', 1.0)  # Hz
        self.declare_parameter('timeout_seconds', 5.0)
        self.declare_parameter('max_retries', 3)

        self.request_frequency = self.get_parameter('request_frequency').value
        self.timeout_seconds = self.get_parameter('timeout_seconds').value
        self.max_retries = self.get_parameter('max_retries').value

        # Set up timer for periodic requests
        timer_period = 1.0 / self.request_frequency
        self.timer = self.create_timer(timer_period, self.make_requests)

        # Track client statistics
        self.stats = {
            'total_requests': 0,
            'successful_requests': 0,
            'failed_requests': 0,
            'timed_out_requests': 0
        }

        # Request tracking for retry mechanism
        self.pending_requests = {}  # Maps request_id to request info

        self.get_logger().info('Advanced Service Client initialized')

    def wait_for_services(self):
        """Wait for required services to become available."""
        services = [
            (self.calc_client, 'advanced_calculation'),
            (self.trigger_client, 'system_trigger')
        ]

        for client, service_name in services:
            while not client.wait_for_service(timeout_sec=1.0):
                self.get_logger().info(f'Service {service_name} not available, waiting...')

    def make_requests(self):
        """Make periodic service requests."""
        # Make a calculation request with random values
        self.calc_request.a = random.randint(1, 100)
        self.calc_request.b = random.randint(1, 100)

        # Make the service call
        self.stats['total_requests'] += 1
        request_id = f'calc_{self.stats["total_requests"]}'

        future = self.calc_client.call_async(self.calc_request)
        future.add_done_callback(lambda f: self.handle_calc_response(f, request_id))

        self.get_logger().info(f'Sending calculation request {request_id}: {self.calc_request.a} + {self.calc_request.b}')

        # Occasionally make a trigger request
        if self.stats['total_requests'] % 5 == 0:
            trigger_id = f'trigger_{self.stats["total_requests"] // 5}'
            trigger_future = self.trigger_client.call_async(self.trigger_request)
            trigger_future.add_done_callback(lambda f: self.handle_trigger_response(f, trigger_id))

    def handle_calc_response(self, future, request_id):
        """Handle calculation service response."""
        try:
            response = future.result()

            if response.success:
                self.stats['successful_requests'] += 1
                self.get_logger().info(
                    f'Request {request_id} successful: {response.message}'
                )
            else:
                self.stats['failed_requests'] += 1
                self.get_logger().warn(
                    f'Request {request_id} failed: {response.message}'
                )

        except TimeoutError:
            self.stats['timed_out_requests'] += 1
            self.get_logger().error(f'Request {request_id} timed out')

        except Exception as e:
            self.stats['failed_requests'] += 1
            self.get_logger().error(f'Request {request_id} error: {e}')

        # Log statistics periodically
        if self.stats['total_requests'] % 10 == 0:
            self.log_statistics()

    def handle_trigger_response(self, future, request_id):
        """Handle trigger service response."""
        try:
            response = future.result()

            if response.success:
                self.get_logger().info(f'Trigger {request_id} successful: {response.message}')
            else:
                self.get_logger().warn(f'Trigger {request_id} failed: {response.message}')

        except Exception as e:
            self.get_logger().error(f'Trigger {request_id} error: {e}')

    def log_statistics(self):
        """Log client statistics."""
        success_rate = (self.stats['successful_requests'] /
                       max(1, self.stats['total_requests'])) * 100

        self.get_logger().info(
            f'Statistics - Total: {self.stats["total_requests"]}, '
            f'Successful: {self.stats["successful_requests"]} ({success_rate:.1f}%), '
            f'Failed: {self.stats["failed_requests"]}, '
            f'Timed out: {self.stats["timed_out_requests"]}'
        )

def main(args=None):
    rclpy.init(args=args)

    advanced_client = AdvancedServiceClient()

    try:
        rclpy.spin(advanced_client)
    except KeyboardInterrupt:
        advanced_client.get_logger().info('Interrupted, shutting down...')
        advanced_client.log_statistics()
    finally:
        advanced_client.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Client with Retry Logic

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
import time
import threading
from collections import defaultdict

class RetryServiceClient(Node):
    """
    A service client with sophisticated retry logic and request tracking.
    This demonstrates how to handle unreliable services and implement resilience.
    """

    def __init__(self):
        super().__init__('retry_service_client')

        # Create service client
        self.client = self.create_client(AddTwoInts, 'unreliable_calculation')

        # Wait for service
        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting...')

        # Configuration
        self.declare_parameter('request_interval', 3.0)  # seconds between requests
        self.declare_parameter('max_retries', 5)
        self.declare_parameter('retry_delay', 1.0)  # seconds between retries

        self.request_interval = self.get_parameter('request_interval').value
        self.max_retries = self.get_parameter('max_retries').value
        self.retry_delay = self.get_parameter('retry_delay').value

        # Request tracking
        self.request_queue = []
        self.pending_requests = {}  # Maps request_id to request info
        self.retry_counts = defaultdict(int)

        # Request object
        self.request = AddTwoInts.Request()

        # Timer for sending requests
        self.timer = self.create_timer(self.request_interval, self.send_next_request)

        # Thread for retry management
        self.retry_thread = threading.Thread(target=self.retry_manager, daemon=True)
        self.retry_thread.start()

        self.get_logger().info('Retry Service Client initialized')

    def send_next_request(self):
        """Send the next request in the queue."""
        # Generate a new request
        self.request.a = int(time.time()) % 100
        self.request.b = int(time.time() * 100) % 100
        request_id = f'request_{int(time.time() * 1000)}'

        # Send the request
        future = self.client.call_async(self.request)
        future.add_done_callback(lambda f: self.handle_response(f, request_id))

        # Track the request
        self.pending_requests[request_id] = {
            'request': (self.request.a, self.request.b),
            'timestamp': time.time(),
            'future': future
        }

        self.get_logger().info(f'Sent request {request_id}: {self.request.a} + {self.request.b}')

    def handle_response(self, future, request_id):
        """Handle service response."""
        try:
            response = future.result()

            if response.success:
                self.get_logger().info(
                    f'Request {request_id} succeeded: {response.message}'
                )
                # Remove from pending requests
                if request_id in self.pending_requests:
                    del self.pending_requests[request_id]
                    if request_id in self.retry_counts:
                        del self.retry_counts[request_id]
            else:
                self.get_logger().warn(
                    f'Request {request_id} failed: {response.message}'
                )
                self.handle_failed_request(request_id)

        except Exception as e:
            self.get_logger().error(f'Request {request_id} error: {e}')
            self.handle_failed_request(request_id)

    def handle_failed_request(self, request_id):
        """Handle a failed request by scheduling a retry."""
        if request_id not in self.pending_requests:
            return

        current_retry = self.retry_counts[request_id] + 1

        if current_retry <= self.max_retries:
            self.retry_counts[request_id] = current_retry
            retry_time = time.time() + self.retry_delay

            self.get_logger().info(
                f'Scheduling retry {current_retry}/{self.max_retries} for {request_id}'
            )

            # In a real system, you might want to use a more sophisticated scheduling mechanism
            # For now, we'll handle retries in the retry_manager thread
            self.pending_requests[request_id]['retry_time'] = retry_time
            self.pending_requests[request_id]['retry_count'] = current_retry
        else:
            self.get_logger().error(
                f'Request {request_id} failed after {self.max_retries} retries'
            )
            # Remove from tracking
            if request_id in self.pending_requests:
                del self.pending_requests[request_id]

    def retry_manager(self):
        """Background thread to manage retries."""
        while rclpy.ok():
            current_time = time.time()
            requests_to_retry = []

            # Find requests that are ready for retry
            for req_id, req_info in self.pending_requests.items():
                if 'retry_time' in req_info and req_info['retry_time'] <= current_time:
                    requests_to_retry.append(req_id)

            # Retry the requests
            for req_id in requests_to_retry:
                if req_id in self.pending_requests:
                    req_info = self.pending_requests[req_id]
                    original_request = req_info['request']

                    # Create new request with original values
                    retry_request = AddTwoInts.Request()
                    retry_request.a = original_request[0]
                    retry_request.b = original_request[1]

                    # Send retry
                    future = self.client.call_async(retry_request)
                    future.add_done_callback(lambda f: self.handle_response(f, req_id))

                    # Update tracking
                    self.pending_requests[req_id] = {
                        'request': original_request,
                        'timestamp': time.time(),
                        'future': future
                    }

                    self.get_logger().info(
                        f'Retrying request {req_id} (attempt {req_info.get("retry_count", 1) + 1})'
                    )

            # Sleep to avoid busy waiting
            time.sleep(0.1)

def main(args=None):
    rclpy.init(args=args)

    retry_client = RetryServiceClient()

    try:
        rclpy.spin(retry_client)
    except KeyboardInterrupt:
        retry_client.get_logger().info('Interrupted, shutting down...')
    finally:
        retry_client.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Client Best Practices

1. **Service Availability**: Always check if services are available before making calls
2. **Asynchronous Calls**: Use `call_async()` to avoid blocking the main thread
3. **Error Handling**: Handle exceptions and service failures gracefully
4. **Timeout Management**: Implement appropriate timeouts for service calls
5. **Retry Logic**: Consider implementing retry mechanisms for unreliable services
6. **Resource Management**: Properly manage futures and avoid resource leaks

<!-- DIAGRAM: Service Client Architecture - Request Submission and Response Handling -->
<!-- CHUNK END: Creating Service Clients -->

<!-- CHUNK START: Custom Service Types -->
## Working with Custom Service Types

While ROS 2 provides standard service types in packages like `std_srvs` and `example_interfaces`, you'll often need to define custom service types for your specific application. Custom services enable precise request-response communication between nodes and are essential for building specialized robotic applications.

### Defining Custom Service Types

Service types are defined in `.srv` files with the following format:

```
# In your_robot_package/srv/RobotControl.srv
# Request part (before ---)
float64 linear_velocity
float64 angular_velocity
bool enable_motors
---
# Response part (after ---)
bool success
string message
float64 execution_time
```

```
# In your_robot_package/srv/GetRobotPose.srv
# Request part
string robot_name
---
# Response part
float64 x
float64 y
float64 theta
bool success
string message
```

### Implementing Custom Services

```python
# Service server implementation
import rclpy
from rclpy.node import Node
from your_robot_package.srv import RobotControl, GetRobotPose
import time

class CustomServiceServer(Node):
    """
    A service server that implements custom service types for robot control.
    This demonstrates how to work with custom service definitions in Python.
    """

    def __init__(self):
        super().__init__('custom_service_server')

        # Create services with custom types
        self.control_service = self.create_service(
            RobotControl,
            'robot_control',
            self.control_callback
        )

        self.pose_service = self.create_service(
            GetRobotPose,
            'get_robot_pose',
            self.pose_callback
        )

        # Simulated robot state
        self.robot_state = {
            'x': 0.0,
            'y': 0.0,
            'theta': 0.0,
            'linear_vel': 0.0,
            'angular_vel': 0.0,
            'motors_enabled': True
        }

        self.get_logger().info('Custom Service Server initialized')

    def control_callback(self, request, response):
        """Handle robot control requests."""
        start_time = time.time()

        try:
            # Validate inputs
            if abs(request.linear_velocity) > 2.0:
                response.success = False
                response.message = 'Linear velocity exceeds maximum (2.0 m/s)'
                return response

            if abs(request.angular_velocity) > 1.0:
                response.success = False
                response.message = 'Angular velocity exceeds maximum (1.0 rad/s)'
                return response

            # Update robot state based on request
            self.robot_state['linear_vel'] = request.linear_velocity
            self.robot_state['angular_vel'] = request.angular_velocity
            self.robot_state['motors_enabled'] = request.enable_motors

            # Simulate command execution (in real system, this would control hardware)
            if request.enable_motors:
                # Update position based on velocity (simplified simulation)
                self.robot_state['x'] += request.linear_velocity * 0.1  # 0.1s simulation
                self.robot_state['y'] += request.angular_velocity * 0.05  # Simplified

            execution_time = time.time() - start_time

            response.success = True
            response.message = f'Control command executed successfully. Motors: {request.enable_motors}'
            response.execution_time = execution_time

            self.get_logger().info(
                f'Control command: v={request.linear_velocity}, w={request.angular_velocity}, '
                f'enabled={request.enable_motors}. Execution time: {execution_time:.3f}s'
            )

        except Exception as e:
            response.success = False
            response.message = f'Control error: {str(e)}'
            self.get_logger().error(f'Control error: {e}')

        return response

    def pose_callback(self, request, response):
        """Handle robot pose requests."""
        try:
            # In a real system, you might look up the robot by name
            # For this example, we'll use a fixed robot or return default values

            if request.robot_name == '' or request.robot_name == 'robot_1':
                response.x = self.robot_state['x']
                response.y = self.robot_state['y']
                response.theta = self.robot_state['theta']
                response.success = True
                response.message = f'Pose for {request.robot_name or "default robot"}'
            else:
                response.x = 0.0
                response.y = 0.0
                response.theta = 0.0
                response.success = False
                response.message = f'Robot {request.robot_name} not found'

            self.get_logger().info(
                f'Pose request for {request.robot_name}: ({response.x}, {response.y}, {response.theta})'
            )

        except Exception as e:
            response.success = False
            response.message = f'Pose error: {str(e)}'
            self.get_logger().error(f'Pose error: {e}')

        return response

# Service client implementation
class CustomServiceClient(Node):
    """
    A service client that uses custom service types for robot communication.
    This demonstrates how to call custom services from Python.
    """

    def __init__(self):
        super().__init__('custom_service_client')

        # Create clients for custom services
        self.control_client = self.create_client(RobotControl, 'robot_control')
        self.pose_client = self.create_client(GetRobotPose, 'get_robot_pose')

        # Wait for services
        while not self.control_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Control service not available, waiting...')

        while not self.pose_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Pose service not available, waiting...')

        # Request objects
        self.control_request = RobotControl.Request()
        self.pose_request = GetRobotPose.Request()

        # Timer for demonstration
        self.timer = self.create_timer(3.0, self.demo_service_calls)

        self.get_logger().info('Custom Service Client initialized')

    def demo_service_calls(self):
        """Demonstrate calls to custom services."""
        # Make a control request
        self.control_request.linear_velocity = 0.5
        self.control_request.angular_velocity = 0.1
        self.control_request.enable_motors = True

        future = self.control_client.call_async(self.control_request)
        future.add_done_callback(self.control_response_callback)

        self.get_logger().info('Sent control request')

        # Make a pose request
        self.pose_request.robot_name = 'robot_1'
        pose_future = self.pose_client.call_async(self.pose_request)
        pose_future.add_done_callback(self.pose_response_callback)

        self.get_logger().info('Sent pose request')

    def control_response_callback(self, future):
        """Handle control service response."""
        try:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Control successful: {response.message}')
            else:
                self.get_logger().warn(f'Control failed: {response.message}')
        except Exception as e:
            self.get_logger().error(f'Control response error: {e}')

    def pose_response_callback(self, future):
        """Handle pose service response."""
        try:
            response = future.result()
            if response.success:
                self.get_logger().info(
                    f'Pose: ({response.x:.2f}, {response.y:.2f}, {response.theta:.2f}) - {response.message}'
                )
            else:
                self.get_logger().warn(f'Pose request failed: {response.message}')
        except Exception as e:
            self.get_logger().error(f'Pose response error: {e}')

def main_server(args=None):
    rclpy.init(args=args)
    server = CustomServiceServer()

    try:
        rclpy.spin(server)
    except KeyboardInterrupt:
        server.get_logger().info('Server interrupted')
    finally:
        server.destroy_node()
        rclpy.shutdown()

def main_client(args=None):
    rclpy.init(args=args)
    client = CustomServiceClient()

    try:
        rclpy.spin(client)
    except KeyboardInterrupt:
        client.get_logger().info('Client interrupted')
    finally:
        client.destroy_node()
        rclpy.shutdown()
```

### Complex Custom Service Example

For more complex applications, you might need services with nested message types:

```
# In your_robot_package/srv/ExecuteTrajectory.srv
# Request
string trajectory_id
geometry_msgs/Point[] waypoints
float64[] velocities
float64 timeout
bool blocking
---
# Response
bool success
string message
builtin_interfaces/Time execution_start
builtin_interfaces/Time execution_end
```

```python
import rclpy
from rclpy.node import Node
from your_robot_package.srv import ExecuteTrajectory
from geometry_msgs.msg import Point
from builtin_interfaces.msg import Time
import time

class TrajectoryServiceServer(Node):
    """
    A service server for executing complex robot trajectories.
    This demonstrates working with complex custom service types.
    """

    def __init__(self):
        super().__init__('trajectory_service_server')

        self.service = self.create_service(
            ExecuteTrajectory,
            'execute_trajectory',
            self.trajectory_callback
        )

        self.get_logger().info('Trajectory Service Server initialized')

    def trajectory_callback(self, request, response):
        """Handle trajectory execution requests."""
        start_time = self.get_clock().now().to_msg()

        try:
            # Validate trajectory
            if len(request.waypoints) == 0:
                response.success = False
                response.message = 'Trajectory has no waypoints'
                return response

            if len(request.velocities) != len(request.waypoints):
                response.success = False
                response.message = 'Number of velocities must match number of waypoints'
                return response

            # Simulate trajectory execution
            self.get_logger().info(
                f'Executing trajectory {request.trajectory_id} '
                f'with {len(request.waypoints)} waypoints'
            )

            # In a real system, this would execute the actual trajectory
            # For simulation, we'll just wait
            if request.blocking:
                # Simulate execution time based on number of waypoints
                execution_duration = len(request.waypoints) * 0.5  # 0.5s per waypoint
                if execution_duration > request.timeout:
                    response.success = False
                    response.message = f'Trajectory would take {execution_duration}s, exceeds timeout {request.timeout}s'
                    return response

                time.sleep(min(execution_duration, request.timeout))

            # Set response
            response.success = True
            response.message = f'Trajectory {request.trajectory_id} executed successfully'
            response.execution_start = start_time
            response.execution_end = self.get_clock().now().to_msg()

        except Exception as e:
            response.success = False
            response.message = f'Trajectory execution error: {str(e)}'
            self.get_logger().error(f'Trajectory error: {e}')

        return response

def main(args=None):
    rclpy.init(args=args)
    server = TrajectoryServiceServer()

    try:
        rclpy.spin(server)
    except KeyboardInterrupt:
        server.get_logger().info('Trajectory server interrupted')
    finally:
        server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Custom Service Best Practices

1. **Service Design**: Design services with clear request-response semantics
2. **Error Handling**: Include success/failure indicators in responses
3. **Timeout Considerations**: Consider whether operations should be blocking or non-blocking
4. **Validation**: Validate all request parameters before processing
5. **Documentation**: Document service interfaces clearly
6. **Versioning**: Consider how service changes will affect compatibility

<!-- DIAGRAM: Custom Service Structure - Request Response Definition -->
<!-- CHUNK END: Custom Service Types -->

<!-- CHUNK START: Python Agent Bridge for Services -->
## Python Agent Bridge for Services

Service communication provides an excellent mechanism for connecting Python AI agents to ROS controllers, especially for operations that require guaranteed responses or have clear request-response semantics. This pattern enables AI agents to request specific actions from robot controllers and receive confirmation of completion.

### Service Bridge Architecture

The service bridge architecture uses synchronous communication for operations that require immediate confirmation:

```python
import rclpy
from rclpy.node import Node
from std_srvs.srv import SetBool, Trigger
from your_robot_package.srv import RobotControl, GetRobotPose
import time
import threading
from queue import Queue

class ServiceBridgeNode(Node):
    """
    A bridge node that connects Python AI agents to ROS controllers using services.
    This demonstrates synchronous communication for guaranteed operations.
    """

    def __init__(self):
        super().__init__('service_bridge')

        # Declare bridge configuration parameters
        self.declare_parameter('service_timeout', 5.0)
        self.declare_parameter('max_concurrent_requests', 10)
        self.declare_parameter('bridge_enabled', True)

        # Get parameter values
        self.service_timeout = self.get_parameter('service_timeout').value
        self.max_concurrent_requests = self.get_parameter('max_concurrent_requests').value
        self.bridge_enabled = self.get_parameter('bridge_enabled').value

        # Create service clients for robot control
        self.motor_control_client = self.create_client(SetBool, '/motors/enable')
        self.control_client = self.create_client(RobotControl, '/robot/control')
        self.pose_client = self.create_client(GetRobotPose, '/robot/get_pose')
        self.trigger_client = self.create_client(Trigger, '/robot/emergency_stop')

        # Create services for AI agent interface
        self.agent_control_service = self.create_service(
            SetBool, '/agent/control', self.agent_control_callback
        )
        self.agent_command_service = self.create_service(
            RobotControl, '/agent/command', self.agent_command_callback
        )
        self.agent_pose_service = self.create_service(
            GetRobotPose, '/agent/get_pose', self.agent_pose_callback
        )

        # Wait for robot services to be available
        self.wait_for_robot_services()

        # Initialize request objects
        self.set_bool_request = SetBool.Request()
        self.control_request = RobotControl.Request()
        self.pose_request = GetRobotPose.Request()
        self.trigger_request = Trigger.Request()

        # Agent state tracking
        self.agent_state = {
            'enabled': True,
            'last_command_time': time.time(),
            'command_count': 0,
            'error_count': 0
        }

        # Thread-safe request queue
        self.request_queue = Queue(maxsize=self.max_concurrent_requests)

        self.get_logger().info('Service Bridge Node initialized')
        self.get_logger().info(f'Service timeout: {self.service_timeout}s')

    def wait_for_robot_services(self):
        """Wait for all robot services to become available."""
        services = [
            (self.motor_control_client, '/motors/enable'),
            (self.control_client, '/robot/control'),
            (self.pose_client, '/robot/get_pose'),
            (self.trigger_client, '/robot/emergency_stop')
        ]

        for client, service_name in services:
            while not client.wait_for_service(timeout_sec=1.0):
                self.get_logger().info(f'Waiting for robot service: {service_name}...')

    def agent_control_callback(self, request, response):
        """Handle agent control requests from Python AI."""
        if not self.bridge_enabled:
            response.success = False
            response.message = 'Bridge is disabled'
            return response

        try:
            self.agent_state['enabled'] = request.data
            status = 'enabled' if request.data else 'disabled'
            response.success = True
            response.message = f'Agent {status} successfully'

            self.get_logger().info(f'Agent control: {status}')
        except Exception as e:
            response.success = False
            response.message = f'Control error: {str(e)}'
            self.get_logger().error(f'Agent control error: {e}')

        return response

    def agent_command_callback(self, request, response):
        """Handle robot command requests from Python AI."""
        if not self.bridge_enabled:
            response.success = False
            response.message = 'Bridge is disabled'
            return response

        if not self.agent_state['enabled']:
            response.success = False
            response.message = 'Agent is disabled'
            return response

        try:
            # Forward the command to the robot
            self.control_request.linear_velocity = request.linear_velocity
            self.control_request.angular_velocity = request.angular_velocity
            self.control_request.enable_motors = request.enable_motors

            # Make the service call to the robot
            future = self.control_client.call_async(self.control_request)

            # Wait for response (this makes it synchronous from the agent's perspective)
            rclpy.spin_until_future_complete(self, future, timeout_sec=self.service_timeout)

            if future.done():
                robot_response = future.result()
                response.success = robot_response.success
                response.message = robot_response.message
                response.execution_time = robot_response.execution_time

                # Update agent state
                self.agent_state['last_command_time'] = time.time()
                self.agent_state['command_count'] += 1

                if robot_response.success:
                    self.get_logger().info(f'Command executed: {robot_response.message}')
                else:
                    self.agent_state['error_count'] += 1
                    self.get_logger().warn(f'Command failed: {robot_response.message}')
            else:
                response.success = False
                response.message = f'Command timed out after {self.service_timeout}s'
                self.agent_state['error_count'] += 1
                self.get_logger().error(f'Command timeout: {response.message}')

        except Exception as e:
            response.success = False
            response.message = f'Command error: {str(e)}'
            self.agent_state['error_count'] += 1
            self.get_logger().error(f'Command error: {e}')

        return response

    def agent_pose_callback(self, request, response):
        """Handle pose request from Python AI."""
        if not self.bridge_enabled:
            response.success = False
            response.message = 'Bridge is disabled'
            return response

        try:
            # Forward the pose request to the robot
            self.pose_request.robot_name = request.robot_name

            # Make the service call to the robot
            future = self.pose_client.call_async(self.pose_request)
            rclpy.spin_until_future_complete(self, future, timeout_sec=self.service_timeout)

            if future.done():
                robot_response = future.result()
                response.x = robot_response.x
                response.y = robot_response.y
                response.theta = robot_response.theta
                response.success = robot_response.success
                response.message = robot_response.message
            else:
                response.success = False
                response.message = f'Pose request timed out after {self.service_timeout}s'
                self.get_logger().error(response.message)

        except Exception as e:
            response.success = False
            response.message = f'Pose request error: {str(e)}'
            self.get_logger().error(f'Pose request error: {e}')

        return response

def main(args=None):
    rclpy.init(args=args)
    bridge = ServiceBridgeNode()

    try:
        rclpy.spin(bridge)
    except KeyboardInterrupt:
        bridge.get_logger().info(
            f'Service bridge interrupted. Stats - Commands: {bridge.agent_state["command_count"]}, '
            f'Errors: {bridge.agent_state["error_count"]}'
        )
    finally:
        bridge.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Advanced Service Bridge with Multiple Agents

```python
import rclpy
from rclpy.node import Node
from std_srvs.srv import SetBool, Trigger
from your_robot_package.srv import RobotControl, GetRobotPose
import time
import threading
from concurrent.futures import ThreadPoolExecutor
from collections import defaultdict

class AdvancedServiceBridgeNode(Node):
    """
    An advanced service bridge supporting multiple AI agents with priority management
    and sophisticated request handling.
    """

    def __init__(self):
        super().__init__('advanced_service_bridge')

        # Declare advanced parameters
        self.declare_parameter('max_concurrent_agents', 5)
        self.declare_parameter('agent_timeout', 10.0)
        self.declare_parameter('priority_levels', 3)  # 0=low, 1=normal, 2=high

        # Get parameter values
        self.max_agents = self.get_parameter('max_concurrent_agents').value
        self.agent_timeout = self.get_parameter('agent_timeout').value
        self.priority_levels = self.get_parameter('priority_levels').value

        # Create service clients for robot
        self.control_client = self.create_client(RobotControl, '/robot/control')
        self.pose_client = self.create_client(GetRobotPose, '/robot/get_pose')
        self.emergency_client = self.create_client(Trigger, '/robot/emergency_stop')

        # Create services for agents
        self.agent_command_service = self.create_service(
            RobotControl, '/multi_agent/command', self.multi_agent_command_callback
        )
        self.agent_status_service = self.create_service(
            GetRobotPose, '/multi_agent/status', self.multi_agent_status_callback
        )

        # Wait for robot services
        self.wait_for_robot_services()

        # Initialize requests
        self.control_request = RobotControl.Request()
        self.pose_request = GetRobotPose.Request()
        self.trigger_request = Trigger.Request()

        # Agent management
        self.active_agents = {}  # Maps agent_id to agent info
        self.agent_priorities = defaultdict(lambda: 1)  # Default to normal priority
        self.request_queue = defaultdict(list)  # Priority level to request queue

        # Thread pool for handling requests
        self.executor = ThreadPoolExecutor(max_workers=10)

        self.get_logger().info('Advanced Service Bridge initialized')

    def wait_for_robot_services(self):
        """Wait for all robot services to be available."""
        services = [
            (self.control_client, '/robot/control'),
            (self.pose_client, '/robot/get_pose'),
            (self.emergency_client, '/robot/emergency_stop')
        ]

        for client, service_name in services:
            while not client.wait_for_service(timeout_sec=1.0):
                self.get_logger().info(f'Waiting for {service_name}...')

    def multi_agent_command_callback(self, request, response):
        """Handle commands from multiple agents with priority management."""
        # Extract agent ID from request (in a real system, this might come from service name or additional field)
        agent_id = getattr(request, 'agent_id', 'default_agent')

        # Check if agent is registered and get priority
        priority = self.agent_priorities[agent_id]

        # Validate request
        if abs(request.linear_velocity) > 2.0 or abs(request.angular_velocity) > 1.0:
            response.success = False
            response.message = 'Invalid velocity values'
            return response

        # Add to appropriate priority queue
        request_item = {
            'agent_id': agent_id,
            'request': request,
            'timestamp': time.time(),
            'priority': priority
        }

        self.request_queue[priority].append(request_item)

        # Process high priority requests first
        self.process_requests_by_priority()

        response.success = True
        response.message = f'Command queued for agent {agent_id} (priority: {priority})'
        return response

    def process_requests_by_priority(self):
        """Process requests starting with highest priority."""
        # Process queues from highest to lowest priority
        for priority_level in sorted(self.request_queue.keys(), reverse=True):
            if self.request_queue[priority_level]:
                request_item = self.request_queue[priority_level].pop(0)
                # Process the request in a separate thread
                self.executor.submit(self.execute_robot_command, request_item)

    def execute_robot_command(self, request_item):
        """Execute a robot command in a separate thread."""
        agent_id = request_item['agent_id']
        request = request_item['request']

        try:
            # Forward to robot
            self.control_request.linear_velocity = request.linear_velocity
            self.control_request.angular_velocity = request.angular_velocity
            self.control_request.enable_motors = request.enable_motors

            future = self.control_client.call_async(self.control_request)

            # Wait for robot response
            rclpy.spin_until_future_complete(self, future, timeout_sec=self.agent_timeout)

            if future.done():
                robot_response = future.result()
                self.get_logger().info(
                    f'Agent {agent_id} command completed: {robot_response.message}'
                )
            else:
                self.get_logger().error(f'Agent {agent_id} command timed out')

        except Exception as e:
            self.get_logger().error(f'Agent {agent_id} command error: {e}')

    def multi_agent_status_callback(self, request, response):
        """Handle status requests from multiple agents."""
        agent_id = getattr(request, 'agent_id', 'default_agent')

        try:
            # Get robot status
            future = self.pose_client.call_async(self.pose_request)
            rclpy.spin_until_future_complete(self, future, timeout_sec=self.agent_timeout)

            if future.done():
                robot_response = future.result()
                response.x = robot_response.x
                response.y = robot_response.y
                response.theta = robot_response.theta
                response.success = robot_response.success
                response.message = f'Status for agent {agent_id}: {robot_response.message}'
            else:
                response.success = False
                response.message = f'Status request for {agent_id} timed out'

        except Exception as e:
            response.success = False
            response.message = f'Status request error for {agent_id}: {str(e)}'

        return response

def main(args=None):
    rclpy.init(args=args)
    advanced_bridge = AdvancedServiceBridgeNode()

    try:
        rclpy.spin(advanced_bridge)
    except KeyboardInterrupt:
        advanced_bridge.get_logger().info('Advanced bridge interrupted')
    finally:
        advanced_bridge.executor.shutdown(wait=True)
        advanced_bridge.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Bridge Benefits

1. **Guaranteed Responses**: Services ensure that operations complete and return results
2. **Synchronous Operations**: Ideal for operations requiring immediate confirmation
3. **Error Handling**: Clear success/failure semantics with detailed error messages
4. **Priority Management**: Can implement sophisticated request prioritization
5. **Resource Management**: Better control over resource allocation and access

<!-- DIAGRAM: Service Bridge - AI Agent to Robot Controller Synchronous Communication -->
<!-- CHUNK END: Python Agent Bridge for Services -->

## Summary

In this section, we've explored services in ROS 2 using `rclpy`. You've learned:

1. **Service server creation** and implementation with proper error handling
2. **Service client implementation** with asynchronous calls and response handling
3. **Custom service types** for specialized applications
4. **Service communication patterns** for synchronous robot control
5. **Python agent bridge patterns** for connecting AI algorithms to robot controllers using services

Services provide a crucial synchronous communication mechanism that complements the asynchronous publish-subscribe pattern, enabling guaranteed operations and immediate responses that are essential for many robotic applications.

## Exercises

1. **Custom Service Creation**: Define and implement a custom service for robot calibration that takes sensor parameters and returns calibration results.

2. **Service Client with Retry**: Create a service client that implements sophisticated retry logic for unreliable services with exponential backoff.

3. **Multi-Agent Service Bridge**: Implement a service bridge that can handle requests from multiple AI agents with different priority levels.

4. **Service Composition**: Create a service that composes multiple other services to perform complex operations (e.g., navigate to position and then perform an action).

5. **Service Performance Monitoring**: Implement a service that tracks and reports performance metrics for other services in the system.

6. **Safety-Enhanced Service**: Create a robot control service that includes safety checks and validation before executing commands.

<!-- DIAGRAM: Exercise Scenarios - Service Communication Applications -->