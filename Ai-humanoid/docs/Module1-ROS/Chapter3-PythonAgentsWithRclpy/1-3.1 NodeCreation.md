---
id: 1-3-1-NodeCreation
sidebar_position: 1
---
---

# Chapter 3-01: Creating Python ROS 2 Nodes with rclpy

<!-- CHUNK START: Introduction to rclpy -->
## Introduction to rclpy

`rclpy` is the Python client library for ROS 2 (Robot Operating System 2) that provides a pure Python implementation of the ROS 2 client library. It allows Python developers to create ROS 2 nodes, publish and subscribe to topics, provide and use services, and work with actions.

ROS 2 is a flexible framework for writing robot software that provides services such as hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more. `rclpy` serves as the bridge between Python applications and the ROS 2 ecosystem, enabling seamless integration of Python-based AI algorithms with robot control systems.

### Learning Objectives

By the end of this section, you will be able to:

1. Create and initialize Python ROS 2 nodes using `rclpy`
2. Understand the node lifecycle and management
3. Implement parameter handling in Python nodes
4. Bridge Python agents to ROS controllers using node patterns
5. Structure node code for RAG (Retrieval-Augmented Generation) indexing

### Prerequisites

Before proceeding, ensure you have:

- Basic Python programming knowledge
- Understanding of ROS 2 concepts (covered in Chapters 1-2)
- ROS 2 Humble Hawksbill installed and sourced
- Basic familiarity with command-line tools

<!-- DIAGRAM: rclpy Architecture - Python to ROS Integration -->
<!-- CHUNK END: Introduction to rclpy -->

<!-- CHUNK START: Basic Node Structure -->
## Basic Node Structure

The fundamental building block of any ROS 2 system is the node. A node in `rclpy` is a Python class that inherits from `rclpy.node.Node`. Here's the minimal structure:

```python
import rclpy
from rclpy.node import Node

class MinimalPublisher(Node):
    """
    A minimal ROS 2 node example that demonstrates basic node structure.
    This node publishes a simple string message to a topic at regular intervals.
    """

    def __init__(self):
        # Initialize the parent Node class with a node name
        super().__init__('minimal_publisher')

        # Create a publisher that sends String messages to the 'topic' topic
        self.publisher_ = self.create_publisher(String, 'topic', 10)

        # Set up a timer to publish messages every 0.5 seconds
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

        # Counter for message numbering
        self.i = 0

    def timer_callback(self):
        """Callback function that executes when the timer fires."""
        msg = String()
        msg.data = 'Hello World: %d' % self.i
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        self.i += 1

def main(args=None):
    """
    Main function that initializes the ROS 2 context, creates the node,
    and starts spinning to process callbacks.
    """
    # Initialize the rclpy library
    rclpy.init(args=args)

    # Create an instance of the node
    minimal_publisher = MinimalPublisher()

    # Start spinning - this keeps the node alive and processes callbacks
    rclpy.spin(minimal_publisher)

    # Clean up when the node is shut down
    minimal_publisher.destroy_node()
    rclpy.shutdown()

# This allows the script to be run directly
if __name__ == '__main__':
    main()
```

### Key Components Explained

1. **Node Inheritance**: Your custom node class inherits from `rclpy.node.Node`
2. **Initialization**: The `__init__` method calls the parent's `__init__` with a unique node name
3. **Publisher Creation**: `create_publisher()` creates a publisher for sending messages
4. **Timer Setup**: `create_timer()` creates a timer that calls a callback function at regular intervals
5. **Message Creation**: Messages are created as instances of specific message types
6. **Logging**: `get_logger().info()` provides logging capabilities
7. **Cleanup**: `destroy_node()` and `rclpy.shutdown()` ensure proper cleanup

<!-- DIAGRAM: Node Structure - Components and Lifecycle -->
<!-- CHUNK END: Basic Node Structure -->

<!-- CHUNK START: Node Lifecycle Management -->
## Node Lifecycle Management

ROS 2 nodes have a well-defined lifecycle that includes initialization, execution, and cleanup phases. Understanding the lifecycle is crucial for creating robust and reliable nodes.

### Standard Lifecycle States

Nodes can exist in various states during their lifetime:

- **Unconfigured**: Node is created but not yet configured
- **Inactive**: Node is configured but not yet active
- **Active**: Node is running and processing callbacks
- **Finalized**: Node has been shut down and cleaned up

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class LifecyclePublisher(Node):
    """
    Example of a node with explicit lifecycle management.
    This node demonstrates proper initialization and cleanup patterns.
    """

    def __init__(self):
        super().__init__('lifecycle_publisher')

        # Initialize publisher as None - will be created in configure method
        self.pub = None
        self.subscription = None

    def setup_publisher(self):
        """Configure the publisher for this node."""
        if self.pub is None:
            self.pub = self.create_publisher(String, 'lifecycle_chatter', 10)
            self.get_logger().info('Publisher created')
        else:
            self.get_logger().info('Publisher already exists')

    def setup_subscriber(self):
        """Configure the subscriber for this node."""
        if self.subscription is None:
            self.subscription = self.create_subscription(
                String,
                'lifecycle_command',
                self.command_callback,
                10
            )
            self.get_logger().info('Subscriber created')
        else:
            self.get_logger().info('Subscriber already exists')

    def command_callback(self, msg):
        """Handle incoming commands."""
        self.get_logger().info(f'Received command: {msg.data}')
        # Process the command based on its content
        if msg.data == 'configure':
            self.setup_publisher()
            self.setup_subscriber()
        elif msg.data == 'publish':
            self.publish_message()

    def publish_message(self):
        """Publish a message if publisher is available."""
        if self.pub is not None:
            msg = String()
            msg.data = f'Message from lifecycle node at {self.get_clock().now()}'
            self.pub.publish(msg)
            self.get_logger().info(f'Published: {msg.data}')

def main(args=None):
    rclpy.init(args=args)

    lifecycle_publisher = LifecyclePublisher()

    try:
        rclpy.spin(lifecycle_publisher)
    except KeyboardInterrupt:
        pass
    finally:
        # Properly destroy the node before shutting down
        lifecycle_publisher.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Lifecycle Best Practices

1. **Initialize in `__init__`**: Set up class variables and basic configuration
2. **Create publishers/subscribers after initialization**: Ensure the node is properly set up first
3. **Handle cleanup**: Always destroy publishers and subscribers when shutting down
4. **Use try-finally blocks**: Ensure cleanup occurs even if exceptions happen
5. **Check for None**: Always verify that publishers/subscribers exist before using them

<!-- DIAGRAM: Node Lifecycle States - Unconfigured to Finalized -->
<!-- CHUNK END: Node Lifecycle Management -->

<!-- CHUNK START: Parameter Handling -->
## Parameter Management

Nodes often need to accept parameters to configure their behavior at runtime. `rclpy` provides a robust parameter system that allows nodes to be configured without code changes.

### Declaring and Using Parameters

```python
import rclpy
from rclpy.node import Node
from rcl_interfaces.msg import ParameterType
from std_msgs.msg import String
import time

class ParameterNode(Node):
    """
    A node that demonstrates parameter handling in ROS 2.
    This node uses parameters to configure its behavior dynamically.
    """

    def __init__(self):
        super().__init__('parameter_node')

        # Declare parameters with default values and descriptions
        # Format: declare_parameter(parameter_name, default_value)
        self.declare_parameter('robot_name', 'turtlebot')
        self.declare_parameter('max_velocity', 1.0)
        self.declare_parameter('control_frequency', 50)
        self.declare_parameter('sensor_topic', '/sensors/laser_scan')
        self.declare_parameter('publish_topic', '/cmd_vel')
        self.declare_parameter('debug_mode', False)

        # Access parameter values after declaration
        self.robot_name = self.get_parameter('robot_name').value
        self.max_velocity = self.get_parameter('max_velocity').value
        self.control_frequency = self.get_parameter('control_frequency').value
        self.sensor_topic = self.get_parameter('sensor_topic').value
        self.publish_topic = self.get_parameter('publish_topic').value
        self.debug_mode = self.get_parameter('debug_mode').value

        # Create publisher based on parameter configuration
        self.publisher = self.create_publisher(String, self.publish_topic, 10)

        # Set up timer based on frequency parameter
        timer_period = 1.0 / self.control_frequency
        self.timer = self.create_timer(timer_period, self.publish_status)

        # Log configuration
        self.get_logger().info(f'Robot: {self.robot_name}')
        self.get_logger().info(f'Max velocity: {self.max_velocity}')
        self.get_logger().info(f'Control frequency: {self.control_frequency} Hz')
        self.get_logger().info(f'Debug mode: {self.debug_mode}')

        # Counter for messages
        self.counter = 0

    def publish_status(self):
        """Publish robot status based on current parameters."""
        msg = String()
        msg.data = f'Status: {self.robot_name}, Counter: {self.counter}, Time: {time.time()}'
        self.publisher.publish(msg)

        if self.debug_mode:
            self.get_logger().info(f'Debug: {msg.data}')

        self.counter += 1

def main(args=None):
    rclpy.init(args=args)

    parameter_node = ParameterNode()

    try:
        rclpy.spin(parameter_node)
    except KeyboardInterrupt:
        pass
    finally:
        parameter_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Parameter Types and Validation

```python
import rclpy
from rclpy.node import Node
from rcl_interfaces.msg import ParameterDescriptor, ParameterType
from rcl_interfaces.srv import SetParameters
from std_msgs.msg import String

class AdvancedParameterNode(Node):
    """
    A node demonstrating advanced parameter features including validation,
    dynamic reconfiguration, and parameter callbacks.
    """

    def __init__(self):
        super().__init__('advanced_parameter_node')

        # Declare parameters with descriptors for validation
        velocity_descriptor = ParameterDescriptor(
            type=ParameterType.PARAMETER_DOUBLE,
            description='Maximum velocity for the robot',
            additional_constraints='Must be between 0.1 and 10.0',
            floating_point_range=[{
                'from_value': 0.1,
                'to_value': 10.0,
                'step': 0.1
            }]
        )

        name_descriptor = ParameterDescriptor(
            type=ParameterType.PARAMETER_STRING,
            description='Name of the robot',
            additional_constraints='Must be alphanumeric and 3-20 characters'
        )

        # Declare parameters with descriptors
        self.declare_parameter('max_velocity', 1.0, velocity_descriptor)
        self.declare_parameter('robot_name', 'default_robot', name_descriptor)
        self.declare_parameter('safety_enabled', True)

        # Set up parameter change callback
        self.add_on_set_parameters_callback(self.parameter_callback)

        # Initialize values
        self.max_velocity = self.get_parameter('max_velocity').value
        self.robot_name = self.get_parameter('robot_name').value
        self.safety_enabled = self.get_parameter('safety_enabled').value

        # Create publisher
        self.publisher = self.create_publisher(String, 'robot_status', 10)

        # Log initial configuration
        self.get_logger().info(f'Advanced Parameter Node initialized')
        self.get_logger().info(f'Robot: {self.robot_name}, Max Velocity: {self.max_velocity}')

    def parameter_callback(self, params):
        """
        Callback function that validates parameter changes.
        This function is called whenever parameters are set.
        """
        for param in params:
            if param.name == 'max_velocity':
                # Validate velocity parameter
                if param.value < 0.1 or param.value > 10.0:
                    self.get_logger().error(f'Invalid velocity: {param.value}. Must be between 0.1 and 10.0')
                    return SetParameters.Result(successful=False, reason='Velocity out of range')

                # Update internal value
                self.max_velocity = param.value
                self.get_logger().info(f'Velocity updated to: {param.value}')

            elif param.name == 'robot_name':
                # Validate name parameter
                if not (3 <= len(param.value) <= 20):
                    self.get_logger().error(f'Invalid robot name length: {len(param.value)}. Must be 3-20 characters')
                    return SetParameters.Result(successful=False, reason='Name length invalid')

                # Update internal value
                self.robot_name = param.value
                self.get_logger().info(f'Robot name updated to: {param.value}')

        # If we get here, all parameters were valid
        return SetParameters.Result(successful=True)

def main(args=None):
    rclpy.init(args=args)

    advanced_node = AdvancedParameterNode()

    try:
        rclpy.spin(advanced_node)
    except KeyboardInterrupt:
        pass
    finally:
        advanced_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Key Parameter Concepts

1. **Declaration**: Parameters must be declared before use with `declare_parameter()`
2. **Types**: ROS 2 supports various parameter types (int, double, string, bool, lists)
3. **Default Values**: Always provide sensible defaults for parameters
4. **Validation**: Use parameter callbacks to validate values before accepting them
5. **Dynamic Reconfiguration**: Parameters can be changed at runtime using ROS 2 tools

<!-- DIAGRAM: Parameter System - Declaration to Runtime Configuration -->
<!-- CHUNK END: Parameter Handling -->

<!-- CHUNK START: Python Agent Bridge Pattern -->
## Python Agent Bridge Pattern

One of the most important applications of `rclpy` is bridging Python-based AI agents to ROS-based robot controllers. This pattern enables AI algorithms implemented in Python to interact with physical robot systems running ROS controllers.

### Basic Bridge Architecture

The bridge pattern involves creating a ROS 2 node that acts as an intermediary between:

1. **Python Agent**: AI algorithms, planning systems, or decision-making components
2. **Bridge Node**: ROS 2 node that translates between Python agent outputs and ROS messages
3. **ROS Controllers**: Robot control systems that execute commands and provide feedback

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Float32
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
import numpy as np
import time

class PythonAgentBridge(Node):
    """
    A bridge node that connects Python AI agents to ROS-based robot controllers.
    This node demonstrates how to integrate AI decision-making with robot control.
    """

    def __init__(self):
        super().__init__('python_agent_bridge')

        # Bridge configuration parameters
        self.declare_parameter('agent_frequency', 10)  # Hz
        self.declare_parameter('safety_distance', 0.5)  # meters
        self.declare_parameter('max_linear_velocity', 1.0)
        self.declare_parameter('max_angular_velocity', 1.0)

        # Get parameter values
        self.agent_frequency = self.get_parameter('agent_frequency').value
        self.safety_distance = self.get_parameter('safety_distance').value
        self.max_linear_vel = self.get_parameter('max_linear_velocity').value
        self.max_angular_vel = self.get_parameter('max_angular_velocity').value

        # Publisher to send commands to robot controller
        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)

        # Subscriber to receive sensor feedback from robot
        self.laser_subscriber = self.create_subscription(
            LaserScan, '/scan', self.laser_callback, 10
        )

        # Subscriber for high-level commands from Python agent
        self.agent_command_subscriber = self.create_subscription(
            String, '/agent_commands', self.agent_command_callback, 10
        )

        # Timer for AI decision-making loop
        timer_period = 1.0 / self.agent_frequency
        self.agent_timer = self.create_timer(timer_period, self.agent_decision_loop)

        # State variables for the bridge
        self.latest_laser_data = None
        self.latest_agent_command = None
        self.safety_mode = False
        self.agent_enabled = True

        # Log initialization
        self.get_logger().info('Python Agent Bridge initialized')
        self.get_logger().info(f'Agent frequency: {self.agent_frequency} Hz')
        self.get_logger().info(f'Safety distance: {self.safety_distance} m')

    def laser_callback(self, msg):
        """Handle incoming laser scan data from the robot."""
        self.latest_laser_data = msg
        self.get_logger().debug(f'Received laser scan with {len(msg.ranges)} ranges')

        # Check for obstacles within safety distance
        if self.latest_laser_data:
            min_range = min(self.latest_laser_data.ranges)
            if min_range < self.safety_distance:
                self.safety_mode = True
                self.get_logger().warn(f'Safety distance violated: {min_range:.2f}m < {self.safety_distance:.2f}m')
            else:
                self.safety_mode = False

    def agent_command_callback(self, msg):
        """Handle high-level commands from the Python agent."""
        self.latest_agent_command = msg.data
        self.get_logger().info(f'Received agent command: {msg.data}')

        # Process special commands
        if msg.data == 'enable':
            self.agent_enabled = True
            self.get_logger().info('Agent enabled')
        elif msg.data == 'disable':
            self.agent_enabled = False
            self.get_logger().info('Agent disabled')
        elif msg.data == 'emergency_stop':
            self.emergency_stop()
        elif msg.data.startswith('set_frequency:'):
            try:
                new_freq = float(msg.data.split(':')[1])
                self.set_agent_frequency(new_freq)
            except ValueError:
                self.get_logger().error(f'Invalid frequency command: {msg.data}')

    def agent_decision_loop(self):
        """Main AI decision-making loop that runs at agent_frequency."""
        if not self.agent_enabled:
            return

        # Safety check - if in safety mode, stop the robot
        if self.safety_mode:
            self.emergency_stop()
            return

        # Process sensor data and make decisions
        if self.latest_laser_data:
            # Example AI decision based on sensor data
            cmd_vel = self.make_navigation_decision()

            # Publish the command to the robot controller
            if cmd_vel:
                self.cmd_vel_publisher.publish(cmd_vel)
                self.get_logger().debug(f'Sent command: linear={cmd_vel.linear.x}, angular={cmd_vel.angular.z}')

    def make_navigation_decision(self):
        """
        Example AI decision-making function.
        This function analyzes sensor data and returns navigation commands.
        """
        if not self.latest_laser_data:
            return None

        # Get ranges in front of the robot (narrow forward sector)
        front_ranges = self.latest_laser_data.ranges[330:] + self.latest_laser_data.ranges[:30]

        # Filter out invalid ranges (inf or nan)
        valid_ranges = [r for r in front_ranges if r != float('inf') and not np.isnan(r)]

        if not valid_ranges:
            # If no valid ranges, go forward slowly
            cmd = Twist()
            cmd.linear.x = 0.2
            cmd.angular.z = 0.0
            return cmd

        # Find minimum distance in front
        min_front_distance = min(valid_ranges) if valid_ranges else float('inf')

        # Simple navigation algorithm
        cmd = Twist()

        if min_front_distance < self.safety_distance * 1.5:  # Buffer zone
            # Too close to obstacle, turn away
            cmd.linear.x = 0.0
            cmd.angular.z = 0.5  # Turn right
        elif min_front_distance < self.safety_distance * 3:
            # Moderate distance, go forward slowly
            cmd.linear.x = 0.3
            cmd.angular.z = 0.0
        else:
            # Safe distance, go forward at normal speed
            cmd.linear.x = 0.8
            cmd.angular.z = 0.0

        return cmd

    def emergency_stop(self):
        """Send emergency stop command to robot."""
        cmd = Twist()
        cmd.linear.x = 0.0
        cmd.angular.z = 0.0
        self.cmd_vel_publisher.publish(cmd)
        self.get_logger().warn('Emergency stop command sent')

    def set_agent_frequency(self, new_frequency):
        """Dynamically adjust the agent decision frequency."""
        if 1.0 <= new_frequency <= 100.0:  # Reasonable range
            self.agent_frequency = new_frequency
            # Update the timer period
            old_period = self.agent_timer.timer_period_ns
            new_period = int(1.0 / new_frequency * 1e9)  # Convert to nanoseconds
            self.agent_timer.change_timer_period(new_period)
            self.get_logger().info(f'Agent frequency changed from {1e9/old_period:.1f}Hz to {new_frequency:.1f}Hz')
        else:
            self.get_logger().error(f'Invalid frequency: {new_frequency}. Must be between 1.0 and 100.0 Hz')

def main(args=None):
    rclpy.init(args=args)

    bridge_node = PythonAgentBridge()

    try:
        rclpy.spin(bridge_node)
        self.get_logger().info('Python Agent Bridge spinning...')
    except KeyboardInterrupt:
        bridge_node.get_logger().info('Interrupted, shutting down...')
    finally:
        bridge_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Bridge Pattern Benefits

1. **Decoupling**: AI agents and robot controllers can be developed independently
2. **Flexibility**: Different AI algorithms can be swapped without changing robot controllers
3. **Safety**: The bridge can implement safety checks and emergency procedures
4. **Scalability**: Multiple agents can interact with the same robot through the bridge
5. **Debugging**: Communication between agent and robot can be monitored and logged

### Advanced Bridge Features

The example above demonstrates several advanced features:

- **Parameter-based configuration** for runtime adjustability
- **Safety systems** that can override agent decisions
- **Dynamic frequency adjustment** for performance tuning
- **Sensor data processing** for AI decision-making
- **Emergency stop capabilities** for safety

<!-- DIAGRAM: Python Agent Bridge - AI to ROS Controller Connection -->
<!-- CHUNK END: Python Agent Bridge Pattern -->

## Summary

In this section, we've covered the fundamentals of creating Python ROS 2 nodes using `rclpy`. You've learned:

1. **Basic node structure** and initialization patterns
2. **Node lifecycle management** for robust operation
3. **Parameter handling** for configurable behavior
4. **Python agent bridge patterns** for connecting AI algorithms to robot controllers

These concepts form the foundation for building more complex ROS 2 systems that integrate Python-based AI with robot control systems.

## Exercises

1. **Basic Node Creation**: Create a node that publishes the current timestamp to a topic every second. Include parameters for controlling the publishing frequency.

2. **Parameter Validation**: Extend the parameter example to include validation for a robot's operational mode (e.g., "navigation", "manipulation", "inspection") using parameter callbacks.

3. **Simple Bridge Implementation**: Create a bridge node that takes high-level commands (e.g., "go forward", "turn left", "stop") from a Python agent and converts them to Twist messages for a robot controller.

4. **Safety-Enhanced Bridge**: Modify your bridge implementation to include safety checks based on sensor data (e.g., stop if obstacles are too close).

5. **Parameter Tuning**: Implement a bridge node where the AI decision-making parameters (like safety distance, speeds, etc.) can be adjusted at runtime using ROS 2 parameter tools.

<!-- DIAGRAM: Exercise Scenarios - Practical Applications -->