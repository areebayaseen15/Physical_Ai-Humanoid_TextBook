---
id: 1-2-4-Actions
sidebar_position: 4
title: 2.4 - Actions
---
---

# 2.4 Actions: Asynchronous Goal-Oriented Tasks

## Learning Objectives
- Explain the asynchronous goal/feedback/result communication model for long-running tasks.
- Implement ROS 2 action servers and clients in Python using `rclpy`.
- Define and use custom ROS IDL action types.
- Understand how to manage asynchronous execution, handle feedback, and implement task cancellation.

## Key Concepts
- **ROS 2 Actions**: Asynchronous goal/feedback/result communication pattern
- **Action Server**: Node that executes long-running tasks
- **Action Client**: Node that sends goals and receives feedback/results
- **Goal**: Request sent to an action server
- **Feedback**: Periodic updates during task execution
- **Result**: Final outcome of the task
- **Task Cancellation**: Mechanism to stop long-running tasks

This section provides a detailed explanation of actions for long-running, asynchronous tasks. It covers the components: goal, feedback, and result. Step-by-step guidance on implementing Python action servers and clients with `rclpy` is provided, including how to handle goal acceptance, continuous feedback publishing, and result processing. Critical aspects like task cancellation and asynchronous programming patterns (e.g., using `Future` objects) are covered. The creation of custom `.action` files using ROS IDL is demonstrated.

<!-- DIAGRAM: Detailed Action client-server interaction flow -->

## Basic Action Server Implementation

```python
import rclpy
from rclpy.action import ActionServer, ActionClient, CancelResponse, GoalResponse
from rclpy.node import Node
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor

# Assuming custom action type in my_robot_controller/action/Fibonacci.action
# int32 order
# ---
# int32[] sequence
# ---
# int32[] partial_sequence
from my_robot_controller.action import Fibonacci # Import custom action

import time

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback,
            goal_callback=self.goal_callback,
            handle_accepted_callback=self.handle_accepted_callback,
            cancel_callback=self.cancel_callback,
            callback_group=ReentrantCallbackGroup() # Use reentrant group for concurrent callbacks
        )
        self.get_logger().info('Fibonacci Action Server Ready.')

    def goal_callback(self, goal_request):
        self.get_logger().info(f'Received goal request with order {goal_request.order}')
        # Validate goal request
        if goal_request.order > 1000: # Example validation
            self.get_logger().warn('Goal order too high, rejecting.')
            return GoalResponse.REJECT
        return GoalResponse.ACCEPT

    def handle_accepted_callback(self, goal_handle):
        self.get_logger().info('Goal accepted, executing...')
        # Start a new thread for execution to avoid blocking the main executor
        # In a real robot, this would offload to a control loop
        import threading
        thread = threading.Thread(target=self.execute_callback, args=(goal_handle,))
        thread.start()

    def cancel_callback(self, goal_handle):
        self.get_logger().info('Received cancel request')
        # Implement logic to stop the long-running task if possible
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.partial_sequence = [0, 1]

        # Fibonacci sequence generation
        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled by client.')
                return Fibonacci.Result()

            feedback_msg.partial_sequence.append(
                feedback_msg.partial_sequence[i] + feedback_msg.partial_sequence[i-1]
            )
            self.get_logger().info(f'Feedback: {feedback_msg.partial_sequence[-1]}')
            goal_handle.publish_feedback(feedback_msg)
            time.sleep(0.5) # Simulate work

        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.partial_sequence
        self.get_logger().info('Goal succeeded.')
        return result

def main(args=None):
    rclpy.init(args=args)
    executor = MultiThreadedExecutor()
    action_server_node = FibonacciActionServer()
    executor.add_node(action_server_node)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        executor.shutdown()
        action_server_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Basic Action Client Implementation

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node

# Assuming custom action type in my_robot_controller/action/Fibonacci.action
from my_robot_controller.action import Fibonacci # Import custom action

import time
import sys

class FibonacciActionClient(Node):
    def __init__(self):
        super().__init__('fibonacci_action_client')
        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')

    def send_goal(self, order):
        self.get_logger().info('Waiting for action server...')
        self._action_client.wait_for_server()

        goal_msg = Fibonacci.Goal()
        goal_msg.order = order

        self.get_logger().info(f'Sending goal request: {order}')

        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback)

        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected :(')
            return

        self.get_logger().info('Goal accepted :)')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Result: {result.sequence}')
        rclpy.shutdown() # Shutdown rclpy once result is received

    def feedback_callback(self, feedback_msg):
        self.get_logger().info(f'Received feedback: {feedback_msg.feedback.partial_sequence[-1]}')

def main(args=None):
    rclpy.init(args=args)

    if len(sys.argv) != 2:
        print('Usage: ros2 run <package_name> fibonacci_action_client <order>')
        return

    action_client_node = FibonacciActionClient()
    action_client_node.send_goal(int(sys.argv[1]))

    rclpy.spin(action_client_node) # Spin until rclpy.shutdown() is called in get_result_callback

if __name__ == '__main__':
    main()
```

## Custom Action Definition

```python
# In my_robot_controller/action/MoveToGoal.action
# float32 target_x
# float32 target_y
# ---
# bool success
# float32 final_x
# float32 final_y
# ---
# float32 current_x
# float32 current_y
# float32 distance_to_goal
```