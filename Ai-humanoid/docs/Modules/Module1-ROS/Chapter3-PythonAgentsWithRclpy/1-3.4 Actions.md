---
id: 1-3-4-Actions
title: 1 3.4 Actions
sidebar_label: 1 3.4 Actions
sidebar_position: 0
---
# Chapter 3-04: Python Action Clients and Servers with rclpy

<!-- CHUNK START: Introduction to Actions -->
## Introduction to Actions in ROS 2

Actions in ROS 2 (Robot Operating System 2) provide a communication pattern for long-running tasks that require feedback, goal management, and cancellation capabilities. Unlike services, which are synchronous and provide a single response, or topics, which are asynchronous and continuous, actions combine the best of both worlds by enabling long-running operations with intermediate feedback and the ability to cancel operations in progress.

Actions are particularly useful for robotic applications such as navigation, manipulation, trajectory execution, and any task that takes a significant amount of time to complete while requiring ongoing communication about progress and status.

### Learning Objectives

By the end of this section, you will be able to:

1. Create action servers that handle long-running tasks with feedback
2. Create action clients that send goals and receive feedback and results
3. Implement custom action types for specific applications
4. Handle goal preemption, cancellation, and result reporting
5. Bridge Python AI agents to ROS controllers using action communication
6. Structure action communication content for RAG (Retrieval-Augmented Generation) indexing

### Key Concepts

- **Action**: A communication pattern for long-running tasks with feedback
- **Action Server**: A node that executes long-running goals and provides feedback
- **Action Client**: A node that sends goals and receives feedback/results
- **Goal**: A request for a long-running operation
- **Feedback**: Intermediate status updates during goal execution
- **Result**: Final outcome of a completed goal
- **Goal ID**: Unique identifier for tracking individual goals

<!-- DIAGRAM: Action Pattern - Goal, Feedback, and Result Flow -->
<!-- CHUNK END: Introduction to Actions -->

<!-- CHUNK START: Creating Action Servers -->
## Creating Action Servers

Action servers in ROS 2 handle long-running tasks that provide feedback during execution and return results upon completion. Creating an action server in `rclpy` involves using the `create_action_server()` method of a node instance, which requires an action type and callback functions for handling goals, executions, and cancellations.

### Basic Action Server Implementation

First, let's define a simple action type. In a real project, this would be in an `.action` file:

```
# In your_robot_package/action/Fibonacci.action
int32 order
---
int32[] sequence
---
int32[] partial_sequence
```

Then implement the action server:

```python
import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from your_robot_package.action import Fibonacci  # Custom action type
from rclpy.executors import MultiThreadedExecutor
import time
import threading

class BasicActionServer(Node):
    """
    A basic action server that demonstrates the fundamental concepts of
    creating and implementing an action server in ROS 2 using rclpy.
    """

    def __init__(self):
        super().__init__('basic_action_server')

        # Create the action server
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            handle_accepted_callback=self.handle_accepted_callback,
            cancel_callback=self.cancel_callback
        )

        self.get_logger().info('Basic Action Server initialized')

    def goal_callback(self, goal_request):
        """
        Accept or reject a goal.
        This method is called when a new goal is received.
        """
        self.get_logger().info(f'Received goal request with order: {goal_request.order}')

        # Accept all goals for this example
        # In a real application, you might reject goals based on criteria
        if goal_request.order > 0 and goal_request.order < 100:
            return GoalResponse.ACCEPT
        else:
            self.get_logger().warn(f'Rejecting goal with invalid order: {goal_request.order}')
            return GoalResponse.REJECT

    def handle_accepted_callback(self, goal_handle):
        """
        Handle an accepted goal.
        This method is called when a goal is accepted.
        """
        self.get_logger().info('Goal accepted, executing...')

        # Create a thread to execute the goal
        # This allows the main thread to continue handling other requests
        goal_thread = threading.Thread(target=self.execute_goal, args=(goal_handle,))
        goal_thread.start()

    def cancel_callback(self, goal_handle):
        """
        Accept or reject a cancel request.
        This method is called when a cancel request is received.
        """
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """
        Execute the goal.
        This method is called in a separate thread when the goal is executed.
        """
        # This method is called by the action server when the goal is ready to execute
        # However, in our implementation, execution happens in the thread created by handle_accepted_callback
        # So this method will not be used directly in this example
        pass

    def execute_goal(self, goal_handle):
        """
        Execute the actual goal in a separate thread.
        """
        # Create feedback message
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.partial_sequence = [0, 1]

        # Check if the goal was canceled when it was accepted
        if goal_handle.is_cancel_requested:
            goal_handle.canceled()
            self.get_logger().info('Goal canceled')
            return

        # Calculate Fibonacci sequence
        order = goal_handle.request.order
        sequence = [0, 1]

        # Send initial feedback
        goal_handle.publish_feedback(feedback_msg)

        # Calculate the sequence
        for i in range(1, order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled during execution')
                return

            # Update sequence
            next_fib = sequence[i] + sequence[i-1]
            sequence.append(next_fib)

            # Update feedback
            feedback_msg.partial_sequence = sequence.copy()
            goal_handle.publish_feedback(feedback_msg)

            # Log progress
            self.get_logger().info(f'Fibonacci progress: {len(sequence)}/{order+2}')

            # Simulate processing time
            time.sleep(0.5)

        # Create result message
        result = Fibonacci.Result()
        result.sequence = sequence

        # Check if the goal was canceled before completion
        if goal_handle.is_cancel_requested:
            goal_handle.canceled()
            self.get_logger().info('Goal canceled before completion')
        else:
            goal_handle.succeed()
            self.get_logger().info(f'Fibonacci sequence completed: {sequence}')

        # Return result
        return result

def main(args=None):
    rclpy.init(args=args)

    action_server = BasicActionServer()

    try:
        # Use MultiThreadedExecutor to handle the threaded execution
        executor = MultiThreadedExecutor()
        executor.add_node(action_server)
        executor.spin()
    except KeyboardInterrupt:
        action_server.get_logger().info('Interrupted, shutting down...')
    finally:
        action_server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Parameterized Action Server

```python
import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from your_robot_package.action import Fibonacci
from rclpy.executors import MultiThreadedExecutor
import time
import threading
from enum import Enum

class GoalStatus(Enum):
    PENDING = 1
    EXECUTING = 2
    CANCELING = 3
    SUCCEEDED = 4
    CANCELED = 5
    ABORTED = 6

class ParameterizedActionServer(Node):
    """
    An action server that uses parameters to configure its behavior.
    This demonstrates how to make action servers configurable at runtime.
    """

    def __init__(self):
        super().__init__('parameterized_action_server')

        # Declare parameters for action configuration
        self.declare_parameter('max_fibonacci_order', 20)
        self.declare_parameter('calculation_delay', 0.2)  # seconds between steps
        self.declare_parameter('action_timeout', 30.0)   # seconds
        self.declare_parameter('enable_feedback', True)

        # Get parameter values
        self.max_order = self.get_parameter('max_fibonacci_order').value
        self.delay = self.get_parameter('calculation_delay').value
        self.timeout = self.get_parameter('action_timeout').value
        self.enable_feedback = self.get_parameter('enable_feedback').value

        # Create the action server
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'parameterized_fibonacci',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            handle_accepted_callback=self.handle_accepted_callback,
            cancel_callback=self.cancel_callback
        )

        # Track active goals
        self.active_goals = {}

        # Log configuration
        self.get_logger().info(f'Parameterized Action Server initialized')
        self.get_logger().info(f'Max order: {self.max_order}')
        self.get_logger().info(f'Delay: {self.delay}s')
        self.get_logger().info(f'Timeout: {self.timeout}s')
        self.get_logger().info(f'Feedback enabled: {self.enable_feedback}')

    def goal_callback(self, goal_request):
        """Accept or reject goals based on parameters."""
        self.get_logger().info(f'Received goal: order={goal_request.order}')

        # Validate goal based on parameters
        if goal_request.order <= 0:
            self.get_logger().warn('Rejecting goal: order must be positive')
            return GoalResponse.REJECT

        if goal_request.order > self.max_order:
            self.get_logger().warn(f'Rejecting goal: order {goal_request.order} exceeds max {self.max_order}')
            return GoalResponse.REJECT

        return GoalResponse.ACCEPT

    def handle_accepted_callback(self, goal_handle):
        """Handle an accepted goal."""
        self.get_logger().info(f'Goal {goal_handle.goal_id.uuid} accepted')

        # Store goal in active goals
        self.active_goals[str(goal_handle.goal_id.uuid)] = {
            'status': GoalStatus.PENDING,
            'start_time': time.time(),
            'goal_handle': goal_handle
        }

        # Execute in a separate thread
        goal_thread = threading.Thread(target=self.execute_goal, args=(goal_handle,))
        goal_thread.start()

    def cancel_callback(self, goal_handle):
        """Handle cancel requests."""
        goal_id = str(goal_handle.goal_id.uuid)
        self.get_logger().info(f'Received cancel request for goal {goal_id}')

        if goal_id in self.active_goals:
            self.active_goals[goal_id]['status'] = GoalStatus.CANCELING

        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """Execute callback (not directly used in this implementation)."""
        pass

    def execute_goal(self, goal_handle):
        """Execute the goal in a separate thread."""
        goal_id = str(goal_handle.goal_id.uuid)
        self.active_goals[goal_id]['status'] = GoalStatus.EXECUTING

        try:
            # Initialize feedback
            feedback_msg = Fibonacci.Feedback()
            feedback_msg.partial_sequence = [0, 1]

            # Check for cancellation
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.active_goals[goal_id]['status'] = GoalStatus.CANCELED
                self.get_logger().info(f'Goal {goal_id} canceled before execution')
                return

            # Calculate Fibonacci sequence
            order = goal_handle.request.order
            sequence = [0, 1]

            # Send initial feedback if enabled
            if self.enable_feedback:
                goal_handle.publish_feedback(feedback_msg)

            # Calculate the sequence with timeout
            start_time = time.time()
            for i in range(1, order):
                # Check for cancellation
                if goal_handle.is_cancel_requested:
                    goal_handle.canceled()
                    self.active_goals[goal_id]['status'] = GoalStatus.CANCELED
                    self.get_logger().info(f'Goal {goal_id} canceled during execution')
                    return

                # Check for timeout
                if time.time() - start_time > self.timeout:
                    goal_handle.abort()
                    self.active_goals[goal_id]['status'] = GoalStatus.ABORTED
                    self.get_logger().error(f'Goal {goal_id} timed out after {self.timeout}s')
                    return

                # Calculate next Fibonacci number
                next_fib = sequence[i] + sequence[i-1]
                sequence.append(next_fib)

                # Send feedback if enabled
                if self.enable_feedback:
                    feedback_msg.partial_sequence = sequence.copy()
                    goal_handle.publish_feedback(feedback_msg)

                # Log progress periodically
                if len(sequence) % 5 == 0:  # Log every 5 numbers
                    self.get_logger().info(f'Goal {goal_id}: Progress {len(sequence)}/{order+2}')

                # Simulate processing time
                time.sleep(self.delay)

            # Create result
            result = Fibonacci.Result()
            result.sequence = sequence

            # Check final status
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.active_goals[goal_id]['status'] = GoalStatus.CANCELED
                self.get_logger().info(f'Goal {goal_id} canceled before completion')
            else:
                goal_handle.succeed()
                self.active_goals[goal_id]['status'] = GoalStatus.SUCCEEDED
                self.get_logger().info(f'Goal {goal_id} succeeded: {sequence}')

        except Exception as e:
            self.get_logger().error(f'Error executing goal {goal_id}: {e}')
            goal_handle.abort()
            self.active_goals[goal_id]['status'] = GoalStatus.ABORTED

        finally:
            # Remove from active goals
            if goal_id in self.active_goals:
                del self.active_goals[goal_id]

def main(args=None):
    rclpy.init(args=args)

    param_server = ParameterizedActionServer()

    try:
        executor = MultiThreadedExecutor()
        executor.add_node(param_server)
        executor.spin()
    except KeyboardInterrupt:
        param_server.get_logger().info('Interrupted, shutting down...')
    finally:
        param_server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Advanced Action Server with Multiple Actions

```python
import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from your_robot_package.action import Fibonacci
from geometry_msgs.action import NavigateToPose
from control_msgs.action import FollowJointTrajectory
from rclpy.executors import MultiThreadedExecutor
import time
import threading
from enum import Enum
from typing import Dict, Any

class AdvancedActionServer(Node):
    """
    An advanced action server that handles multiple action types
    with sophisticated goal management and resource allocation.
    """

    def __init__(self):
        super().__init__('advanced_action_server')

        # Create multiple action servers
        self.fibonacci_server = ActionServer(
            self,
            Fibonacci,
            'compute_fibonacci',
            execute_callback=self.fibonacci_execute_callback,
            goal_callback=self.fibonacci_goal_callback,
            handle_accepted_callback=self.fibonacci_handle_accepted,
            cancel_callback=self.fibonacci_cancel_callback
        )

        # For this example, we'll just define the servers
        # In a real system, you'd implement all action types

        # Resource management
        self.max_concurrent_goals = 3
        self.active_goal_count = 0
        self.active_goal_lock = threading.Lock()

        # Goal tracking
        self.goal_info: Dict[str, Dict[str, Any]] = {}

        self.get_logger().info('Advanced Action Server initialized')

    def fibonacci_goal_callback(self, goal_request):
        """Goal callback for Fibonacci action."""
        with self.active_goal_lock:
            if self.active_goal_count >= self.max_concurrent_goals:
                self.get_logger().warn('Max concurrent goals reached, rejecting new goal')
                return GoalResponse.REJECT

        self.get_logger().info(f'Fibonacci goal request: order={goal_request.order}')
        return GoalResponse.ACCEPT

    def fibonacci_handle_accepted(self, goal_handle):
        """Handle accepted Fibonacci goal."""
        goal_id = str(goal_handle.goal_id.uuid)

        with self.active_goal_lock:
            self.active_goal_count += 1
            self.goal_info[goal_id] = {
                'type': 'fibonacci',
                'start_time': time.time(),
                'goal_handle': goal_handle
            }

        goal_thread = threading.Thread(
            target=self.fibonacci_execute,
            args=(goal_handle,)
        )
        goal_thread.start()

    def fibonacci_cancel_callback(self, goal_handle):
        """Cancel callback for Fibonacci action."""
        goal_id = str(goal_handle.goal_id.uuid)
        self.get_logger().info(f'Received cancel for Fibonacci goal {goal_id}')

        if goal_id in self.goal_info:
            self.goal_info[goal_id]['status'] = 'canceling'

        return CancelResponse.ACCEPT

    def fibonacci_execute_callback(self, goal_handle):
        """Execute callback (not directly used in this implementation)."""
        pass

    def fibonacci_execute(self, goal_handle):
        """Execute Fibonacci goal."""
        goal_id = str(goal_handle.goal_id.uuid)

        try:
            # Simulate computation with feedback
            feedback_msg = Fibonacci.Feedback()
            sequence = [0, 1]
            feedback_msg.partial_sequence = sequence.copy()

            order = goal_handle.request.order

            # Check for cancellation before starting
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info(f'Fibonacci goal {goal_id} canceled before start')
                return

            # Send initial feedback
            goal_handle.publish_feedback(feedback_msg)

            # Calculate Fibonacci sequence
            for i in range(1, order):
                # Check for cancellation during execution
                if goal_handle.is_cancel_requested:
                    goal_handle.canceled()
                    self.get_logger().info(f'Fibonacci goal {goal_id} canceled during execution')
                    return

                # Calculate next number
                next_fib = sequence[i] + sequence[i-1]
                sequence.append(next_fib)

                # Send feedback
                feedback_msg.partial_sequence = sequence.copy()
                goal_handle.publish_feedback(feedback_msg)

                # Simulate processing time
                time.sleep(0.1)

            # Complete the goal
            result = Fibonacci.Result()
            result.sequence = sequence
            goal_handle.succeed()
            self.get_logger().info(f'Fibonacci goal {goal_id} completed successfully')

        except Exception as e:
            self.get_logger().error(f'Error in Fibonacci goal {goal_id}: {e}')
            goal_handle.abort()

        finally:
            # Update goal tracking
            with self.active_goal_lock:
                if goal_id in self.goal_info:
                    del self.goal_info[goal_id]
                self.active_goal_count -= 1

def main(args=None):
    rclpy.init(args=args)

    advanced_server = AdvancedActionServer()

    try:
        executor = MultiThreadedExecutor()
        executor.add_node(advanced_server)
        executor.spin()
    except KeyboardInterrupt:
        advanced_server.get_logger().info('Interrupted, shutting down...')
    finally:
        advanced_server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Action Server Best Practices

1. **Threading**: Use separate threads for goal execution to avoid blocking the main thread
2. **Cancellation**: Properly handle cancellation requests and check `is_cancel_requested`
3. **Feedback**: Send regular feedback updates to keep clients informed
4. **Error Handling**: Handle exceptions and abort goals when necessary
5. **Resource Management**: Track active goals and manage system resources
6. **Timeouts**: Implement appropriate timeouts for long-running operations

<!-- DIAGRAM: Action Server Architecture - Goal Handling and Execution -->
<!-- CHUNK END: Creating Action Servers -->

<!-- CHUNK START: Creating Action Clients -->
## Creating Action Clients

Action clients in ROS 2 send goals to action servers and receive feedback and results during the execution of long-running tasks. Creating an action client in `rclpy` involves using the `create_action_client()` method of a node instance, followed by sending goals and handling feedback and results.

### Basic Action Client Implementation

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from your_robot_package.action import Fibonacci
import time

class BasicActionClient(Node):
    """
    A basic action client that demonstrates how to create and use
    action clients in ROS 2 using rclpy.
    """

    def __init__(self):
        super().__init__('basic_action_client')

        # Create the action client
        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')

        # Wait for the action server to be available
        self.get_logger().info('Waiting for action server...')
        self._action_client.wait_for_server()

        # Create a goal request
        self._goal_request = Fibonacci.Goal()

        # Timer to send goals periodically
        self.timer = self.create_timer(5.0, self.send_goal)

        self.get_logger().info('Basic Action Client initialized')

    def send_goal(self):
        """Send a goal to the action server."""
        # Set the goal parameters
        self._goal_request.order = 10

        self.get_logger().info(f'Sending goal: Fibonacci order {self._goal_request.order}')

        # Send the goal and register callbacks
        self._send_goal_future = self._action_client.send_goal_async(
            self._goal_request,
            feedback_callback=self.feedback_callback
        )

        # Add a callback for when the goal is accepted
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        """Handle the goal response."""
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected by server')
            return

        self.get_logger().info('Goal accepted by server')

        # Get the result future
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def feedback_callback(self, feedback_msg):
        """Handle feedback from the action server."""
        self.get_logger().info(
            f'Received feedback: {len(feedback_msg.partial_sequence)} numbers calculated'
        )

    def get_result_callback(self, future):
        """Handle the final result."""
        result = future.result().result
        self.get_logger().info(f'Result: {result.sequence}')
        self.get_logger().info('Goal completed')

def main(args=None):
    rclpy.init(args=args)

    action_client = BasicActionClient()

    try:
        rclpy.spin(action_client)
    except KeyboardInterrupt:
        action_client.get_logger().info('Interrupted, shutting down...')
    finally:
        action_client.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Advanced Action Client with Goal Management

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from your_robot_package.action import Fibonacci
import time
import threading
from enum import Enum
from typing import Dict, Any

class GoalState(Enum):
    PENDING = 1
    ACTIVE = 2
    CANCELING = 3
    SUCCEEDED = 4
    CANCELED = 5
    ABORTED = 6

class AdvancedActionClient(Node):
    """
    An advanced action client with sophisticated goal management,
    error handling, and multiple concurrent goal support.
    """

    def __init__(self):
        super().__init__('advanced_action_client')

        # Create the action client
        self._action_client = ActionClient(self, Fibonacci, 'parameterized_fibonacci')

        # Wait for the action server to be available
        self.get_logger().info('Waiting for action server...')
        self._action_client.wait_for_server()

        # Goal request template
        self._goal_request = Fibonacci.Goal()

        # Goal management
        self.active_goals: Dict[str, Dict[str, Any]] = {}
        self.goal_counter = 0

        # Configuration parameters
        self.declare_parameter('goal_frequency', 0.2)  # goals per second
        self.declare_parameter('max_active_goals', 5)
        self.declare_parameter('enable_cancellation', True)

        self.goal_frequency = self.get_parameter('goal_frequency').value
        self.max_active_goals = self.get_parameter('max_active_goals').value
        self.enable_cancellation = self.get_parameter('enable_cancellation').value

        # Timer for sending goals
        timer_period = 1.0 / self.goal_frequency
        self.timer = self.create_timer(timer_period, self.send_next_goal)

        # Timer for goal management (cancellation, etc.)
        self.management_timer = self.create_timer(2.0, self.manage_goals)

        self.get_logger().info('Advanced Action Client initialized')

    def send_next_goal(self):
        """Send the next goal if under the active goal limit."""
        active_count = sum(1 for goal_info in self.active_goals.values()
                          if goal_info['state'] in [GoalState.PENDING, GoalState.ACTIVE])

        if active_count >= self.max_active_goals:
            self.get_logger().debug(f'Max active goals ({self.max_active_goals}) reached')
            return

        # Create and send a new goal
        self.goal_counter += 1
        goal_order = (self.goal_counter % 10) + 5  # Cycle through orders 5-14

        self._goal_request.order = goal_order
        goal_id = f'goal_{self.goal_counter}'

        self.get_logger().info(f'Sending goal {goal_id}: Fibonacci order {goal_order}')

        # Send the goal
        send_goal_future = self._action_client.send_goal_async(
            self._goal_request,
            feedback_callback=self.feedback_callback
        )

        # Store goal information
        self.active_goals[goal_id] = {
            'goal_request': self._goal_request.order,
            'state': GoalState.PENDING,
            'timestamp': time.time(),
            'send_future': send_goal_future,
            'goal_handle': None
        }

        # Add callback for goal response
        send_goal_future.add_done_callback(
            lambda future, gid=goal_id: self.goal_response_callback(future, gid)
        )

    def goal_response_callback(self, future, goal_id):
        """Handle the goal response."""
        try:
            goal_handle = future.result()

            if not goal_handle.accepted:
                self.get_logger().warn(f'Goal {goal_id} rejected by server')
                if goal_id in self.active_goals:
                    self.active_goals[goal_id]['state'] = GoalState.ABORTED
                return

            self.get_logger().info(f'Goal {goal_id} accepted by server')

            # Update goal state and handle
            self.active_goals[goal_id]['state'] = GoalState.ACTIVE
            self.active_goals[goal_id]['goal_handle'] = goal_handle

            # Get the result future
            get_result_future = goal_handle.get_result_async()
            get_result_future.add_done_callback(
                lambda future, gid=goal_id: self.get_result_callback(future, gid)
            )

        except Exception as e:
            self.get_logger().error(f'Error handling goal response for {goal_id}: {e}')
            if goal_id in self.active_goals:
                self.active_goals[goal_id]['state'] = GoalState.ABORTED

    def feedback_callback(self, feedback_msg):
        """Handle feedback from the action server."""
        # In a real system, you might want to associate feedback with specific goals
        # For this example, we'll just log the feedback
        self.get_logger().debug(
            f'Received feedback: {len(feedback_msg.partial_sequence)} numbers calculated'
        )

    def get_result_callback(self, future, goal_id):
        """Handle the final result."""
        try:
            goal_result = future.result()
            result = goal_result.result
            status = goal_result.status

            # Update goal state based on result status
            if status == 2:  # SUCCEEDED
                self.active_goals[goal_id]['state'] = GoalState.SUCCEEDED
                self.get_logger().info(f'Goal {goal_id} succeeded: {result.sequence}')
            elif status == 5:  # CANCELED
                self.active_goals[goal_id]['state'] = GoalState.CANCELED
                self.get_logger().info(f'Goal {goal_id} was canceled')
            else:
                self.active_goals[goal_id]['state'] = GoalState.ABORTED
                self.get_logger().warn(f'Goal {goal_id} was aborted with status {status}')

        except Exception as e:
            self.get_logger().error(f'Error getting result for {goal_id}: {e}')
            if goal_id in self.active_goals:
                self.active_goals[goal_id]['state'] = GoalState.ABORTED

    def manage_goals(self):
        """Periodic goal management tasks."""
        current_time = time.time()

        # Check for stuck goals (not updated in a long time)
        for goal_id, goal_info in list(self.active_goals.items()):
            if goal_info['state'] in [GoalState.ACTIVE, GoalState.CANCELING]:
                time_since_update = current_time - goal_info['timestamp']

                # If a goal has been active for more than 60 seconds, consider canceling it
                if time_since_update > 60 and self.enable_cancellation:
                    self.get_logger().warn(f'Goal {goal_id} appears stuck, canceling...')
                    self.cancel_goal(goal_id)

        # Log active goal statistics
        state_counts = {}
        for goal_info in self.active_goals.values():
            state = goal_info['state']
            state_counts[state] = state_counts.get(state, 0) + 1

        self.get_logger().info(f'Goal statistics: {state_counts}')

    def cancel_goal(self, goal_id):
        """Cancel a specific goal."""
        if goal_id not in self.active_goals:
            self.get_logger().warn(f'Attempted to cancel non-existent goal: {goal_id}')
            return

        goal_info = self.active_goals[goal_id]
        goal_handle = goal_info.get('goal_handle')

        if goal_handle:
            cancel_future = goal_handle.cancel_goal_async()
            cancel_future.add_done_callback(
                lambda future, gid=goal_id: self.cancel_response_callback(future, gid)
            )
            goal_info['state'] = GoalState.CANCELING
            self.get_logger().info(f'Cancel request sent for goal {goal_id}')
        else:
            self.get_logger().warn(f'No goal handle for {goal_id}, cannot cancel')

    def cancel_response_callback(self, future, goal_id):
        """Handle cancel response."""
        try:
            cancel_response = future.result()
            self.get_logger().info(f'Cancel response for {goal_id}: {cancel_response}')
        except Exception as e:
            self.get_logger().error(f'Error handling cancel response for {goal_id}: {e}')

def main(args=None):
    rclpy.init(args=args)

    advanced_client = AdvancedActionClient()

    try:
        rclpy.spin(advanced_client)
    except KeyboardInterrupt:
        advanced_client.get_logger().info('Interrupted, shutting down...')
    finally:
        advanced_client.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Action Client with Timeout and Retry Logic

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from your_robot_package.action import Fibonacci
import time
import threading
from typing import Dict, Any
from enum import Enum

class TimeoutActionClient(Node):
    """
    An action client with sophisticated timeout and retry mechanisms
    for handling unreliable action servers.
    """

    def __init__(self):
        super().__init__('timeout_action_client')

        # Create the action client
        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')

        # Wait for the action server to be available
        self.get_logger().info('Waiting for action server...')
        self._action_client.wait_for_server()

        # Goal request template
        self._goal_request = Fibonacci.Goal()

        # Configuration
        self.declare_parameter('goal_timeout', 30.0)  # seconds
        self.declare_parameter('max_retries', 3)
        self.declare_parameter('retry_delay', 2.0)   # seconds

        self.goal_timeout = self.get_parameter('goal_timeout').value
        self.max_retries = self.get_parameter('max_retries').value
        self.retry_delay = self.get_parameter('retry_delay').value

        # Goal tracking with timeout management
        self.active_goals: Dict[str, Dict[str, Any]] = {}
        self.goal_counter = 0

        # Timer for sending goals
        self.timer = self.create_timer(10.0, self.send_periodic_goal)

        # Timer for timeout management
        self.timeout_timer = self.create_timer(1.0, self.check_timeouts)

        self.get_logger().info('Timeout Action Client initialized')

    def send_periodic_goal(self):
        """Send a goal periodically."""
        self.goal_counter += 1
        goal_order = (self.goal_counter % 5) + 5  # Orders 5-9

        self._goal_request.order = goal_order
        goal_id = f'timeout_goal_{self.goal_counter}'

        self.get_logger().info(f'Sending timeout goal {goal_id}: order {goal_order}')

        # Send the goal
        send_future = self._action_client.send_goal_async(
            self._goal_request,
            feedback_callback=self.feedback_callback
        )

        # Store goal info with timeout tracking
        self.active_goals[goal_id] = {
            'goal_request': goal_order,
            'state': 'pending',
            'timestamp': time.time(),
            'send_future': send_future,
            'goal_handle': None,
            'retry_count': 0,
            'original_request': self._goal_request.order
        }

        send_future.add_done_callback(
            lambda future, gid=goal_id: self.goal_response_callback(future, gid)
        )

    def goal_response_callback(self, future, goal_id):
        """Handle goal response."""
        try:
            goal_handle = future.result()

            if not goal_handle.accepted:
                self.get_logger().warn(f'Goal {goal_id} rejected, attempting retry')
                self.handle_goal_failure(goal_id)
                return

            self.get_logger().info(f'Goal {goal_id} accepted')
            self.active_goals[goal_id]['state'] = 'active'
            self.active_goals[goal_id]['goal_handle'] = goal_handle

            # Set up result callback
            result_future = goal_handle.get_result_async()
            result_future.add_done_callback(
                lambda future, gid=goal_id: self.result_callback(future, gid)
            )

        except Exception as e:
            self.get_logger().error(f'Error in goal response for {goal_id}: {e}')
            self.handle_goal_failure(goal_id)

    def result_callback(self, future, goal_id):
        """Handle the final result."""
        try:
            goal_result = future.result()
            result = goal_result.result
            status = goal_result.status

            if status == 2:  # SUCCEEDED
                self.get_logger().info(f'Goal {goal_id} succeeded: {result.sequence}')
                if goal_id in self.active_goals:
                    del self.active_goals[goal_id]
            else:
                self.get_logger().warn(f'Goal {goal_id} failed with status {status}')
                self.handle_goal_failure(goal_id)

        except Exception as e:
            self.get_logger().error(f'Error getting result for {goal_id}: {e}')
            self.handle_goal_failure(goal_id)

    def feedback_callback(self, feedback_msg):
        """Handle feedback (just log for this example)."""
        self.get_logger().debug(f'Feedback received: {len(feedback_msg.partial_sequence)} numbers')

    def check_timeouts(self):
        """Check for goals that have timed out."""
        current_time = time.time()
        timed_out_goals = []

        for goal_id, goal_info in self.active_goals.items():
            time_elapsed = current_time - goal_info['timestamp']

            if time_elapsed > self.goal_timeout:
                timed_out_goals.append(goal_id)

        for goal_id in timed_out_goals:
            self.get_logger().warn(f'Goal {goal_id} timed out after {self.goal_timeout}s')
            self.handle_goal_timeout(goal_id)

    def handle_goal_timeout(self, goal_id):
        """Handle a goal that has timed out."""
        if goal_id not in self.active_goals:
            return

        goal_info = self.active_goals[goal_id]

        # Attempt retry if under retry limit
        if goal_info['retry_count'] < self.max_retries:
            self.retry_goal(goal_id)
        else:
            self.get_logger().error(f'Goal {goal_id} failed after {self.max_retries} retries')
            del self.active_goals[goal_id]

    def handle_goal_failure(self, goal_id):
        """Handle a failed goal (rejected, aborted, etc.)."""
        if goal_id not in self.active_goals:
            return

        goal_info = self.active_goals[goal_id]

        # Attempt retry if under retry limit
        if goal_info['retry_count'] < self.max_retries:
            self.retry_goal(goal_id)
        else:
            self.get_logger().error(f'Goal {goal_id} failed after {self.max_retries} retries')
            if goal_id in self.active_goals:
                del self.active_goals[goal_id]

    def retry_goal(self, goal_id):
        """Retry a failed or timed-out goal."""
        if goal_id not in self.active_goals:
            return

        goal_info = self.active_goals[goal_id]
        retry_count = goal_info['retry_count'] + 1

        self.get_logger().info(f'Retrying goal {goal_id} (attempt {retry_count}/{self.max_retries})')

        # Update retry count
        goal_info['retry_count'] = retry_count
        goal_info['timestamp'] = time.time()

        # Create new goal request with original parameters
        self._goal_request.order = goal_info['original_request']

        # Send new goal
        send_future = self._action_client.send_goal_async(
            self._goal_request,
            feedback_callback=self.feedback_callback
        )

        # Update goal info
        goal_info['send_future'] = send_future
        goal_info['state'] = 'pending'

        send_future.add_done_callback(
            lambda future, gid=goal_id: self.goal_response_callback(future, gid)
        )

def main(args=None):
    rclpy.init(args=args)

    timeout_client = TimeoutActionClient()

    try:
        rclpy.spin(timeout_client)
    except KeyboardInterrupt:
        timeout_client.get_logger().info('Interrupted, shutting down...')
    finally:
        timeout_client.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Action Client Best Practices

1. **Server Availability**: Always wait for the action server before sending goals
2. **Asynchronous Operations**: Use `send_goal_async()` and handle futures properly
3. **Error Handling**: Handle goal rejection, cancellation, and execution failures
4. **Timeout Management**: Implement appropriate timeouts for long-running operations
5. **Resource Management**: Track active goals and avoid resource leaks
6. **Feedback Processing**: Handle feedback appropriately for your application

<!-- DIAGRAM: Action Client Architecture - Goal Submission and Result Handling -->
<!-- CHUNK END: Creating Action Clients -->

<!-- CHUNK START: Custom Action Types -->
## Working with Custom Action Types

While ROS 2 provides some standard action types, you'll often need to define custom action types for your specific application. Custom actions enable sophisticated long-running operations with feedback and are essential for building specialized robotic applications.

### Defining Custom Action Types

Action types are defined in `.action` files with three sections:

```
# In your_robot_package/action/MoveToPose.action
# Goal definition (input parameters)
geometry_msgs/Pose target_pose
float64 tolerance
string description
---
# Result definition (final output)
bool success
string message
geometry_msgs/Pose final_pose
float64 execution_time
---
# Feedback definition (intermediate updates)
float64 distance_to_goal
float64 progress_percentage
string status
geometry_msgs/Pose current_pose
```

```
# In your_robot_package/action/ExecuteTrajectory.action
# Goal
trajectory_msgs/JointTrajectory trajectory
bool blocking
float64 max_velocity
---
# Result
bool success
string message
int32 error_code
---
# Feedback
float64 progress_percentage
int32 current_waypoint
string status
```

### Implementing Custom Actions

```python
# Action server for custom MoveToPose action
import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from your_robot_package.action import MoveToPose
from geometry_msgs.msg import Pose
from rclpy.executors import MultiThreadedExecutor
import time
import threading
import math

class MoveToPoseActionServer(Node):
    """
    An action server that implements a custom MoveToPose action for robot navigation.
    This demonstrates working with complex custom action definitions.
    """

    def __init__(self):
        super().__init__('move_to_pose_action_server')

        # Create the action server
        self._action_server = ActionServer(
            self,
            MoveToPose,
            'move_to_pose',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            handle_accepted_callback=self.handle_accepted_callback,
            cancel_callback=self.cancel_callback
        )

        # Simulated robot state
        self.current_pose = Pose()
        self.current_pose.position.x = 0.0
        self.current_pose.position.y = 0.0
        self.current_pose.position.z = 0.0
        self.current_pose.orientation.w = 1.0  # No rotation initially

        # Robot movement parameters
        self.linear_speed = 0.5  # m/s
        self.angular_speed = 0.5  # rad/s
        self.arrival_tolerance = 0.1  # m

        self.get_logger().info('MoveToPose Action Server initialized')

    def goal_callback(self, goal_request):
        """Accept or reject move-to-pose goals."""
        # Validate the target pose
        target = goal_request.target_pose
        tolerance = goal_request.tolerance

        # Check if target is valid (not NaN or inf)
        if (math.isnan(target.position.x) or math.isnan(target.position.y) or
            math.isinf(target.position.x) or math.isinf(target.position.y)):
            self.get_logger().warn('Rejecting goal: invalid target pose coordinates')
            return GoalResponse.REJECT

        # Check if tolerance is positive
        if tolerance <= 0:
            self.get_logger().warn(f'Rejecting goal: invalid tolerance {tolerance}')
            return GoalResponse.REJECT

        self.get_logger().info(
            f'Accepting goal: move to ({target.position.x:.2f}, {target.position.y:.2f}), '
            f'tolerance: {tolerance:.2f}, description: {goal_request.description}'
        )

        return GoalResponse.ACCEPT

    def handle_accepted_callback(self, goal_handle):
        """Handle an accepted goal."""
        self.get_logger().info('MoveToPose goal accepted, executing...')

        # Execute in a separate thread
        goal_thread = threading.Thread(
            target=self.execute_goal,
            args=(goal_handle,)
        )
        goal_thread.start()

    def cancel_callback(self, goal_handle):
        """Handle cancel requests."""
        self.get_logger().info('MoveToPose cancel request received')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """Execute callback (not directly used in this implementation)."""
        pass

    def execute_goal(self, goal_handle):
        """Execute the move-to-pose goal."""
        start_time = time.time()
        target_pose = goal_handle.request.target_pose
        tolerance = goal_handle.request.tolerance
        description = goal_handle.request.description

        # Initialize feedback
        feedback_msg = MoveToPose.Feedback()
        feedback_msg.current_pose = self.current_pose
        feedback_msg.status = 'Moving to pose'

        try:
            # Calculate distance to target
            dx = target_pose.position.x - self.current_pose.position.x
            dy = target_pose.position.y - self.current_pose.position.y
            distance_to_target = math.sqrt(dx*dx + dy*dy)

            # Move toward the target
            step_size = 0.05  # 5cm steps
            total_distance = distance_to_target

            while distance_to_target > tolerance:
                # Check for cancellation
                if goal_handle.is_cancel_requested:
                    goal_handle.canceled()
                    self.get_logger().info('MoveToPose goal canceled')
                    return

                # Calculate movement vector
                move_x = dx * step_size / distance_to_target
                move_y = dy * step_size / distance_to_target

                # Update current pose
                self.current_pose.position.x += move_x
                self.current_pose.position.y += move_y

                # Calculate remaining distance
                dx = target_pose.position.x - self.current_pose.position.x
                dy = target_pose.position.y - self.current_pose.position.y
                distance_to_target = math.sqrt(dx*dx + dy*dy)

                # Calculate progress
                distance_traveled = total_distance - distance_to_target
                progress = min(100.0, (distance_traveled / total_distance) * 100) if total_distance > 0 else 100.0

                # Update feedback
                feedback_msg.distance_to_goal = distance_to_target
                feedback_msg.progress_percentage = progress
                feedback_msg.status = f'Moving to pose: {description}'
                feedback_msg.current_pose = self.current_pose

                goal_handle.publish_feedback(feedback_msg)

                # Log progress periodically
                if int(progress) % 10 == 0:  # Log every 10%
                    self.get_logger().info(
                        f'MoveToPose progress: {progress:.1f}% - '
                        f'Distance to goal: {distance_to_target:.2f}m'
                    )

                # Simulate movement time
                time.sleep(0.1)

            # Goal reached
            execution_time = time.time() - start_time

            # Create result
            result = MoveToPose.Result()
            result.success = True
            result.message = f'Pose reached successfully in {execution_time:.2f}s'
            result.final_pose = self.current_pose
            result.execution_time = execution_time

            goal_handle.succeed()
            self.get_logger().info(
                f'MoveToPose goal completed: {description} - '
                f'Final position: ({self.current_pose.position.x:.2f}, {self.current_pose.position.y:.2f})'
            )

        except Exception as e:
            self.get_logger().error(f'Error executing MoveToPose goal: {e}')
            result = MoveToPose.Result()
            result.success = False
            result.message = f'Execution error: {str(e)}'
            goal_handle.abort()

        return result

# Action client for custom MoveToPose action
class MoveToPoseActionClient(Node):
    """
    An action client that uses the custom MoveToPose action.
    This demonstrates how to call custom actions from Python.
    """

    def __init__(self):
        super().__init__('move_to_pose_action_client')

        # Create the action client
        self._action_client = ActionClient(self, MoveToPose, 'move_to_pose')

        # Wait for the action server
        self.get_logger().info('Waiting for MoveToPose action server...')
        self._action_client.wait_for_server()

        # Goal request template
        self._goal_request = MoveToPose.Goal()

        # Timer for demonstration
        self.timer = self.create_timer(10.0, self.send_navigation_goal)

        self.get_logger().info('MoveToPose Action Client initialized')

    def send_navigation_goal(self):
        """Send a navigation goal to the robot."""
        # Create a target pose
        target_pose = Pose()
        target_pose.position.x = 2.0 + (self.get_clock().now().nanoseconds % 100) / 50.0  # Vary x position
        target_pose.position.y = 1.0 + (self.get_clock().now().nanoseconds % 80) / 40.0   # Vary y position
        target_pose.position.z = 0.0
        target_pose.orientation.w = 1.0

        # Set up the goal
        self._goal_request.target_pose = target_pose
        self._goal_request.tolerance = 0.1
        self._goal_request.description = f'Navigation goal at {time.time():.0f}'

        self.get_logger().info(
            f'Sending navigation goal: ({target_pose.position.x:.2f}, {target_pose.position.y:.2f})'
        )

        # Send the goal
        send_future = self._action_client.send_goal_async(
            self._goal_request,
            feedback_callback=self.feedback_callback
        )

        send_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        """Handle goal response."""
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().warn('Navigation goal rejected by server')
            return

        self.get_logger().info('Navigation goal accepted')

        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.result_callback)

    def feedback_callback(self, feedback_msg):
        """Handle navigation feedback."""
        self.get_logger().info(
            f'Navigation feedback: {feedback_msg.progress_percentage:.1f}% complete, '
            f'{feedback_msg.distance_to_goal:.2f}m to goal'
        )

    def result_callback(self, future):
        """Handle navigation result."""
        goal_result = future.result()
        result = goal_result.result
        status = goal_result.status

        if status == 2:  # SUCCEEDED
            self.get_logger().info(f'Navigation succeeded: {result.message}')
        else:
            self.get_logger().warn(f'Navigation failed with status {status}: {result.message}')

def main_server(args=None):
    rclpy.init(args=args)
    server = MoveToPoseActionServer()

    try:
        executor = MultiThreadedExecutor()
        executor.add_node(server)
        executor.spin()
    except KeyboardInterrupt:
        server.get_logger().info('MoveToPose server interrupted')
    finally:
        server.destroy_node()
        rclpy.shutdown()

def main_client(args=None):
    rclpy.init(args=args)
    client = MoveToPoseActionClient()

    try:
        rclpy.spin(client)
    except KeyboardInterrupt:
        client.get_logger().info('MoveToPose client interrupted')
    finally:
        client.destroy_node()
        rclpy.shutdown()
```

### Complex Custom Action Example

For more sophisticated applications, you might need actions with complex feedback and result structures:

```
# In your_robot_package/action/ComplexManipulation.action
# Goal
string manipulation_type  # 'pick', 'place', 'move', 'assemble'
geometry_msgs/Pose target_pose
string object_id
float64 gripper_force
bool use_vision
---
# Result
bool success
string message
int32 error_code
geometry_msgs/Pose final_pose
builtin_interfaces/Time execution_start
builtin_interfaces/Time execution_end
---
# Feedback
string phase  # 'approaching', 'grasping', 'lifting', 'moving', 'placing'
float64 progress_percentage
geometry_msgs/Pose current_pose
string status_message
builtin_interfaces/Time phase_start
```

```python
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from your_robot_package.action import ComplexManipulation
from geometry_msgs.msg import Pose
from builtin_interfaces.msg import Time
from rclpy.executors import MultiThreadedExecutor
import time
import threading

class ComplexManipulationServer(Node):
    """
    A server for complex manipulation actions with detailed feedback.
    This demonstrates working with complex custom action types.
    """

    def __init__(self):
        super().__init__('complex_manipulation_server')

        self._action_server = ActionServer(
            self,
            ComplexManipulation,
            'complex_manipulation',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            handle_accepted_callback=self.handle_accepted_callback,
            cancel_callback=self.cancel_callback
        )

        # Simulated robot state
        self.current_pose = Pose()
        self.current_pose.position.x = 0.0
        self.current_pose.position.y = 0.0
        self.current_pose.position.z = 1.0  # Default height

        self.get_logger().info('Complex Manipulation Server initialized')

    def goal_callback(self, goal_request):
        """Validate and accept manipulation goals."""
        valid_types = ['pick', 'place', 'move', 'assemble']

        if goal_request.manipulation_type not in valid_types:
            self.get_logger().warn(f'Invalid manipulation type: {goal_request.manipulation_type}')
            return GoalResponse.REJECT

        self.get_logger().info(
            f'Accepting manipulation goal: {goal_request.manipulation_type} '
            f'for object {goal_request.object_id}'
        )

        return GoalResponse.ACCEPT

    def handle_accepted_callback(self, goal_handle):
        """Handle accepted goal."""
        goal_thread = threading.Thread(
            target=self.execute_manipulation,
            args=(goal_handle,)
        )
        goal_thread.start()

    def cancel_callback(self, goal_handle):
        """Handle cancel request."""
        self.get_logger().info('Manipulation cancel requested')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """Execute callback."""
        pass

    def execute_manipulation(self, goal_handle):
        """Execute the complex manipulation."""
        start_time = self.get_clock().now().to_msg()
        request = goal_handle.request

        # Initialize feedback
        feedback_msg = ComplexManipulation.Feedback()
        feedback_msg.current_pose = self.current_pose
        feedback_msg.phase = 'initializing'
        feedback_msg.progress_percentage = 0.0
        feedback_msg.status_message = f'Starting {request.manipulation_type} operation'

        try:
            # Phase 1: Approach
            feedback_msg.phase = 'approaching'
            feedback_msg.status_message = f'Approaching {request.object_id}'

            for i in range(20):  # Simulate approach
                if goal_handle.is_cancel_requested:
                    goal_handle.canceled()
                    return

                feedback_msg.progress_percentage = i * 5.0  # 0% to 100% over phases
                feedback_msg.current_pose.position.x += 0.02
                feedback_msg.current_pose.position.y += 0.01
                goal_handle.publish_feedback(feedback_msg)
                time.sleep(0.1)

            # Phase 2: Execute manipulation based on type
            if request.manipulation_type == 'pick':
                feedback_msg.phase = 'grasping'
                feedback_msg.status_message = f'Grasping {request.object_id}'

                for i in range(10):
                    if goal_handle.is_cancel_requested:
                        goal_handle.canceled()
                        return
                    feedback_msg.progress_percentage = 50.0 + i * 5.0
                    goal_handle.publish_feedback(feedback_msg)
                    time.sleep(0.2)

            elif request.manipulation_type == 'place':
                feedback_msg.phase = 'placing'
                feedback_msg.status_message = f'Placing {request.object_id}'

                for i in range(10):
                    if goal_handle.is_cancel_requested:
                        goal_handle.canceled()
                        return
                    feedback_msg.progress_percentage = 50.0 + i * 5.0
                    goal_handle.publish_feedback(feedback_msg)
                    time.sleep(0.2)

            # Finalize
            end_time = self.get_clock().now().to_msg()

            result = ComplexManipulation.Result()
            result.success = True
            result.message = f'{request.manipulation_type.title()} operation completed successfully'
            result.error_code = 0
            result.final_pose = self.current_pose
            result.execution_start = start_time
            result.execution_end = end_time

            goal_handle.succeed()
            self.get_logger().info(f'Manipulation completed: {result.message}')

        except Exception as e:
            result = ComplexManipulation.Result()
            result.success = False
            result.message = f'Manipulation error: {str(e)}'
            result.error_code = 1
            goal_handle.abort()

def main(args=None):
    rclpy.init(args=args)
    server = ComplexManipulationServer()

    try:
        executor = MultiThreadedExecutor()
        executor.add_node(server)
        executor.spin()
    except KeyboardInterrupt:
        server.get_logger().info('Complex manipulation server interrupted')
    finally:
        server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Custom Action Best Practices

1. **Action Design**: Design actions with clear phases and meaningful feedback
2. **Error Handling**: Include comprehensive error reporting in results
3. **Cancellation**: Properly handle cancellation requests during execution
4. **Progress Tracking**: Provide meaningful progress indicators in feedback
5. **Validation**: Validate goal parameters before accepting them
6. **Resource Management**: Track and manage resources used by active goals

<!-- DIAGRAM: Custom Action Structure - Goal Feedback Result Definition -->
<!-- CHUNK END: Custom Action Types -->

<!-- CHUNK START: Python Agent Bridge for Actions -->
## Python Agent Bridge for Actions

Actions provide an excellent mechanism for connecting Python AI agents to ROS controllers for long-running operations that require feedback and cancellation capabilities. This pattern is particularly useful for AI agents that need to monitor and potentially interrupt robot operations like navigation, manipulation, or complex task execution.

### Action Bridge Architecture

The action bridge architecture enables AI agents to send long-running goals to robot controllers while maintaining the ability to monitor progress and cancel operations:

```python
import rclpy
from rclpy.action import ActionClient, ActionServer
from rclpy.node import Node
from your_robot_package.action import MoveToPose, ComplexManipulation
from geometry_msgs.msg import Pose
from std_msgs.msg import String
from std_srvs.srv import Trigger
import time
import threading
from typing import Dict, Any
from enum import Enum

class AgentActionBridge(Node):
    """
    A bridge node that connects Python AI agents to ROS controllers using actions.
    This enables long-running operations with feedback and cancellation.
    """

    def __init__(self):
        super().__init__('agent_action_bridge')

        # Declare bridge configuration parameters
        self.declare_parameter('bridge_frequency', 10.0)  # Hz
        self.declare_parameter('action_timeout', 60.0)    # seconds
        self.declare_parameter('enable_cancellation', True)

        # Get parameter values
        self.bridge_frequency = self.get_parameter('bridge_frequency').value
        self.action_timeout = self.get_parameter('action_timeout').value
        self.enable_cancellation = self.get_parameter('enable_cancellation').value

        # Create action clients for robot operations
        self.nav_client = ActionClient(self, MoveToPose, '/robot/move_to_pose')
        self.manip_client = ActionClient(self, ComplexManipulation, '/robot/manipulation')

        # Create services for agent interface
        self.nav_service = self.create_service(
            MoveToPose, '/agent/navigate', self.agent_navigate_callback
        )
        self.manip_service = self.create_service(
            ComplexManipulation, '/agent/manipulate', self.agent_manipulate_callback
        )

        # Create action servers for agent interface
        self.agent_nav_server = ActionServer(
            self,
            MoveToPose,
            '/agent/action_navigate',
            execute_callback=self.agent_action_navigate_execute,
            goal_callback=self.agent_action_goal_callback,
            handle_accepted_callback=self.agent_action_handle_accepted,
            cancel_callback=self.agent_action_cancel_callback
        )

        # Wait for robot action servers
        self.get_logger().info('Waiting for robot action servers...')
        self.nav_client.wait_for_server()
        self.manip_client.wait_for_server()

        # Goal tracking
        self.active_agent_goals: Dict[str, Dict[str, Any]] = {}
        self.active_robot_goals: Dict[str, Dict[str, Any]] = {}

        # Initialize request objects
        self.nav_request = MoveToPose.Goal()
        self.manip_request = ComplexManipulation.Goal()

        self.get_logger().info('Agent Action Bridge initialized')

    def agent_navigate_callback(self, request, response):
        """Handle navigation requests from Python AI agents."""
        try:
            # Forward the navigation request to the robot
            self.nav_request.target_pose = request.target_pose
            self.nav_request.tolerance = request.tolerance
            self.nav_request.description = f'Agent: {request.description}'

            # Send the goal to the robot
            send_future = self.nav_client.send_goal_async(self.nav_request)

            # Wait for acceptance (synchronous from agent's perspective)
            rclpy.spin_until_future_complete(self, send_future, timeout_sec=5.0)

            if send_future.done():
                goal_handle = send_future.result()
                if goal_handle and goal_handle.accepted:
                    # Wait for result
                    result_future = goal_handle.get_result_async()
                    rclpy.spin_until_future_complete(self, result_future, timeout_sec=self.action_timeout)

                    if result_future.done():
                        result_msg = result_future.result()
                        result = result_msg.result

                        response.success = result.success
                        response.message = result.message
                        response.final_pose = result.final_pose
                        response.execution_time = result.execution_time
                    else:
                        response.success = False
                        response.message = f'Navigation timed out after {self.action_timeout}s'
                else:
                    response.success = False
                    response.message = 'Navigation goal was rejected by robot'
            else:
                response.success = False
                response.message = 'Failed to send navigation goal to robot'

        except Exception as e:
            response.success = False
            response.message = f'Navigation error: {str(e)}'
            self.get_logger().error(f'Navigation error: {e}')

        return response

    def agent_manipulate_callback(self, request, response):
        """Handle manipulation requests from Python AI agents."""
        try:
            # Forward the manipulation request to the robot
            self.manip_request.manipulation_type = request.manipulation_type
            self.manip_request.target_pose = request.target_pose
            self.manip_request.object_id = request.object_id
            self.manip_request.gripper_force = request.gripper_force
            self.manip_request.use_vision = request.use_vision

            # Send the goal to the robot
            send_future = self.manip_client.send_goal_async(self.manip_request)

            # Wait for acceptance
            rclpy.spin_until_future_complete(self, send_future, timeout_sec=5.0)

            if send_future.done():
                goal_handle = send_future.result()
                if goal_handle and goal_handle.accepted:
                    # Wait for result
                    result_future = goal_handle.get_result_async()
                    rclpy.spin_until_future_complete(self, result_future, timeout_sec=self.action_timeout)

                    if result_future.done():
                        result_msg = result_future.result()
                        result = result_msg.result

                        response.success = result.success
                        response.message = result.message
                        response.error_code = result.error_code
                    else:
                        response.success = False
                        response.message = f'Manipulation timed out after {self.action_timeout}s'
                else:
                    response.success = False
                    response.message = 'Manipulation goal was rejected by robot'
            else:
                response.success = False
                response.message = 'Failed to send manipulation goal to robot'

        except Exception as e:
            response.success = False
            response.message = f'Manipulation error: {str(e)}'
            self.get_logger().error(f'Manipulation error: {e}')

        return response

    def agent_action_goal_callback(self, goal_request):
        """Handle action goals from AI agents."""
        self.get_logger().info(f'Agent action goal received: {goal_request.description}')
        return GoalResponse.ACCEPT

    def agent_action_handle_accepted(self, goal_handle):
        """Handle accepted agent action goal."""
        goal_id = str(goal_handle.goal_id.uuid)

        # Store goal info
        self.active_agent_goals[goal_id] = {
            'goal_handle': goal_handle,
            'timestamp': time.time(),
            'state': 'forwarding'
        }

        # Forward to robot in a separate thread
        goal_thread = threading.Thread(
            target=self.forward_agent_goal,
            args=(goal_handle, goal_id)
        )
        goal_thread.start()

    def forward_agent_goal(self, agent_goal_handle, agent_goal_id):
        """Forward an agent goal to the robot."""
        try:
            # Extract goal from agent
            agent_request = agent_goal_handle.request

            # Forward to robot navigation
            self.nav_request.target_pose = agent_request.target_pose
            self.nav_request.tolerance = agent_request.tolerance
            self.nav_request.description = f'Bridge: {agent_request.description}'

            # Send to robot
            send_future = self.nav_client.send_goal_async(
                self.nav_request,
                feedback_callback=lambda fb: self.robot_feedback_callback(fb, agent_goal_id)
            )

            # Wait for robot to accept
            rclpy.spin_until_future_complete(self, send_future, timeout_sec=5.0)

            if send_future.done():
                robot_goal_handle = send_future.result()
                if robot_goal_handle and robot_goal_handle.accepted:
                    # Store robot goal info
                    robot_goal_id = str(robot_goal_handle.goal_id.uuid)
                    self.active_agent_goals[agent_goal_id]['robot_goal_handle'] = robot_goal_handle
                    self.active_agent_goals[agent_goal_id]['robot_goal_id'] = robot_goal_id

                    # Wait for robot result
                    result_future = robot_goal_handle.get_result_async()
                    rclpy.spin_until_future_complete(self, result_future, timeout_sec=self.action_timeout)

                    if result_future.done():
                        result_msg = result_future.result()
                        robot_result = result_msg.result

                        # Forward result back to agent
                        if result_msg.status == 2:  # SUCCEEDED
                            agent_goal_handle.succeed()
                        elif result_msg.status == 5:  # CANCELED
                            agent_goal_handle.canceled()
                        else:
                            agent_goal_handle.abort()

                        # Create and return result
                        agent_result = MoveToPose.Result()
                        agent_result.success = robot_result.success
                        agent_result.message = robot_result.message
                        agent_result.final_pose = robot_result.final_pose
                        agent_result.execution_time = robot_result.execution_time

                        if agent_goal_id in self.active_agent_goals:
                            del self.active_agent_goals[agent_goal_id]

                        return agent_result
                    else:
                        agent_goal_handle.abort()
                        agent_result = MoveToPose.Result()
                        agent_result.success = False
                        agent_result.message = f'Robot operation timed out after {self.action_timeout}s'

                        if agent_goal_id in self.active_agent_goals:
                            del self.active_agent_goals[agent_goal_id]

                        return agent_result
                else:
                    agent_goal_handle.abort()
                    agent_result = MoveToPose.Result()
                    agent_result.success = False
                    agent_result.message = 'Robot rejected the goal'

                    if agent_goal_id in self.active_agent_goals:
                        del self.active_agent_goals[agent_goal_id]

                    return agent_result
            else:
                agent_goal_handle.abort()
                agent_result = MoveToPose.Result()
                agent_result.success = False
                agent_result.message = 'Failed to send goal to robot'

                if agent_goal_id in self.active_agent_goals:
                    del self.active_agent_goals[agent_goal_id]

                return agent_result

        except Exception as e:
            self.get_logger().error(f'Error forwarding agent goal {agent_goal_id}: {e}')
            agent_goal_handle.abort()
            agent_result = MoveToPose.Result()
            agent_result.success = False
            agent_result.message = f'Forwarding error: {str(e)}'

            if agent_goal_id in self.active_agent_goals:
                del self.active_agent_goals[agent_goal_id]

            return agent_result

    def robot_feedback_callback(self, feedback_msg, agent_goal_id):
        """Forward robot feedback to the agent."""
        if agent_goal_id in self.active_agent_goals:
            # Create agent feedback (same structure as robot feedback for this example)
            agent_feedback = MoveToPose.Feedback()
            agent_feedback.distance_to_goal = feedback_msg.distance_to_goal
            agent_feedback.progress_percentage = feedback_msg.progress_percentage
            agent_feedback.status = feedback_msg.status
            agent_feedback.current_pose = feedback_msg.current_pose

            # Get the agent goal handle and publish feedback
            agent_goal_handle = self.active_agent_goals[agent_goal_id]['goal_handle']
            agent_goal_handle.publish_feedback(agent_feedback)

    def agent_action_cancel_callback(self, goal_handle):
        """Handle cancel requests from AI agents."""
        goal_id = str(goal_handle.goal_id.uuid)

        self.get_logger().info(f'Cancel request for agent goal {goal_id}')

        # If we have a corresponding robot goal, cancel it too
        if goal_id in self.active_agent_goals:
            robot_goal_handle = self.active_agent_goals[goal_id].get('robot_goal_handle')
            if robot_goal_handle:
                cancel_future = robot_goal_handle.cancel_goal_async()
                # We could add a callback here to handle the robot's cancel response

        return CancelResponse.ACCEPT

    def agent_action_navigate_execute(self, goal_handle):
        """Execute callback for agent navigation action."""
        # This is handled in the thread created by handle_accepted_callback
        pass

def main(args=None):
    rclpy.init(args=args)
    bridge = AgentActionBridge()

    try:
        rclpy.spin(bridge)
    except KeyboardInterrupt:
        bridge.get_logger().info('Agent action bridge interrupted')
    finally:
        bridge.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Advanced Action Bridge with Priority Management

```python
import rclpy
from rclpy.action import ActionClient, ActionServer
from rclpy.node import Node
from your_robot_package.action import MoveToPose
from std_msgs.msg import String
from rclpy.executors import MultiThreadedExecutor
import time
import threading
from typing import Dict, Any
from enum import Enum
from queue import PriorityQueue

class Priority(Enum):
    LOW = 1
    NORMAL = 2
    HIGH = 3
    EMERGENCY = 4

class AdvancedActionBridgeNode(Node):
    """
    An advanced action bridge supporting multiple AI agents with priority-based
    goal scheduling and sophisticated resource management.
    """

    def __init__(self):
        super().__init__('advanced_action_bridge')

        # Declare advanced parameters
        self.declare_parameter('max_concurrent_goals', 2)
        self.declare_parameter('goal_queue_size', 10)
        self.declare_parameter('enable_preemption', True)

        # Get parameter values
        self.max_concurrent_goals = self.get_parameter('max_concurrent_goals').value
        self.goal_queue_size = self.get_parameter('goal_queue_size').value
        self.enable_preemption = self.get_parameter('enable_preemption').value

        # Create action client for robot
        self.robot_client = ActionClient(self, MoveToPose, '/robot/move_to_pose')

        # Create action server for agents
        self.agent_server = ActionServer(
            self,
            MoveToPose,
            '/multi_agent/navigate',
            execute_callback=self.agent_execute_callback,
            goal_callback=self.agent_goal_callback,
            handle_accepted_callback=self.agent_handle_accepted,
            cancel_callback=self.agent_cancel_callback
        )

        # Wait for robot server
        self.get_logger().info('Waiting for robot action server...')
        self.robot_client.wait_for_server()

        # Priority queue for goals
        self.goal_queue = PriorityQueue(maxsize=self.goal_queue_size)
        self.active_goals = {}
        self.goal_counter = 0

        # Thread for processing goals
        self.processing_thread = threading.Thread(target=self.process_goals, daemon=True)
        self.processing_thread.start()

        self.get_logger().info('Advanced Action Bridge initialized')

    def agent_goal_callback(self, goal_request):
        """Handle goal requests with priority assignment."""
        # Extract priority from goal description or assign default
        priority = Priority.NORMAL

        if 'emergency' in goal_request.description.lower():
            priority = Priority.EMERGENCY
        elif 'high' in goal_request.description.lower():
            priority = Priority.HIGH
        elif 'low' in goal_request.description.lower():
            priority = Priority.LOW

        self.get_logger().info(
            f'Received goal with priority {priority.name}: {goal_request.description}'
        )

        # Check if queue is full
        if self.goal_queue.qsize() >= self.goal_queue_size:
            self.get_logger().warn('Goal queue is full, rejecting goal')
            return GoalResponse.REJECT

        return GoalResponse.ACCEPT

    def agent_handle_accepted(self, goal_handle):
        """Handle accepted goal with priority."""
        goal_id = str(goal_handle.goal_id.uuid)

        # Determine priority based on goal description
        description = goal_handle.request.description.lower()
        if 'emergency' in description:
            priority = Priority.EMERGENCY.value
        elif 'high' in description:
            priority = Priority.HIGH.value
        elif 'low' in description:
            priority = Priority.LOW.value
        else:
            priority = Priority.NORMAL.value

        # Add to priority queue
        queue_item = (
            priority,  # Priority (lower number = higher priority)
            time.time(),  # Timestamp for tie-breaking
            goal_id,
            goal_handle
        )

        try:
            self.goal_queue.put_nowait(queue_item)
            self.get_logger().info(f'Goal {goal_id} added to queue with priority {priority}')
        except:
            self.get_logger().error(f'Failed to add goal {goal_id} to queue')
            goal_handle.abort()

    def process_goals(self):
        """Process goals from the priority queue."""
        while rclpy.ok():
            try:
                # Get next goal from queue
                priority, timestamp, goal_id, goal_handle = self.goal_queue.get(timeout=1.0)

                # Check if we can start this goal (respect concurrent limit)
                active_count = len([g for g in self.active_goals.values() if g['status'] == 'active'])

                if active_count >= self.max_concurrent_goals:
                    # Put it back in the queue and wait
                    self.goal_queue.put((priority, timestamp, goal_id, goal_handle))
                    time.sleep(0.1)
                    continue

                # Start processing the goal
                self.active_goals[goal_id] = {
                    'goal_handle': goal_handle,
                    'status': 'active',
                    'priority': priority,
                    'start_time': time.time()
                }

                # Execute the goal in a separate thread
                goal_thread = threading.Thread(
                    target=self.execute_robot_goal,
                    args=(goal_handle, goal_id)
                )
                goal_thread.start()

            except Exception as e:
                # Queue is empty (timeout) or other error
                if str(e) != "queue is empty":
                    self.get_logger().debug(f'Goal processing: {e}')
                time.sleep(0.01)

    def execute_robot_goal(self, agent_goal_handle, agent_goal_id):
        """Execute a goal on the robot."""
        try:
            # Forward to robot
            robot_request = MoveToPose.Goal()
            robot_request.target_pose = agent_goal_handle.request.target_pose
            robot_request.tolerance = agent_goal_handle.request.tolerance
            robot_request.description = f'Agent bridge: {agent_goal_handle.request.description}'

            # Send to robot with feedback
            send_future = self.robot_client.send_goal_async(
                robot_request,
                feedback_callback=lambda fb: self.forward_feedback(fb, agent_goal_id)
            )

            # Wait for acceptance
            rclpy.spin_until_future_complete(self, send_future, timeout_sec=5.0)

            if send_future.done():
                robot_goal_handle = send_future.result()
                if robot_goal_handle and robot_goal_handle.accepted:
                    # Wait for result
                    result_future = robot_goal_handle.get_result_async()
                    rclpy.spin_until_future_complete(self, result_future, timeout_sec=120.0)

                    if result_future.done():
                        result_msg = result_future.result()

                        # Complete the agent goal based on robot result
                        if result_msg.status == 2:  # SUCCEEDED
                            agent_goal_handle.succeed()
                        elif result_msg.status == 5:  # CANCELED
                            agent_goal_handle.canceled()
                        else:
                            agent_goal_handle.abort()

                    else:
                        agent_goal_handle.abort()
                else:
                    agent_goal_handle.abort()
            else:
                agent_goal_handle.abort()

        except Exception as e:
            self.get_logger().error(f'Error executing goal {agent_goal_id}: {e}')
            agent_goal_handle.abort()

        finally:
            # Mark as complete in our tracking
            if agent_goal_id in self.active_goals:
                self.active_goals[agent_goal_id]['status'] = 'completed'
                # Clean up after a delay
                time.sleep(1)
                if agent_goal_id in self.active_goals:
                    del self.active_goals[agent_goal_id]

    def forward_feedback(self, robot_feedback, agent_goal_id):
        """Forward robot feedback to the agent."""
        if agent_goal_id in self.active_goals:
            agent_goal_handle = self.active_goals[agent_goal_id]['goal_handle']

            # Forward feedback to agent
            agent_feedback = MoveToPose.Feedback()
            agent_feedback.distance_to_goal = robot_feedback.distance_to_goal
            agent_feedback.progress_percentage = robot_feedback.progress_percentage
            agent_feedback.status = robot_feedback.status
            agent_feedback.current_pose = robot_feedback.current_pose

            agent_goal_handle.publish_feedback(agent_feedback)

    def agent_execute_callback(self, goal_handle):
        """Execute callback (handled by processing thread)."""
        pass

    def agent_cancel_callback(self, goal_handle):
        """Handle cancel requests."""
        goal_id = str(goal_handle.goal_id.uuid)
        self.get_logger().info(f'Cancel request for goal {goal_id}')

        # In a real system, you'd need to implement cancellation logic
        # This is complex because goals are processed in separate threads

        return CancelResponse.ACCEPT

def main(args=None):
    rclpy.init(args=args)
    advanced_bridge = AdvancedActionBridgeNode()

    try:
        executor = MultiThreadedExecutor()
        executor.add_node(advanced_bridge)
        executor.spin()
    except KeyboardInterrupt:
        advanced_bridge.get_logger().info('Advanced action bridge interrupted')
    finally:
        advanced_bridge.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Action Bridge Benefits

1. **Long-Running Operations**: Perfect for tasks that take significant time to complete
2. **Progress Monitoring**: AI agents can monitor operation progress in real-time
3. **Cancellation Support**: Operations can be interrupted when necessary
4. **Feedback Integration**: Continuous feedback during execution
5. **Priority Management**: Can implement sophisticated scheduling algorithms
6. **Resource Management**: Better control over robot resources during operations

<!-- DIAGRAM: Action Bridge - AI Agent to Robot Controller Long-Running Communication -->
<!-- CHUNK END: Python Agent Bridge for Actions -->

## Summary

In this section, we've explored actions in ROS 2 using `rclpy`. You've learned:

1. **Action server creation** and implementation with proper goal management
2. **Action client implementation** with goal submission and feedback handling
3. **Custom action types** for specialized long-running operations
4. **Action communication patterns** for complex robot tasks
5. **Python agent bridge patterns** for connecting AI algorithms to robot controllers using actions

Actions provide a sophisticated communication mechanism that bridges the gap between simple services and continuous topic publishing, enabling complex operations with feedback, progress tracking, and cancellation capabilities that are essential for advanced robotic applications.

## Exercises

1. **Custom Action Creation**: Define and implement a custom action for robot arm manipulation that includes path planning, execution, and detailed feedback.

2. **Action Client with State Machine**: Create an action client that implements a state machine to manage complex multi-step operations.

3. **Priority-Based Action Bridge**: Implement an action bridge that supports multiple AI agents with different priority levels for robot resources.

4. **Action Composition**: Create an action that coordinates multiple other actions to perform complex behaviors (e.g., navigate to location, then perform manipulation).

5. **Action Monitoring System**: Implement a system that monitors and logs all action executions in a robotic system.

6. **Safety-Enhanced Action**: Create an action server that includes safety checks and automatic cancellation based on sensor data.

<!-- DIAGRAM: Exercise Scenarios - Action Communication Applications -->