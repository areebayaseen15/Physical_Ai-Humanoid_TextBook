---
id: 1-3-2-PublishSubscribe
title: 1 3.2 PublishSubscribe
sidebar_label: 1 3.2 PublishSubscribe
sidebar_position: 0
---
# Chapter 3-02: Implementing Topics in Python with rclpy

<!-- CHUNK START: Introduction to Publish-Subscribe -->
## Introduction to Publish-Subscribe Pattern

The publish-subscribe (pub/sub) pattern is the most fundamental communication paradigm in ROS 2 (Robot Operating System 2). It enables asynchronous, decoupled communication between nodes through topics. In this pattern, publishers send messages to topics without knowing which subscribers will receive them, and subscribers receive messages from topics without knowing which publishers sent them.

This decoupling is essential for creating flexible, scalable robotic systems where components can be developed, tested, and deployed independently. The publish-subscribe pattern allows for one-to-many, many-to-one, and many-to-many communication patterns, making it ideal for distributed robotics applications.

### Learning Objectives

By the end of this section, you will be able to:

1. Create publishers that send messages to ROS 2 topics
2. Create subscribers that receive messages from ROS 2 topics
3. Implement Quality of Service (QoS) settings for different communication needs
4. Work with custom message types in Python
5. Bridge Python agents to ROS controllers using publish-subscribe patterns
6. Structure topic communication content for RAG (Retrieval-Augmented Generation) indexing

### Key Concepts

- **Topic**: A named channel through which messages flow
- **Publisher**: A node that sends messages to a topic
- **Subscriber**: A node that receives messages from a topic
- **Message**: The data structure sent between nodes
- **QoS (Quality of Service)**: Settings that control message delivery characteristics

<!-- DIAGRAM: Publish-Subscribe Pattern - Publishers and Subscribers -->
<!-- CHUNK END: Introduction to Publish-Subscribe -->

<!-- CHUNK START: Creating Publishers -->
## Creating Publishers

Publishers allow nodes to send messages to topics in the publish-subscribe pattern. Creating a publisher in `rclpy` involves using the `create_publisher()` method of a node instance.

### Basic Publisher Implementation

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Int32, Float32
import time

class DataPublisher(Node):
    """
    A publisher node that demonstrates creating and using multiple publishers
    to send different types of data to different topics.
    """

    def __init__(self):
        super().__init__('data_publisher')

        # Create multiple publishers for different data types
        self.string_publisher = self.create_publisher(String, 'string_topic', 10)
        self.int_publisher = self.create_publisher(Int32, 'int_topic', 10)
        self.float_publisher = self.create_publisher(Float32, 'float_topic', 10)

        # Timer to publish data at regular intervals
        self.timer = self.create_timer(0.5, self.publish_data)
        self.counter = 0

        self.get_logger().info('Data Publisher initialized')

    def publish_data(self):
        """Publish data to all topics."""
        # Publish string message
        str_msg = String()
        str_msg.data = f'Data packet {self.counter}'
        self.string_publisher.publish(str_msg)

        # Publish integer message
        int_msg = Int32()
        int_msg.data = self.counter
        self.int_publisher.publish(int_msg)

        # Publish float message
        float_msg = Float32()
        float_msg.data = float(self.counter) * 0.1
        self.float_publisher.publish(float_msg)

        self.get_logger().info(f'Published data packet {self.counter}')
        self.counter += 1

def main(args=None):
    rclpy.init(args=args)

    data_publisher = DataPublisher()

    try:
        rclpy.spin(data_publisher)
    except KeyboardInterrupt:
        pass
    finally:
        data_publisher.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Publisher with Parameters

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import time

class ParameterizedPublisher(Node):
    """
    A publisher that uses parameters to configure its behavior.
    This demonstrates how to make publishers configurable at runtime.
    """

    def __init__(self):
        super().__init__('parameterized_publisher')

        # Declare parameters for publisher configuration
        self.declare_parameter('publish_frequency', 2.0)  # Hz
        self.declare_parameter('topic_name', 'parameterized_topic')
        self.declare_parameter('message_prefix', 'Parameterized message')
        self.declare_parameter('max_count', 100)

        # Get parameter values
        self.publish_frequency = self.get_parameter('publish_frequency').value
        self.topic_name = self.get_parameter('topic_name').value
        self.message_prefix = self.get_parameter('message_prefix').value
        self.max_count = self.get_parameter('max_count').value

        # Create publisher with parameterized topic name
        self.publisher = self.create_publisher(String, self.topic_name, 10)

        # Set up timer based on frequency parameter
        timer_period = 1.0 / self.publish_frequency
        self.timer = self.create_timer(timer_period, self.publish_message)

        # Initialize state
        self.counter = 0

        # Log configuration
        self.get_logger().info(f'Parameterized Publisher initialized')
        self.get_logger().info(f'Publishing to: {self.topic_name}')
        self.get_logger().info(f'Frequency: {self.publish_frequency} Hz')
        self.get_logger().info(f'Message prefix: {self.message_prefix}')

    def publish_message(self):
        """Publish a parameterized message."""
        if self.counter >= self.max_count:
            self.get_logger().info('Maximum count reached, stopping publisher')
            # In a real application, you might want to stop the timer or shutdown
            return

        msg = String()
        msg.data = f'{self.message_prefix} #{self.counter} at {time.time()}'
        self.publisher.publish(msg)

        self.get_logger().info(f'Published: {msg.data}')
        self.counter += 1

def main(args=None):
    rclpy.init(args=args)

    param_publisher = ParameterizedPublisher()

    try:
        rclpy.spin(param_publisher)
    except KeyboardInterrupt:
        param_publisher.get_logger().info('Interrupted, shutting down...')
    finally:
        param_publisher.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Publisher Best Practices

1. **Queue Size**: Choose appropriate queue sizes based on your application needs (typically 10 for most applications)
2. **Message Construction**: Construct messages efficiently, avoiding unnecessary computations in publish loops
3. **Resource Management**: Properly manage publisher resources by destroying them when the node is destroyed
4. **Error Handling**: While `rclpy` handles most communication errors, ensure your application logic is robust
5. **Parameter Configuration**: Use parameters to make publishers configurable without code changes

<!-- DIAGRAM: Publisher Architecture - Message Creation and Publishing -->
<!-- CHUNK END: Creating Publishers -->

<!-- CHUNK START: Creating Subscribers -->
## Creating Subscribers

Subscribers receive messages from topics in the publish-subscribe pattern. Creating a subscriber in `rclpy` involves using the `create_subscription()` method of a node instance, which requires a callback function to process incoming messages.

### Basic Subscriber Implementation

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Int32, Float32

class DataSubscriber(Node):
    """
    A subscriber node that demonstrates creating and using multiple subscribers
    to receive different types of data from different topics.
    """

    def __init__(self):
        super().__init__('data_subscriber')

        # Create subscribers for different message types
        self.string_subscription = self.create_subscription(
            String,
            'string_topic',
            self.string_callback,
            10)
        self.string_subscription  # prevent unused variable warning

        self.int_subscription = self.create_subscription(
            Int32,
            'int_topic',
            self.int_callback,
            10)
        self.int_subscription  # prevent unused variable warning

        self.float_subscription = self.create_subscription(
            Float32,
            'float_topic',
            self.float_callback,
            10)
        self.float_subscription  # prevent unused variable warning

        self.get_logger().info('Data Subscriber initialized')

    def string_callback(self, msg):
        """Handle incoming string messages."""
        self.get_logger().info(f'Received string: {msg.data}')

    def int_callback(self, msg):
        """Handle incoming integer messages."""
        self.get_logger().info(f'Received integer: {msg.data}')

    def float_callback(self, msg):
        """Handle incoming float messages."""
        self.get_logger().info(f'Received float: {msg.data:.2f}')

def main(args=None):
    rclpy.init(args=args)

    data_subscriber = DataSubscriber()

    try:
        rclpy.spin(data_subscriber)
    except KeyboardInterrupt:
        pass
    finally:
        data_subscriber.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Advanced Subscriber with Data Processing

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32, String
from collections import deque
import statistics

class ProcessingSubscriber(Node):
    """
    A subscriber that processes incoming data and maintains statistics.
    This demonstrates how subscribers can perform computations on received data.
    """

    def __init__(self):
        super().__init__('processing_subscriber')

        # Declare parameters for processing configuration
        self.declare_parameter('history_size', 10)
        self.declare_parameter('threshold', 5.0)
        self.declare_parameter('topic_name', 'sensor_data')

        # Get parameter values
        self.history_size = self.get_parameter('history_size').value
        self.threshold = self.get_parameter('threshold').value
        self.topic_name = self.get_parameter('topic_name').value

        # Create subscription
        self.subscription = self.create_subscription(
            Float32,
            self.topic_name,
            self.data_callback,
            10
        )

        # Publisher for processed results
        self.result_publisher = self.create_publisher(String, 'processed_results', 10)

        # Data storage and statistics
        self.data_history = deque(maxlen=self.history_size)
        self.event_counter = 0

        # Log configuration
        self.get_logger().info(f'Processing Subscriber initialized')
        self.get_logger().info(f'Subscribing to: {self.topic_name}')
        self.get_logger().info(f'History size: {self.history_size}')
        self.get_logger().info(f'Threshold: {self.threshold}')

    def data_callback(self, msg):
        """Process incoming sensor data."""
        # Add new data to history
        self.data_history.append(msg.data)

        # Calculate statistics
        if len(self.data_history) > 0:
            current_value = msg.data
            avg_value = statistics.mean(self.data_history)
            min_value = min(self.data_history)
            max_value = max(self.data_history)

            # Check for threshold crossing
            if current_value > self.threshold:
                self.event_counter += 1
                event_msg = f'EVENT #{self.event_counter}: Value {current_value} exceeded threshold {self.threshold}'
                self.get_logger().warn(event_msg)

                # Publish event notification
                result_msg = String()
                result_msg.data = event_msg
                self.result_publisher.publish(result_msg)

            # Log statistics periodically
            if len(self.data_history) == self.history_size:
                stats_msg = f'Current: {current_value:.2f}, Avg: {avg_value:.2f}, Min: {min_value:.2f}, Max: {max_value:.2f}'
                self.get_logger().info(stats_msg)

def main(args=None):
    rclpy.init(args=args)

    processor = ProcessingSubscriber()

    try:
        rclpy.spin(processor)
    except KeyboardInterrupt:
        processor.get_logger().info('Interrupted, shutting down...')
    finally:
        processor.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Subscriber Best Practices

1. **Callback Efficiency**: Keep subscriber callbacks lightweight to avoid blocking message processing
2. **Data Handling**: Process messages efficiently and avoid unnecessary copies
3. **Threading**: Be aware that callbacks run in the same thread as the executor by default
4. **Queue Management**: Choose appropriate queue sizes to handle message bursts
5. **Error Handling**: Handle potential errors in message processing gracefully

<!-- DIAGRAM: Subscriber Architecture - Message Reception and Processing -->
<!-- CHUNK END: Creating Subscribers -->

<!-- CHUNK START: Custom Message Types -->
## Working with Custom Message Types

While ROS 2 provides standard message types in `std_msgs`, `sensor_msgs`, and other packages, you'll often need to define custom message types for your specific application. Custom messages enable precise data exchange between nodes and are essential for building specialized robotic applications.

### Creating and Using Custom Messages

First, you would define your custom message in a `.msg` file (typically in a package's `msg/` directory):

```
# In your_robot_package/msg/RobotPose.msg
float64 x
float64 y
float64 theta
string robot_name
uint8[] status_flags
```

Then use it in your publisher/subscriber:

```python
# Publisher with custom message
import rclpy
from rclpy.node import Node
from your_robot_package.msg import RobotPose  # Custom message type

class RobotPosePublisher(Node):
    """
    A publisher that sends custom RobotPose messages.
    This demonstrates how to work with custom message types in Python.
    """

    def __init__(self):
        super().__init__('robot_pose_publisher')

        # Create publisher for custom message type
        self.publisher = self.create_publisher(RobotPose, 'robot_pose', 10)

        # Timer for periodic publishing
        self.timer = self.create_timer(0.1, self.publish_pose)

        self.robot_id = 0
        self.get_logger().info('Robot Pose Publisher initialized')

    def publish_pose(self):
        """Publish robot pose information."""
        msg = RobotPose()
        msg.x = 1.0 + self.robot_id * 0.1  # Simulated position
        msg.y = 2.0 + self.robot_id * 0.1
        msg.theta = 1.57  # 90 degrees in radians
        msg.robot_name = f'robot_{self.robot_id}'
        msg.status_flags = [1, 0, 1, 0]  # Example status flags

        self.publisher.publish(msg)
        self.get_logger().info(f'Published pose for {msg.robot_name}: ({msg.x}, {msg.y}, {msg.theta})')

        self.robot_id = (self.robot_id + 1) % 10  # Cycle through robot IDs

# Subscriber for custom message
class RobotPoseSubscriber(Node):
    """
    A subscriber that receives custom RobotPose messages.
    This demonstrates how to process custom message types in Python.
    """

    def __init__(self):
        super().__init__('robot_pose_subscriber')

        # Create subscription for custom message type
        self.subscription = self.create_subscription(
            RobotPose,
            'robot_pose',
            self.pose_callback,
            10
        )

        self.get_logger().info('Robot Pose Subscriber initialized')

    def pose_callback(self, msg):
        """Handle incoming robot pose messages."""
        self.get_logger().info(
            f'Received pose for {msg.robot_name}: '
            f'Position({msg.x:.2f}, {msg.y:.2f}), '
            f'Orientation: {msg.theta:.2f} rad'
        )

        # Process status flags
        if len(msg.status_flags) > 0:
            status_str = ''.join([str(flag) for flag in msg.status_flags])
            self.get_logger().info(f'Status flags: {status_str}')
```

### Complex Custom Message Example

For more complex applications, you might need nested message structures:

```
# In your_robot_package/msg/RobotState.msg
RobotPose pose
sensor_msgs/BatteryState battery
geometry_msgs/Twist velocity
uint8[] sensor_readings
builtin_interfaces/Time timestamp
```

```python
import rclpy
from rclpy.node import Node
from your_robot_package.msg import RobotState  # Custom message with nested types
from sensor_msgs.msg import BatteryState
from geometry_msgs.msg import Twist
from builtin_interfaces.msg import Time

class RobotStatePublisher(Node):
    """
    A publisher that sends complex RobotState messages with nested types.
    This demonstrates working with complex custom message structures.
    """

    def __init__(self):
        super().__init__('robot_state_publisher')

        self.publisher = self.create_publisher(RobotState, 'robot_state', 10)
        self.timer = self.create_timer(0.5, self.publish_state)

        self.sequence = 0
        self.get_logger().info('Robot State Publisher initialized')

    def publish_state(self):
        """Publish comprehensive robot state information."""
        msg = RobotState()

        # Set pose information
        msg.pose.x = 1.0 + self.sequence * 0.01
        msg.pose.y = 2.0 + self.sequence * 0.01
        msg.pose.theta = 0.0
        msg.pose.robot_name = f'robot_{self.sequence % 10}'
        msg.pose.status_flags = [1, 1, 0, 1]

        # Set battery information
        msg.battery.voltage = 12.6 - (self.sequence * 0.01)  # Simulated discharge
        msg.battery.current = 2.5
        msg.battery.charge = 85.0 - (self.sequence * 0.1)
        msg.battery.percentage = msg.battery.charge / 100.0
        msg.battery.power_supply_status = BatteryState.POWER_SUPPLY_STATUS_DISCHARGING

        # Set velocity information
        msg.velocity.linear.x = 0.5 + (self.sequence % 3) * 0.1
        msg.velocity.linear.y = 0.0
        msg.velocity.linear.z = 0.0
        msg.velocity.angular.x = 0.0
        msg.velocity.angular.y = 0.0
        msg.velocity.angular.z = 0.1 * (self.sequence % 5 - 2)

        # Set sensor readings (simulated)
        msg.sensor_readings = [i + self.sequence for i in range(8)]

        # Set timestamp
        current_time = self.get_clock().now().to_msg()
        msg.timestamp.sec = current_time.sec
        msg.timestamp.nanosec = current_time.nanosec

        self.publisher.publish(msg)
        self.get_logger().info(f'Published state for {msg.pose.robot_name}')

        self.sequence += 1

def main(args=None):
    rclpy.init(args=args)

    state_publisher = RobotStatePublisher()

    try:
        rclpy.spin(state_publisher)
    except KeyboardInterrupt:
        state_publisher.get_logger().info('Interrupted, shutting down...')
    finally:
        state_publisher.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Custom Message Best Practices

1. **Message Design**: Design messages to be efficient and include only necessary data
2. **Naming Conventions**: Use clear, descriptive names for message fields
3. **Data Types**: Choose appropriate data types to balance precision and efficiency
4. **Documentation**: Document message fields and their expected values
5. **Versioning**: Consider how message changes will affect compatibility

<!-- DIAGRAM: Custom Message Structure - Definition to Usage -->
<!-- CHUNK END: Custom Message Types -->

<!-- CHUNK START: Quality of Service Settings -->
## Quality of Service (QoS) Settings

Quality of Service (QoS) settings in ROS 2 control how messages are delivered between publishers and subscribers. These settings allow you to optimize communication for different requirements such as reliability, latency, and resource usage.

### Understanding QoS Profiles

QoS settings include several key parameters:

- **Reliability**: Whether messages are guaranteed to be delivered
- **Durability**: Whether late-joining subscribers receive old messages
- **History**: How many messages to store
- **Deadline**: Maximum time between consecutive messages
- **Liveliness**: How to detect if a publisher is still active

```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy
from std_msgs.msg import String

class QoSPublisher(Node):
    """
    A publisher that demonstrates different QoS settings for various use cases.
    This shows how to configure communication characteristics for different needs.
    """

    def __init__(self):
        super().__init__('qos_publisher')

        # Create different QoS profiles for different use cases

        # Real-time sensor data: Best effort, volatile, small history
        sensor_qos = QoSProfile(
            depth=5,  # Small history for real-time data
            reliability=ReliabilityPolicy.BEST_EFFORT,
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST
        )
        self.sensor_publisher = self.create_publisher(String, 'sensor_data', sensor_qos)

        # Critical commands: Reliable, volatile, small history
        command_qos = QoSProfile(
            depth=10,
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST
        )
        self.command_publisher = self.create_publisher(String, 'robot_commands', command_qos)

        # Configuration data: Reliable, transient local, larger history
        config_qos = QoSProfile(
            depth=100,
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
            history=HistoryPolicy.KEEP_ALL
        )
        self.config_publisher = self.create_publisher(String, 'configuration', config_qos)

        # Timer for publishing different types of data
        self.timer = self.create_timer(1.0, self.publish_messages)

        self.message_counter = 0
        self.get_logger().info('QoS Publisher initialized with different profiles')

    def publish_messages(self):
        """Publish messages with different QoS requirements."""
        # Publish sensor data (best effort)
        sensor_msg = String()
        sensor_msg.data = f'Sensor reading {self.message_counter}'
        self.sensor_publisher.publish(sensor_msg)

        # Publish command data (reliable)
        command_msg = String()
        command_msg.data = f'Command {self.message_counter}'
        self.command_publisher.publish(command_msg)

        # Publish configuration data (reliable, persistent)
        config_msg = String()
        config_msg.data = f'Configuration setting {self.message_counter}'
        self.config_publisher.publish(config_msg)

        self.get_logger().info(f'Published messages: {self.message_counter}')
        self.message_counter += 1

class QoSSubscriber(Node):
    """
    A subscriber that uses matching QoS profiles to receive messages properly.
    This demonstrates how subscribers must match or be compatible with publisher QoS.
    """

    def __init__(self):
        super().__init__('qos_subscriber')

        # Create QoS profiles that match the publisher
        sensor_qos = QoSProfile(
            depth=5,
            reliability=ReliabilityPolicy.BEST_EFFORT,
            durability=DurabilityPolicy.VOLATILE
        )
        self.sensor_subscription = self.create_subscription(
            String, 'sensor_data', self.sensor_callback, sensor_qos
        )

        command_qos = QoSProfile(
            depth=10,
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE
        )
        self.command_subscription = self.create_subscription(
            String, 'robot_commands', self.command_callback, command_qos
        )

        config_qos = QoSProfile(
            depth=100,
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.TRANSIENT_LOCAL
        )
        self.config_subscription = self.create_subscription(
            String, 'configuration', self.config_callback, config_qos
        )

        self.get_logger().info('QoS Subscriber initialized')

    def sensor_callback(self, msg):
        """Handle best-effort sensor data."""
        self.get_logger().info(f'Received sensor data: {msg.data}')

    def command_callback(self, msg):
        """Handle reliable command data."""
        self.get_logger().info(f'Received command: {msg.data}')

    def config_callback(self, msg):
        """Handle persistent configuration data."""
        self.get_logger().info(f'Received config: {msg.data}')

def main(args=None):
    rclpy.init(args=args)

    # Run both publisher and subscriber in the same process for demonstration
    qos_publisher = QoSPublisher()
    qos_subscriber = QoSSubscriber()

    try:
        # Create a MultiThreadedExecutor to handle both nodes
        from rclpy.executors import MultiThreadedExecutor
        executor = MultiThreadedExecutor()
        executor.add_node(qos_publisher)
        executor.add_node(qos_subscriber)

        executor.spin()
    except KeyboardInterrupt:
        qos_publisher.get_logger().info('Interrupted, shutting down...')
        qos_subscriber.get_logger().info('Subscriber shutting down...')
    finally:
        qos_publisher.destroy_node()
        qos_subscriber.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Common QoS Patterns

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy

# Predefined QoS profiles for common use cases

# Sensor data: Best effort, small history, volatile
SENSOR_DATA_QOS = QoSProfile(
    depth=10,
    reliability=ReliabilityPolicy.BEST_EFFORT,
    durability=DurabilityPolicy.VOLATILE,
    history=HistoryPolicy.KEEP_LAST
)

# Control commands: Reliable, small history, volatile
COMMAND_QOS = QoSProfile(
    depth=10,
    reliability=ReliabilityPolicy.RELIABLE,
    durability=DurabilityPolicy.VOLATILE,
    history=HistoryPolicy.KEEP_LAST
)

# Configuration: Reliable, large history, transient local
CONFIG_QOS = QoSProfile(
    depth=100,
    reliability=ReliabilityPolicy.RELIABLE,
    durability=DurabilityPolicy.TRANSIENT_LOCAL,
    history=HistoryPolicy.KEEP_LAST
)

# Log data: Reliable, keep all, volatile (be careful with memory usage)
LOG_QOS = QoSProfile(
    depth=1000,
    reliability=ReliabilityPolicy.RELIABLE,
    durability=DurabilityPolicy.VOLATILE,
    history=HistoryPolicy.KEEP_ALL
)

# Image data: Best effort, small history, volatile
IMAGE_QOS = QoSProfile(
    depth=1,
    reliability=ReliabilityPolicy.BEST_EFFORT,
    durability=DurabilityPolicy.VOLATILE,
    history=HistoryPolicy.KEEP_LAST
)
```

### QoS Best Practices

1. **Match Publisher/Subscriber QoS**: Subscribers should use compatible QoS settings to receive messages
2. **Choose Appropriate Reliability**: Use BEST_EFFORT for real-time data, RELIABLE for commands
3. **Manage History Depth**: Balance between data availability and memory usage
4. **Consider Durability**: Use TRANSIENT_LOCAL for configuration data that new subscribers need
5. **Test Compatibility**: Verify that your QoS settings work as expected in your system

<!-- DIAGRAM: QoS Settings - Reliability and Durability Combinations -->
<!-- CHUNK END: Quality of Service Settings -->

<!-- CHUNK START: Python Agent Bridge for Topics -->
## Python Agent Bridge for Topics

One of the most important applications of publish-subscribe communication in robotics is bridging Python AI agents to ROS controllers. This pattern enables AI algorithms to send commands to robot controllers and receive sensor feedback through ROS topics.

### Bridge Architecture for Topic Communication

The bridge architecture involves creating ROS 2 nodes that translate between Python agent outputs and ROS messages:

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Float32, Bool
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
import numpy as np
import time

class TopicBridgeNode(Node):
    """
    A bridge node that connects Python AI agents to ROS controllers using topics.
    This demonstrates how to use publish-subscribe for AI-robot communication.
    """

    def __init__(self):
        super().__init__('topic_bridge')

        # Declare bridge configuration parameters
        self.declare_parameter('bridge_frequency', 20)  # Hz
        self.declare_parameter('safety_threshold', 0.5)  # meters
        self.declare_parameter('max_linear_velocity', 1.0)
        self.declare_parameter('max_angular_velocity', 1.0)

        # Get parameter values
        self.bridge_frequency = self.get_parameter('bridge_frequency').value
        self.safety_threshold = self.get_parameter('safety_threshold').value
        self.max_linear_vel = self.get_parameter('max_linear_velocity').value
        self.max_angular_vel = self.get_parameter('max_angular_velocity').value

        # Publishers to send commands to robot controllers
        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)
        self.agent_status_publisher = self.create_publisher(String, '/agent_status', 10)

        # Subscribers to receive sensor data from robot
        self.laser_subscriber = self.create_subscription(
            LaserScan, '/scan', self.laser_callback, 10
        )
        self.odom_subscriber = self.create_subscription(
            Odometry, '/odom', self.odom_callback, 10
        )

        # Subscribers for agent commands and control signals
        self.agent_command_subscriber = self.create_subscription(
            String, '/agent_commands', self.agent_command_callback, 10
        )
        self.agent_control_subscriber = self.create_subscription(
            Bool, '/agent_enabled', self.agent_control_callback, 10
        )

        # Timer for bridge processing loop
        timer_period = 1.0 / self.bridge_frequency
        self.bridge_timer = self.create_timer(timer_period, self.bridge_process)

        # State variables
        self.latest_laser_data = None
        self.latest_odom_data = None
        self.latest_agent_command = None
        self.agent_enabled = True
        self.safety_mode = False
        self.last_command_time = time.time()

        # Agent state tracking
        self.agent_state = {
            'position': (0.0, 0.0),
            'orientation': 0.0,
            'velocity': (0.0, 0.0),
            'safety_status': 'normal',
            'last_action': 'none'
        }

        # Log initialization
        self.get_logger().info('Topic Bridge Node initialized')
        self.get_logger().info(f'Bridge frequency: {self.bridge_frequency} Hz')
        self.get_logger().info(f'Safety threshold: {self.safety_threshold} m')

    def laser_callback(self, msg):
        """Handle incoming laser scan data from the robot."""
        self.latest_laser_data = msg
        self.get_logger().debug(f'Received laser scan with {len(msg.ranges)} ranges')

        # Update safety status based on laser data
        if self.latest_laser_data:
            valid_ranges = [r for r in self.latest_laser_data.ranges
                          if r != float('inf') and not np.isnan(r) and r > 0]
            if valid_ranges:
                min_range = min(valid_ranges)
                if min_range < self.safety_threshold:
                    self.safety_mode = True
                    self.agent_state['safety_status'] = 'obstacle_detected'
                    self.get_logger().warn(f'Safety threshold violated: {min_range:.2f}m < {self.safety_threshold:.2f}m')
                else:
                    self.safety_mode = False
                    self.agent_state['safety_status'] = 'normal'

    def odom_callback(self, msg):
        """Handle incoming odometry data from the robot."""
        self.latest_odom_data = msg

        # Update agent state with position information
        self.agent_state['position'] = (msg.pose.pose.position.x, msg.pose.pose.position.y)
        # Simplified orientation extraction (in a real system, you'd use quaternions properly)
        self.agent_state['orientation'] = 0.0  # Placeholder
        self.agent_state['velocity'] = (msg.twist.twist.linear.x, msg.twist.twist.angular.z)

    def agent_command_callback(self, msg):
        """Handle high-level commands from the Python agent."""
        self.latest_agent_command = msg.data
        self.agent_state['last_action'] = msg.data
        self.last_command_time = time.time()

        self.get_logger().info(f'Received agent command: {msg.data}')

        # Process special agent commands
        if msg.data == 'enable':
            self.agent_enabled = True
            self.get_logger().info('Agent enabled')
        elif msg.data == 'disable':
            self.agent_enabled = False
            self.get_logger().info('Agent disabled')
        elif msg.data == 'reset_safety':
            self.safety_mode = False
            self.agent_state['safety_status'] = 'normal'
            self.get_logger().info('Safety mode reset')

    def agent_control_callback(self, msg):
        """Handle enable/disable commands for the agent bridge."""
        self.agent_enabled = msg.data
        status = 'enabled' if self.agent_enabled else 'disabled'
        self.get_logger().info(f'Agent bridge {status} via control topic')

    def bridge_process(self):
        """Main bridge processing loop that runs at bridge_frequency."""
        if not self.agent_enabled:
            return

        # Safety check - if in safety mode, stop the robot
        if self.safety_mode:
            self.emergency_stop()
            return

        # Process sensor data and make decisions if available
        if self.latest_laser_data and self.latest_odom_data:
            # Example AI decision based on sensor data
            cmd_vel = self.make_decision_from_sensors()

            # Publish the command to the robot controller
            if cmd_vel:
                self.cmd_vel_publisher.publish(cmd_vel)
                self.get_logger().debug(f'Sent command: linear={cmd_vel.linear.x:.2f}, angular={cmd_vel.angular.z:.2f}')

        # Publish agent status periodically
        if time.time() - self.last_command_time > 1.0:  # Every second
            self.publish_agent_status()

    def make_decision_from_sensors(self):
        """
        Example AI decision-making function based on sensor data.
        This function analyzes sensor information and returns navigation commands.
        """
        if not self.latest_laser_data or not self.latest_odom_data:
            return None

        # Analyze laser data for navigation
        laser = self.latest_laser_data
        front_ranges = laser.ranges[330:] + laser.ranges[:30]  # Front 60 degrees
        valid_ranges = [r for r in front_ranges if r != float('inf') and not np.isnan(r) and r > 0]

        if not valid_ranges:
            # If no valid ranges in front, move forward slowly
            cmd = Twist()
            cmd.linear.x = 0.2
            cmd.angular.z = 0.0
            return cmd

        min_front_distance = min(valid_ranges)

        # Navigation algorithm based on obstacle distance
        cmd = Twist()

        if min_front_distance < self.safety_threshold * 1.2:  # Safety buffer
            # Too close to obstacle, turn away
            cmd.linear.x = 0.0
            cmd.angular.z = 0.8  # Turn right
        elif min_front_distance < self.safety_threshold * 2.5:
            # Moderate distance, move forward slowly and check surroundings
            cmd.linear.x = 0.3
            # Add slight turning to scan environment
            cmd.angular.z = 0.1 * np.sin(time.time())  # Gentle oscillation
        else:
            # Safe distance, move forward at normal speed
            cmd.linear.x = 0.8
            cmd.angular.z = 0.0

        return cmd

    def publish_agent_status(self):
        """Publish current agent status for monitoring."""
        status_msg = String()
        status_msg.data = f'Agent running - Pos:({self.agent_state["position"][0]:.2f},{self.agent_state["position"][1]:.2f}) ' \
                         f'Status:{self.agent_state["safety_status"]} ' \
                         f'Action:{self.agent_state["last_action"]}'
        self.agent_status_publisher.publish(status_msg)

    def emergency_stop(self):
        """Send emergency stop command to robot."""
        cmd = Twist()
        cmd.linear.x = 0.0
        cmd.angular.z = 0.0
        self.cmd_vel_publisher.publish(cmd)
        self.get_logger().warn('Emergency stop command sent due to safety violation')

def main(args=None):
    rclpy.init(args=args)

    bridge_node = TopicBridgeNode()

    try:
        rclpy.spin(bridge_node)
    except KeyboardInterrupt:
        bridge_node.get_logger().info('Interrupted, shutting down...')
    finally:
        bridge_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Advanced Bridge Features

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Float32MultiArray
from sensor_msgs.msg import LaserScan, Image
from geometry_msgs.msg import Twist
from cv_bridge import CvBridge
import numpy as np
import time
import threading
from queue import Queue

class AdvancedTopicBridgeNode(Node):
    """
    An advanced bridge node with multiple features for AI-robot communication.
    This includes sensor fusion, command queuing, and advanced safety systems.
    """

    def __init__(self):
        super().__init__('advanced_topic_bridge')

        # Declare advanced configuration parameters
        self.declare_parameter('bridge_frequency', 30)
        self.declare_parameter('safety_check_frequency', 100)
        self.declare_parameter('command_timeout', 2.0)
        self.declare_parameter('max_command_queue', 10)

        # Get parameter values
        self.bridge_frequency = self.get_parameter('bridge_frequency').value
        self.safety_frequency = self.get_parameter('safety_check_frequency').value
        self.command_timeout = self.get_parameter('command_timeout').value
        self.max_queue_size = self.get_parameter('max_command_queue').value

        # Publishers
        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)
        self.status_publisher = self.create_publisher(String, '/bridge_status', 10)

        # Subscribers
        self.laser_subscriber = self.create_subscription(LaserScan, '/scan', self.laser_callback, 10)
        self.image_subscriber = self.create_subscription(Image, '/camera/image_raw', self.image_callback, 10)

        # Agent command subscribers
        self.agent_command_subscriber = self.create_subscription(String, '/agent_commands', self.agent_command_callback, 10)

        # Timers
        self.bridge_timer = self.create_timer(1.0/self.bridge_frequency, self.bridge_process)
        self.safety_timer = self.create_timer(1.0/self.safety_frequency, self.safety_check)

        # Data storage
        self.laser_data = None
        self.image_data = None
        self.command_queue = Queue(maxsize=self.max_queue_size)
        self.last_command_time = time.time()
        self.bridge_enabled = True
        self.safety_violation = False

        # Threading for image processing (if needed)
        self.image_lock = threading.Lock()

        # CV Bridge for image processing
        try:
            self.cv_bridge = CvBridge()
        except ImportError:
            self.get_logger().warn('cv_bridge not available, image processing disabled')
            self.cv_bridge = None

        self.get_logger().info('Advanced Topic Bridge Node initialized')

    def laser_callback(self, msg):
        """Handle laser scan data."""
        self.laser_data = msg

    def image_callback(self, msg):
        """Handle image data."""
        with self.image_lock:
            self.image_data = msg

    def agent_command_callback(self, msg):
        """Handle agent commands with queuing."""
        try:
            if not self.command_queue.full():
                self.command_queue.put((time.time(), msg.data))
                self.last_command_time = time.time()
            else:
                self.get_logger().warn('Command queue full, dropping command')
        except Exception as e:
            self.get_logger().error(f'Error adding command to queue: {e}')

    def safety_check(self):
        """High-frequency safety checks."""
        if not self.bridge_enabled:
            return

        if self.laser_data:
            # Check for imminent collision
            valid_ranges = [r for r in self.laser_data.ranges
                          if r != float('inf') and not np.isnan(r) and r > 0 and r < 0.3]
            if valid_ranges:
                self.safety_violation = True
                self.emergency_stop()
                self.get_logger().error('SAFETY VIOLATION: Obstacle too close')
            else:
                self.safety_violation = False

        # Check for command timeout
        if time.time() - self.last_command_time > self.command_timeout:
            self.get_logger().warn('No commands received recently, stopping robot')
            self.emergency_stop()

    def bridge_process(self):
        """Main bridge processing loop."""
        if not self.bridge_enabled or self.safety_violation:
            return

        # Process commands from queue
        processed_count = 0
        while not self.command_queue.empty() and processed_count < 3:  # Process up to 3 commands per cycle
            try:
                timestamp, command = self.command_queue.get_nowait()

                # Check if command is too old
                if time.time() - timestamp > self.command_timeout:
                    self.get_logger().debug(f'Discarding old command: {command}')
                    continue

                # Process the command
                self.process_agent_command(command)
                processed_count += 1
            except:
                break  # Queue is empty

        # Publish status
        status_msg = String()
        status_msg.data = f'Bridge active - Commands in queue: {self.command_queue.qsize()}, ' \
                         f'Safety: {"OK" if not self.safety_violation else "VIOLATION"}'
        self.status_publisher.publish(status_msg)

    def process_agent_command(self, command):
        """Process a single agent command."""
        self.get_logger().debug(f'Processing agent command: {command}')

        # Example command processing
        if command.startswith('move:'):
            try:
                parts = command.split(':')
                if len(parts) >= 3:
                    linear = float(parts[1])
                    angular = float(parts[2])

                    cmd = Twist()
                    cmd.linear.x = max(-1.0, min(1.0, linear))  # Clamp to reasonable values
                    cmd.angular.z = max(-1.0, min(1.0, angular))

                    self.cmd_vel_publisher.publish(cmd)
                    self.get_logger().info(f'Sent movement command: linear={linear}, angular={angular}')
            except ValueError:
                self.get_logger().error(f'Invalid move command format: {command}')

    def emergency_stop(self):
        """Immediate stop for safety."""
        cmd = Twist()
        cmd.linear.x = 0.0
        cmd.angular.z = 0.0
        self.cmd_vel_publisher.publish(cmd)

def main(args=None):
    rclpy.init(args=args)

    advanced_bridge = AdvancedTopicBridgeNode()

    try:
        rclpy.spin(advanced_bridge)
    except KeyboardInterrupt:
        advanced_bridge.get_logger().info('Interrupted, shutting down...')
    finally:
        advanced_bridge.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Bridge Pattern Benefits for Topics

1. **Decoupling**: AI agents and robot controllers operate independently
2. **Scalability**: Multiple agents can potentially influence the same robot
3. **Safety**: The bridge can implement safety checks and override agent decisions
4. **Flexibility**: Different AI algorithms can be swapped without changing controllers
5. **Monitoring**: Bridge nodes can log and monitor AI-robot interactions

<!-- DIAGRAM: Topic Bridge - AI Agent to Robot Controller Communication -->
<!-- CHUNK END: Python Agent Bridge for Topics -->

## Summary

In this section, we've explored the publish-subscribe pattern in ROS 2 using `rclpy`. You've learned:

1. **Publisher creation** and configuration with various parameters
2. **Subscriber implementation** with efficient message processing
3. **Custom message types** for specialized applications
4. **Quality of Service settings** for different communication requirements
5. **Python agent bridge patterns** for connecting AI algorithms to robot controllers using topics

The publish-subscribe pattern is fundamental to ROS 2 and enables the distributed, asynchronous communication that makes robotic systems flexible and scalable.

## Exercises

1. **Multi-topic Publisher**: Create a publisher that sends synchronized sensor data (e.g., temperature, humidity, pressure) to multiple topics with appropriate QoS settings.

2. **Aggregating Subscriber**: Implement a subscriber that receives data from multiple topics and publishes a combined summary message.

3. **Custom Message Publisher/Subscriber**: Define and use a custom message type to represent robot health status (battery, temperature, error flags) and implement both publisher and subscriber.

4. **QoS Experimentation**: Create a system with different QoS profiles and observe how message delivery changes under network stress or node failures.

5. **Advanced Bridge**: Implement a bridge node that combines sensor data from multiple sources (laser, camera, IMU) and provides a unified interface for Python AI agents.

6. **Safety-Enhanced Bridge**: Extend the bridge example to include multiple safety checks (laser, camera, IMU) and implement a safety state machine.

<!-- DIAGRAM: Exercise Scenarios - Topic Communication Applications -->