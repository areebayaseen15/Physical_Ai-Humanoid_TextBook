---
id: 2-3-Collision-Detection
title: Collision Detection and Contact Response in Gazebo
sidebar_position: 3
---
---

## <!-- CHUNK START: Section 2.3 -->
### 2.3 Collision Detection and Contact Response

**Learning Objectives:**
- Understand how Gazebo simulates collisions between objects.
- Learn to configure collision shapes for robot links and environment objects.
- Analyze contact forces and handle collisions realistically.

Gazebo uses **physics engines** (ODE, Bullet, DART) to calculate interactions between objects. Collision detection ensures that objects do not pass through each other and that physical forces, such as impacts and friction, are accurately simulated.

**Collision Shapes:**
- **Primitive Shapes:** Box, Sphere, Cylinder – computationally efficient for simple objects.
- **Mesh Collisions:** High-fidelity shapes using STL/OBJ files; useful for complex robot geometries but more computationally expensive.
- **Link-Level Collision:** Each robot link must have a `<collision>` element in URDF/SDF for accurate simulation.

**Example URDF Collision Element:**
```xml
<link name="robot_arm_link">
  <collision>
    <geometry>
      <box>
        <size>0.1 0.05 0.3</size>
      </box>
    </geometry>
    <pose>0 0 0 0 0 0</pose>
  </collision>
</link>
```

**Contact Parameters:**
- **Friction:** Determines sliding behavior between surfaces.
- **Restitution:** Bounciness of collisions.
- **Damping:** Reduces oscillations or unwanted vibrations during contact.

**Example SDF Contact Parameters:**
```xml
<collision name="floor_collision">
  <surface>
    <friction>
      <ode>
        <mu>1.0</mu>
        <mu2>1.0</mu2>
      </ode>
    </friction>
    <bounce>
      <restitution_coefficient>0.1</restitution_coefficient>
    </bounce>
    <contact>
      <ode>
        <soft_cfm>0</soft_cfm>
        <soft_erp>0.2</soft_erp>
      </ode>
    </contact>
  </surface>
</collision>
```

**Python Example – Listening to Contact States (ROS 2 Gazebo Plugin):**
```python
import rclpy
from gazebo_msgs.msg import ContactsState
from rclpy.node import Node

class ContactListener(Node):
    def __init__(self):
        super().__init__('contact_listener')
        self.subscription = self.create_subscription(
            ContactsState,
            '/robot/bumper_states',
            self.contact_callback,
            10
        )

    def contact_callback(self, msg):
        for state in msg.states:
            self.get_logger().info(f'Collision detected: {state.collision1_name} ↔ {state.collision2_name}')

rclpy.init()
node = ContactListener()
rclpy.spin(node)
rclpy.shutdown()
```

This listener subscribes to a Gazebo contact topic and prints collision information, helping developers debug physical interactions and tune contact parameters.

**Key Terms for RAG:** Collision Detection, Contact Response, Friction, Restitution, Damping, ODE, Bullet, DART, Collision Shapes, URDF, SDF, Contact Forces, Gazebo Physics Simulation.

**Cross-Reference:** The next section (2.4) will cover integrating sensors (LiDAR, Depth Cameras, IMUs) with simulated objects and collision environments.

<!-- CHUNK END: Section 2.3 -->