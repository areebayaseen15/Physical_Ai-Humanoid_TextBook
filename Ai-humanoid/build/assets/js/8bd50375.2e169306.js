"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[4859],{2413:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>_,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-4-Actions","title":"1 3.4 Actions","description":"Introduction to Actions in ROS 2","source":"@site/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3.4 Actions.md","sourceDirName":"Module1-ROS/Chapter3-PythonAgentsWithRclpy","slug":"/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-4-Actions","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-4-Actions","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3.4 Actions.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"id":"1-3-4-Actions","title":"1 3.4 Actions","sidebar_label":"1 3.4 Actions","sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"1 3.3 Services","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-3-Services"},"next":{"title":"Chapter 3 Overview","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/"}}');var o=a(4848),l=a(8453);const r={id:"1-3-4-Actions",title:"1 3.4 Actions",sidebar_label:"1 3.4 Actions",sidebar_position:0},i="Chapter 3-04: Python Action Clients and Servers with rclpy",s={},c=[{value:"Introduction to Actions in ROS 2",id:"introduction-to-actions-in-ros-2",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Creating Action Servers",id:"creating-action-servers",level:2},{value:"Basic Action Server Implementation",id:"basic-action-server-implementation",level:3},{value:"Parameterized Action Server",id:"parameterized-action-server",level:3},{value:"Advanced Action Server with Multiple Actions",id:"advanced-action-server-with-multiple-actions",level:3},{value:"Action Server Best Practices",id:"action-server-best-practices",level:3},{value:"Creating Action Clients",id:"creating-action-clients",level:2},{value:"Basic Action Client Implementation",id:"basic-action-client-implementation",level:3},{value:"Advanced Action Client with Goal Management",id:"advanced-action-client-with-goal-management",level:3},{value:"Action Client with Timeout and Retry Logic",id:"action-client-with-timeout-and-retry-logic",level:3},{value:"Action Client Best Practices",id:"action-client-best-practices",level:3},{value:"Working with Custom Action Types",id:"working-with-custom-action-types",level:2},{value:"Defining Custom Action Types",id:"defining-custom-action-types",level:3},{value:"Implementing Custom Actions",id:"implementing-custom-actions",level:3},{value:"Complex Custom Action Example",id:"complex-custom-action-example",level:3},{value:"Custom Action Best Practices",id:"custom-action-best-practices",level:3},{value:"Python Agent Bridge for Actions",id:"python-agent-bridge-for-actions",level:2},{value:"Action Bridge Architecture",id:"action-bridge-architecture",level:3},{value:"Advanced Action Bridge with Priority Management",id:"advanced-action-bridge-with-priority-management",level:3},{value:"Action Bridge Benefits",id:"action-bridge-benefits",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function g(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"chapter-3-04-python-action-clients-and-servers-with-rclpy",children:"Chapter 3-04: Python Action Clients and Servers with rclpy"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-actions-in-ros-2",children:"Introduction to Actions in ROS 2"}),"\n",(0,o.jsx)(n.p,{children:"Actions in ROS 2 (Robot Operating System 2) provide a communication pattern for long-running tasks that require feedback, goal management, and cancellation capabilities. Unlike services, which are synchronous and provide a single response, or topics, which are asynchronous and continuous, actions combine the best of both worlds by enabling long-running operations with intermediate feedback and the ability to cancel operations in progress."}),"\n",(0,o.jsx)(n.p,{children:"Actions are particularly useful for robotic applications such as navigation, manipulation, trajectory execution, and any task that takes a significant amount of time to complete while requiring ongoing communication about progress and status."}),"\n",(0,o.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Create action servers that handle long-running tasks with feedback"}),"\n",(0,o.jsx)(n.li,{children:"Create action clients that send goals and receive feedback and results"}),"\n",(0,o.jsx)(n.li,{children:"Implement custom action types for specific applications"}),"\n",(0,o.jsx)(n.li,{children:"Handle goal preemption, cancellation, and result reporting"}),"\n",(0,o.jsx)(n.li,{children:"Bridge Python AI agents to ROS controllers using action communication"}),"\n",(0,o.jsx)(n.li,{children:"Structure action communication content for RAG (Retrieval-Augmented Generation) indexing"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action"}),": A communication pattern for long-running tasks with feedback"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action Server"}),": A node that executes long-running goals and provides feedback"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action Client"}),": A node that sends goals and receives feedback/results"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Goal"}),": A request for a long-running operation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Feedback"}),": Intermediate status updates during goal execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Result"}),": Final outcome of a completed goal"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Goal ID"}),": Unique identifier for tracking individual goals"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"creating-action-servers",children:"Creating Action Servers"}),"\n",(0,o.jsxs)(n.p,{children:["Action servers in ROS 2 handle long-running tasks that provide feedback during execution and return results upon completion. Creating an action server in ",(0,o.jsx)(n.code,{children:"rclpy"})," involves using the ",(0,o.jsx)(n.code,{children:"create_action_server()"})," method of a node instance, which requires an action type and callback functions for handling goals, executions, and cancellations."]}),"\n",(0,o.jsx)(n.h3,{id:"basic-action-server-implementation",children:"Basic Action Server Implementation"}),"\n",(0,o.jsxs)(n.p,{children:["First, let's define a simple action type. In a real project, this would be in an ",(0,o.jsx)(n.code,{children:".action"})," file:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"# In your_robot_package/action/Fibonacci.action\nint32 order\n---\nint32[] sequence\n---\nint32[] partial_sequence\n"})}),"\n",(0,o.jsx)(n.p,{children:"Then implement the action server:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom your_robot_package.action import Fibonacci  # Custom action type\nfrom rclpy.executors import MultiThreadedExecutor\nimport time\nimport threading\n\nclass BasicActionServer(Node):\n    """\n    A basic action server that demonstrates the fundamental concepts of\n    creating and implementing an action server in ROS 2 using rclpy.\n    """\n\n    def __init__(self):\n        super().__init__(\'basic_action_server\')\n\n        # Create the action server\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            \'fibonacci\',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n        self.get_logger().info(\'Basic Action Server initialized\')\n\n    def goal_callback(self, goal_request):\n        """\n        Accept or reject a goal.\n        This method is called when a new goal is received.\n        """\n        self.get_logger().info(f\'Received goal request with order: {goal_request.order}\')\n\n        # Accept all goals for this example\n        # In a real application, you might reject goals based on criteria\n        if goal_request.order > 0 and goal_request.order < 100:\n            return GoalResponse.ACCEPT\n        else:\n            self.get_logger().warn(f\'Rejecting goal with invalid order: {goal_request.order}\')\n            return GoalResponse.REJECT\n\n    def handle_accepted_callback(self, goal_handle):\n        """\n        Handle an accepted goal.\n        This method is called when a goal is accepted.\n        """\n        self.get_logger().info(\'Goal accepted, executing...\')\n\n        # Create a thread to execute the goal\n        # This allows the main thread to continue handling other requests\n        goal_thread = threading.Thread(target=self.execute_goal, args=(goal_handle,))\n        goal_thread.start()\n\n    def cancel_callback(self, goal_handle):\n        """\n        Accept or reject a cancel request.\n        This method is called when a cancel request is received.\n        """\n        self.get_logger().info(\'Received cancel request\')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        """\n        Execute the goal.\n        This method is called in a separate thread when the goal is executed.\n        """\n        # This method is called by the action server when the goal is ready to execute\n        # However, in our implementation, execution happens in the thread created by handle_accepted_callback\n        # So this method will not be used directly in this example\n        pass\n\n    def execute_goal(self, goal_handle):\n        """\n        Execute the actual goal in a separate thread.\n        """\n        # Create feedback message\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.partial_sequence = [0, 1]\n\n        # Check if the goal was canceled when it was accepted\n        if goal_handle.is_cancel_requested:\n            goal_handle.canceled()\n            self.get_logger().info(\'Goal canceled\')\n            return\n\n        # Calculate Fibonacci sequence\n        order = goal_handle.request.order\n        sequence = [0, 1]\n\n        # Send initial feedback\n        goal_handle.publish_feedback(feedback_msg)\n\n        # Calculate the sequence\n        for i in range(1, order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info(\'Goal canceled during execution\')\n                return\n\n            # Update sequence\n            next_fib = sequence[i] + sequence[i-1]\n            sequence.append(next_fib)\n\n            # Update feedback\n            feedback_msg.partial_sequence = sequence.copy()\n            goal_handle.publish_feedback(feedback_msg)\n\n            # Log progress\n            self.get_logger().info(f\'Fibonacci progress: {len(sequence)}/{order+2}\')\n\n            # Simulate processing time\n            time.sleep(0.5)\n\n        # Create result message\n        result = Fibonacci.Result()\n        result.sequence = sequence\n\n        # Check if the goal was canceled before completion\n        if goal_handle.is_cancel_requested:\n            goal_handle.canceled()\n            self.get_logger().info(\'Goal canceled before completion\')\n        else:\n            goal_handle.succeed()\n            self.get_logger().info(f\'Fibonacci sequence completed: {sequence}\')\n\n        # Return result\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    action_server = BasicActionServer()\n\n    try:\n        # Use MultiThreadedExecutor to handle the threaded execution\n        executor = MultiThreadedExecutor()\n        executor.add_node(action_server)\n        executor.spin()\n    except KeyboardInterrupt:\n        action_server.get_logger().info(\'Interrupted, shutting down...\')\n    finally:\n        action_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(n.h3,{id:"parameterized-action-server",children:"Parameterized Action Server"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom your_robot_package.action import Fibonacci\nfrom rclpy.executors import MultiThreadedExecutor\nimport time\nimport threading\nfrom enum import Enum\n\nclass GoalStatus(Enum):\n    PENDING = 1\n    EXECUTING = 2\n    CANCELING = 3\n    SUCCEEDED = 4\n    CANCELED = 5\n    ABORTED = 6\n\nclass ParameterizedActionServer(Node):\n    \"\"\"\n    An action server that uses parameters to configure its behavior.\n    This demonstrates how to make action servers configurable at runtime.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('parameterized_action_server')\n\n        # Declare parameters for action configuration\n        self.declare_parameter('max_fibonacci_order', 20)\n        self.declare_parameter('calculation_delay', 0.2)  # seconds between steps\n        self.declare_parameter('action_timeout', 30.0)   # seconds\n        self.declare_parameter('enable_feedback', True)\n\n        # Get parameter values\n        self.max_order = self.get_parameter('max_fibonacci_order').value\n        self.delay = self.get_parameter('calculation_delay').value\n        self.timeout = self.get_parameter('action_timeout').value\n        self.enable_feedback = self.get_parameter('enable_feedback').value\n\n        # Create the action server\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'parameterized_fibonacci',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n        # Track active goals\n        self.active_goals = {}\n\n        # Log configuration\n        self.get_logger().info(f'Parameterized Action Server initialized')\n        self.get_logger().info(f'Max order: {self.max_order}')\n        self.get_logger().info(f'Delay: {self.delay}s')\n        self.get_logger().info(f'Timeout: {self.timeout}s')\n        self.get_logger().info(f'Feedback enabled: {self.enable_feedback}')\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject goals based on parameters.\"\"\"\n        self.get_logger().info(f'Received goal: order={goal_request.order}')\n\n        # Validate goal based on parameters\n        if goal_request.order <= 0:\n            self.get_logger().warn('Rejecting goal: order must be positive')\n            return GoalResponse.REJECT\n\n        if goal_request.order > self.max_order:\n            self.get_logger().warn(f'Rejecting goal: order {goal_request.order} exceeds max {self.max_order}')\n            return GoalResponse.REJECT\n\n        return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        \"\"\"Handle an accepted goal.\"\"\"\n        self.get_logger().info(f'Goal {goal_handle.goal_id.uuid} accepted')\n\n        # Store goal in active goals\n        self.active_goals[str(goal_handle.goal_id.uuid)] = {\n            'status': GoalStatus.PENDING,\n            'start_time': time.time(),\n            'goal_handle': goal_handle\n        }\n\n        # Execute in a separate thread\n        goal_thread = threading.Thread(target=self.execute_goal, args=(goal_handle,))\n        goal_thread.start()\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Handle cancel requests.\"\"\"\n        goal_id = str(goal_handle.goal_id.uuid)\n        self.get_logger().info(f'Received cancel request for goal {goal_id}')\n\n        if goal_id in self.active_goals:\n            self.active_goals[goal_id]['status'] = GoalStatus.CANCELING\n\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute callback (not directly used in this implementation).\"\"\"\n        pass\n\n    def execute_goal(self, goal_handle):\n        \"\"\"Execute the goal in a separate thread.\"\"\"\n        goal_id = str(goal_handle.goal_id.uuid)\n        self.active_goals[goal_id]['status'] = GoalStatus.EXECUTING\n\n        try:\n            # Initialize feedback\n            feedback_msg = Fibonacci.Feedback()\n            feedback_msg.partial_sequence = [0, 1]\n\n            # Check for cancellation\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.active_goals[goal_id]['status'] = GoalStatus.CANCELED\n                self.get_logger().info(f'Goal {goal_id} canceled before execution')\n                return\n\n            # Calculate Fibonacci sequence\n            order = goal_handle.request.order\n            sequence = [0, 1]\n\n            # Send initial feedback if enabled\n            if self.enable_feedback:\n                goal_handle.publish_feedback(feedback_msg)\n\n            # Calculate the sequence with timeout\n            start_time = time.time()\n            for i in range(1, order):\n                # Check for cancellation\n                if goal_handle.is_cancel_requested:\n                    goal_handle.canceled()\n                    self.active_goals[goal_id]['status'] = GoalStatus.CANCELED\n                    self.get_logger().info(f'Goal {goal_id} canceled during execution')\n                    return\n\n                # Check for timeout\n                if time.time() - start_time > self.timeout:\n                    goal_handle.abort()\n                    self.active_goals[goal_id]['status'] = GoalStatus.ABORTED\n                    self.get_logger().error(f'Goal {goal_id} timed out after {self.timeout}s')\n                    return\n\n                # Calculate next Fibonacci number\n                next_fib = sequence[i] + sequence[i-1]\n                sequence.append(next_fib)\n\n                # Send feedback if enabled\n                if self.enable_feedback:\n                    feedback_msg.partial_sequence = sequence.copy()\n                    goal_handle.publish_feedback(feedback_msg)\n\n                # Log progress periodically\n                if len(sequence) % 5 == 0:  # Log every 5 numbers\n                    self.get_logger().info(f'Goal {goal_id}: Progress {len(sequence)}/{order+2}')\n\n                # Simulate processing time\n                time.sleep(self.delay)\n\n            # Create result\n            result = Fibonacci.Result()\n            result.sequence = sequence\n\n            # Check final status\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.active_goals[goal_id]['status'] = GoalStatus.CANCELED\n                self.get_logger().info(f'Goal {goal_id} canceled before completion')\n            else:\n                goal_handle.succeed()\n                self.active_goals[goal_id]['status'] = GoalStatus.SUCCEEDED\n                self.get_logger().info(f'Goal {goal_id} succeeded: {sequence}')\n\n        except Exception as e:\n            self.get_logger().error(f'Error executing goal {goal_id}: {e}')\n            goal_handle.abort()\n            self.active_goals[goal_id]['status'] = GoalStatus.ABORTED\n\n        finally:\n            # Remove from active goals\n            if goal_id in self.active_goals:\n                del self.active_goals[goal_id]\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    param_server = ParameterizedActionServer()\n\n    try:\n        executor = MultiThreadedExecutor()\n        executor.add_node(param_server)\n        executor.spin()\n    except KeyboardInterrupt:\n        param_server.get_logger().info('Interrupted, shutting down...')\n    finally:\n        param_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"advanced-action-server-with-multiple-actions",children:"Advanced Action Server with Multiple Actions"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom your_robot_package.action import Fibonacci\nfrom geometry_msgs.action import NavigateToPose\nfrom control_msgs.action import FollowJointTrajectory\nfrom rclpy.executors import MultiThreadedExecutor\nimport time\nimport threading\nfrom enum import Enum\nfrom typing import Dict, Any\n\nclass AdvancedActionServer(Node):\n    \"\"\"\n    An advanced action server that handles multiple action types\n    with sophisticated goal management and resource allocation.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_action_server')\n\n        # Create multiple action servers\n        self.fibonacci_server = ActionServer(\n            self,\n            Fibonacci,\n            'compute_fibonacci',\n            execute_callback=self.fibonacci_execute_callback,\n            goal_callback=self.fibonacci_goal_callback,\n            handle_accepted_callback=self.fibonacci_handle_accepted,\n            cancel_callback=self.fibonacci_cancel_callback\n        )\n\n        # For this example, we'll just define the servers\n        # In a real system, you'd implement all action types\n\n        # Resource management\n        self.max_concurrent_goals = 3\n        self.active_goal_count = 0\n        self.active_goal_lock = threading.Lock()\n\n        # Goal tracking\n        self.goal_info: Dict[str, Dict[str, Any]] = {}\n\n        self.get_logger().info('Advanced Action Server initialized')\n\n    def fibonacci_goal_callback(self, goal_request):\n        \"\"\"Goal callback for Fibonacci action.\"\"\"\n        with self.active_goal_lock:\n            if self.active_goal_count >= self.max_concurrent_goals:\n                self.get_logger().warn('Max concurrent goals reached, rejecting new goal')\n                return GoalResponse.REJECT\n\n        self.get_logger().info(f'Fibonacci goal request: order={goal_request.order}')\n        return GoalResponse.ACCEPT\n\n    def fibonacci_handle_accepted(self, goal_handle):\n        \"\"\"Handle accepted Fibonacci goal.\"\"\"\n        goal_id = str(goal_handle.goal_id.uuid)\n\n        with self.active_goal_lock:\n            self.active_goal_count += 1\n            self.goal_info[goal_id] = {\n                'type': 'fibonacci',\n                'start_time': time.time(),\n                'goal_handle': goal_handle\n            }\n\n        goal_thread = threading.Thread(\n            target=self.fibonacci_execute,\n            args=(goal_handle,)\n        )\n        goal_thread.start()\n\n    def fibonacci_cancel_callback(self, goal_handle):\n        \"\"\"Cancel callback for Fibonacci action.\"\"\"\n        goal_id = str(goal_handle.goal_id.uuid)\n        self.get_logger().info(f'Received cancel for Fibonacci goal {goal_id}')\n\n        if goal_id in self.goal_info:\n            self.goal_info[goal_id]['status'] = 'canceling'\n\n        return CancelResponse.ACCEPT\n\n    def fibonacci_execute_callback(self, goal_handle):\n        \"\"\"Execute callback (not directly used in this implementation).\"\"\"\n        pass\n\n    def fibonacci_execute(self, goal_handle):\n        \"\"\"Execute Fibonacci goal.\"\"\"\n        goal_id = str(goal_handle.goal_id.uuid)\n\n        try:\n            # Simulate computation with feedback\n            feedback_msg = Fibonacci.Feedback()\n            sequence = [0, 1]\n            feedback_msg.partial_sequence = sequence.copy()\n\n            order = goal_handle.request.order\n\n            # Check for cancellation before starting\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info(f'Fibonacci goal {goal_id} canceled before start')\n                return\n\n            # Send initial feedback\n            goal_handle.publish_feedback(feedback_msg)\n\n            # Calculate Fibonacci sequence\n            for i in range(1, order):\n                # Check for cancellation during execution\n                if goal_handle.is_cancel_requested:\n                    goal_handle.canceled()\n                    self.get_logger().info(f'Fibonacci goal {goal_id} canceled during execution')\n                    return\n\n                # Calculate next number\n                next_fib = sequence[i] + sequence[i-1]\n                sequence.append(next_fib)\n\n                # Send feedback\n                feedback_msg.partial_sequence = sequence.copy()\n                goal_handle.publish_feedback(feedback_msg)\n\n                # Simulate processing time\n                time.sleep(0.1)\n\n            # Complete the goal\n            result = Fibonacci.Result()\n            result.sequence = sequence\n            goal_handle.succeed()\n            self.get_logger().info(f'Fibonacci goal {goal_id} completed successfully')\n\n        except Exception as e:\n            self.get_logger().error(f'Error in Fibonacci goal {goal_id}: {e}')\n            goal_handle.abort()\n\n        finally:\n            # Update goal tracking\n            with self.active_goal_lock:\n                if goal_id in self.goal_info:\n                    del self.goal_info[goal_id]\n                self.active_goal_count -= 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    advanced_server = AdvancedActionServer()\n\n    try:\n        executor = MultiThreadedExecutor()\n        executor.add_node(advanced_server)\n        executor.spin()\n    except KeyboardInterrupt:\n        advanced_server.get_logger().info('Interrupted, shutting down...')\n    finally:\n        advanced_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"action-server-best-practices",children:"Action Server Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Threading"}),": Use separate threads for goal execution to avoid blocking the main thread"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cancellation"}),": Properly handle cancellation requests and check ",(0,o.jsx)(n.code,{children:"is_cancel_requested"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Feedback"}),": Send regular feedback updates to keep clients informed"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Error Handling"}),": Handle exceptions and abort goals when necessary"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Resource Management"}),": Track active goals and manage system resources"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Timeouts"}),": Implement appropriate timeouts for long-running operations"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"creating-action-clients",children:"Creating Action Clients"}),"\n",(0,o.jsxs)(n.p,{children:["Action clients in ROS 2 send goals to action servers and receive feedback and results during the execution of long-running tasks. Creating an action client in ",(0,o.jsx)(n.code,{children:"rclpy"})," involves using the ",(0,o.jsx)(n.code,{children:"create_action_client()"})," method of a node instance, followed by sending goals and handling feedback and results."]}),"\n",(0,o.jsx)(n.h3,{id:"basic-action-client-implementation",children:"Basic Action Client Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom your_robot_package.action import Fibonacci\nimport time\n\nclass BasicActionClient(Node):\n    """\n    A basic action client that demonstrates how to create and use\n    action clients in ROS 2 using rclpy.\n    """\n\n    def __init__(self):\n        super().__init__(\'basic_action_client\')\n\n        # Create the action client\n        self._action_client = ActionClient(self, Fibonacci, \'fibonacci\')\n\n        # Wait for the action server to be available\n        self.get_logger().info(\'Waiting for action server...\')\n        self._action_client.wait_for_server()\n\n        # Create a goal request\n        self._goal_request = Fibonacci.Goal()\n\n        # Timer to send goals periodically\n        self.timer = self.create_timer(5.0, self.send_goal)\n\n        self.get_logger().info(\'Basic Action Client initialized\')\n\n    def send_goal(self):\n        """Send a goal to the action server."""\n        # Set the goal parameters\n        self._goal_request.order = 10\n\n        self.get_logger().info(f\'Sending goal: Fibonacci order {self._goal_request.order}\')\n\n        # Send the goal and register callbacks\n        self._send_goal_future = self._action_client.send_goal_async(\n            self._goal_request,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Add a callback for when the goal is accepted\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        """Handle the goal response."""\n        goal_handle = future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Goal rejected by server\')\n            return\n\n        self.get_logger().info(\'Goal accepted by server\')\n\n        # Get the result future\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        """Handle feedback from the action server."""\n        self.get_logger().info(\n            f\'Received feedback: {len(feedback_msg.partial_sequence)} numbers calculated\'\n        )\n\n    def get_result_callback(self, future):\n        """Handle the final result."""\n        result = future.result().result\n        self.get_logger().info(f\'Result: {result.sequence}\')\n        self.get_logger().info(\'Goal completed\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    action_client = BasicActionClient()\n\n    try:\n        rclpy.spin(action_client)\n    except KeyboardInterrupt:\n        action_client.get_logger().info(\'Interrupted, shutting down...\')\n    finally:\n        action_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(n.h3,{id:"advanced-action-client-with-goal-management",children:"Advanced Action Client with Goal Management"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom your_robot_package.action import Fibonacci\nimport time\nimport threading\nfrom enum import Enum\nfrom typing import Dict, Any\n\nclass GoalState(Enum):\n    PENDING = 1\n    ACTIVE = 2\n    CANCELING = 3\n    SUCCEEDED = 4\n    CANCELED = 5\n    ABORTED = 6\n\nclass AdvancedActionClient(Node):\n    \"\"\"\n    An advanced action client with sophisticated goal management,\n    error handling, and multiple concurrent goal support.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_action_client')\n\n        # Create the action client\n        self._action_client = ActionClient(self, Fibonacci, 'parameterized_fibonacci')\n\n        # Wait for the action server to be available\n        self.get_logger().info('Waiting for action server...')\n        self._action_client.wait_for_server()\n\n        # Goal request template\n        self._goal_request = Fibonacci.Goal()\n\n        # Goal management\n        self.active_goals: Dict[str, Dict[str, Any]] = {}\n        self.goal_counter = 0\n\n        # Configuration parameters\n        self.declare_parameter('goal_frequency', 0.2)  # goals per second\n        self.declare_parameter('max_active_goals', 5)\n        self.declare_parameter('enable_cancellation', True)\n\n        self.goal_frequency = self.get_parameter('goal_frequency').value\n        self.max_active_goals = self.get_parameter('max_active_goals').value\n        self.enable_cancellation = self.get_parameter('enable_cancellation').value\n\n        # Timer for sending goals\n        timer_period = 1.0 / self.goal_frequency\n        self.timer = self.create_timer(timer_period, self.send_next_goal)\n\n        # Timer for goal management (cancellation, etc.)\n        self.management_timer = self.create_timer(2.0, self.manage_goals)\n\n        self.get_logger().info('Advanced Action Client initialized')\n\n    def send_next_goal(self):\n        \"\"\"Send the next goal if under the active goal limit.\"\"\"\n        active_count = sum(1 for goal_info in self.active_goals.values()\n                          if goal_info['state'] in [GoalState.PENDING, GoalState.ACTIVE])\n\n        if active_count >= self.max_active_goals:\n            self.get_logger().debug(f'Max active goals ({self.max_active_goals}) reached')\n            return\n\n        # Create and send a new goal\n        self.goal_counter += 1\n        goal_order = (self.goal_counter % 10) + 5  # Cycle through orders 5-14\n\n        self._goal_request.order = goal_order\n        goal_id = f'goal_{self.goal_counter}'\n\n        self.get_logger().info(f'Sending goal {goal_id}: Fibonacci order {goal_order}')\n\n        # Send the goal\n        send_goal_future = self._action_client.send_goal_async(\n            self._goal_request,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Store goal information\n        self.active_goals[goal_id] = {\n            'goal_request': self._goal_request.order,\n            'state': GoalState.PENDING,\n            'timestamp': time.time(),\n            'send_future': send_goal_future,\n            'goal_handle': None\n        }\n\n        # Add callback for goal response\n        send_goal_future.add_done_callback(\n            lambda future, gid=goal_id: self.goal_response_callback(future, gid)\n        )\n\n    def goal_response_callback(self, future, goal_id):\n        \"\"\"Handle the goal response.\"\"\"\n        try:\n            goal_handle = future.result()\n\n            if not goal_handle.accepted:\n                self.get_logger().warn(f'Goal {goal_id} rejected by server')\n                if goal_id in self.active_goals:\n                    self.active_goals[goal_id]['state'] = GoalState.ABORTED\n                return\n\n            self.get_logger().info(f'Goal {goal_id} accepted by server')\n\n            # Update goal state and handle\n            self.active_goals[goal_id]['state'] = GoalState.ACTIVE\n            self.active_goals[goal_id]['goal_handle'] = goal_handle\n\n            # Get the result future\n            get_result_future = goal_handle.get_result_async()\n            get_result_future.add_done_callback(\n                lambda future, gid=goal_id: self.get_result_callback(future, gid)\n            )\n\n        except Exception as e:\n            self.get_logger().error(f'Error handling goal response for {goal_id}: {e}')\n            if goal_id in self.active_goals:\n                self.active_goals[goal_id]['state'] = GoalState.ABORTED\n\n    def feedback_callback(self, feedback_msg):\n        \"\"\"Handle feedback from the action server.\"\"\"\n        # In a real system, you might want to associate feedback with specific goals\n        # For this example, we'll just log the feedback\n        self.get_logger().debug(\n            f'Received feedback: {len(feedback_msg.partial_sequence)} numbers calculated'\n        )\n\n    def get_result_callback(self, future, goal_id):\n        \"\"\"Handle the final result.\"\"\"\n        try:\n            goal_result = future.result()\n            result = goal_result.result\n            status = goal_result.status\n\n            # Update goal state based on result status\n            if status == 2:  # SUCCEEDED\n                self.active_goals[goal_id]['state'] = GoalState.SUCCEEDED\n                self.get_logger().info(f'Goal {goal_id} succeeded: {result.sequence}')\n            elif status == 5:  # CANCELED\n                self.active_goals[goal_id]['state'] = GoalState.CANCELED\n                self.get_logger().info(f'Goal {goal_id} was canceled')\n            else:\n                self.active_goals[goal_id]['state'] = GoalState.ABORTED\n                self.get_logger().warn(f'Goal {goal_id} was aborted with status {status}')\n\n        except Exception as e:\n            self.get_logger().error(f'Error getting result for {goal_id}: {e}')\n            if goal_id in self.active_goals:\n                self.active_goals[goal_id]['state'] = GoalState.ABORTED\n\n    def manage_goals(self):\n        \"\"\"Periodic goal management tasks.\"\"\"\n        current_time = time.time()\n\n        # Check for stuck goals (not updated in a long time)\n        for goal_id, goal_info in list(self.active_goals.items()):\n            if goal_info['state'] in [GoalState.ACTIVE, GoalState.CANCELING]:\n                time_since_update = current_time - goal_info['timestamp']\n\n                # If a goal has been active for more than 60 seconds, consider canceling it\n                if time_since_update > 60 and self.enable_cancellation:\n                    self.get_logger().warn(f'Goal {goal_id} appears stuck, canceling...')\n                    self.cancel_goal(goal_id)\n\n        # Log active goal statistics\n        state_counts = {}\n        for goal_info in self.active_goals.values():\n            state = goal_info['state']\n            state_counts[state] = state_counts.get(state, 0) + 1\n\n        self.get_logger().info(f'Goal statistics: {state_counts}')\n\n    def cancel_goal(self, goal_id):\n        \"\"\"Cancel a specific goal.\"\"\"\n        if goal_id not in self.active_goals:\n            self.get_logger().warn(f'Attempted to cancel non-existent goal: {goal_id}')\n            return\n\n        goal_info = self.active_goals[goal_id]\n        goal_handle = goal_info.get('goal_handle')\n\n        if goal_handle:\n            cancel_future = goal_handle.cancel_goal_async()\n            cancel_future.add_done_callback(\n                lambda future, gid=goal_id: self.cancel_response_callback(future, gid)\n            )\n            goal_info['state'] = GoalState.CANCELING\n            self.get_logger().info(f'Cancel request sent for goal {goal_id}')\n        else:\n            self.get_logger().warn(f'No goal handle for {goal_id}, cannot cancel')\n\n    def cancel_response_callback(self, future, goal_id):\n        \"\"\"Handle cancel response.\"\"\"\n        try:\n            cancel_response = future.result()\n            self.get_logger().info(f'Cancel response for {goal_id}: {cancel_response}')\n        except Exception as e:\n            self.get_logger().error(f'Error handling cancel response for {goal_id}: {e}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    advanced_client = AdvancedActionClient()\n\n    try:\n        rclpy.spin(advanced_client)\n    except KeyboardInterrupt:\n        advanced_client.get_logger().info('Interrupted, shutting down...')\n    finally:\n        advanced_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"action-client-with-timeout-and-retry-logic",children:"Action Client with Timeout and Retry Logic"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom your_robot_package.action import Fibonacci\nimport time\nimport threading\nfrom typing import Dict, Any\nfrom enum import Enum\n\nclass TimeoutActionClient(Node):\n    \"\"\"\n    An action client with sophisticated timeout and retry mechanisms\n    for handling unreliable action servers.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('timeout_action_client')\n\n        # Create the action client\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\n\n        # Wait for the action server to be available\n        self.get_logger().info('Waiting for action server...')\n        self._action_client.wait_for_server()\n\n        # Goal request template\n        self._goal_request = Fibonacci.Goal()\n\n        # Configuration\n        self.declare_parameter('goal_timeout', 30.0)  # seconds\n        self.declare_parameter('max_retries', 3)\n        self.declare_parameter('retry_delay', 2.0)   # seconds\n\n        self.goal_timeout = self.get_parameter('goal_timeout').value\n        self.max_retries = self.get_parameter('max_retries').value\n        self.retry_delay = self.get_parameter('retry_delay').value\n\n        # Goal tracking with timeout management\n        self.active_goals: Dict[str, Dict[str, Any]] = {}\n        self.goal_counter = 0\n\n        # Timer for sending goals\n        self.timer = self.create_timer(10.0, self.send_periodic_goal)\n\n        # Timer for timeout management\n        self.timeout_timer = self.create_timer(1.0, self.check_timeouts)\n\n        self.get_logger().info('Timeout Action Client initialized')\n\n    def send_periodic_goal(self):\n        \"\"\"Send a goal periodically.\"\"\"\n        self.goal_counter += 1\n        goal_order = (self.goal_counter % 5) + 5  # Orders 5-9\n\n        self._goal_request.order = goal_order\n        goal_id = f'timeout_goal_{self.goal_counter}'\n\n        self.get_logger().info(f'Sending timeout goal {goal_id}: order {goal_order}')\n\n        # Send the goal\n        send_future = self._action_client.send_goal_async(\n            self._goal_request,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Store goal info with timeout tracking\n        self.active_goals[goal_id] = {\n            'goal_request': goal_order,\n            'state': 'pending',\n            'timestamp': time.time(),\n            'send_future': send_future,\n            'goal_handle': None,\n            'retry_count': 0,\n            'original_request': self._goal_request.order\n        }\n\n        send_future.add_done_callback(\n            lambda future, gid=goal_id: self.goal_response_callback(future, gid)\n        )\n\n    def goal_response_callback(self, future, goal_id):\n        \"\"\"Handle goal response.\"\"\"\n        try:\n            goal_handle = future.result()\n\n            if not goal_handle.accepted:\n                self.get_logger().warn(f'Goal {goal_id} rejected, attempting retry')\n                self.handle_goal_failure(goal_id)\n                return\n\n            self.get_logger().info(f'Goal {goal_id} accepted')\n            self.active_goals[goal_id]['state'] = 'active'\n            self.active_goals[goal_id]['goal_handle'] = goal_handle\n\n            # Set up result callback\n            result_future = goal_handle.get_result_async()\n            result_future.add_done_callback(\n                lambda future, gid=goal_id: self.result_callback(future, gid)\n            )\n\n        except Exception as e:\n            self.get_logger().error(f'Error in goal response for {goal_id}: {e}')\n            self.handle_goal_failure(goal_id)\n\n    def result_callback(self, future, goal_id):\n        \"\"\"Handle the final result.\"\"\"\n        try:\n            goal_result = future.result()\n            result = goal_result.result\n            status = goal_result.status\n\n            if status == 2:  # SUCCEEDED\n                self.get_logger().info(f'Goal {goal_id} succeeded: {result.sequence}')\n                if goal_id in self.active_goals:\n                    del self.active_goals[goal_id]\n            else:\n                self.get_logger().warn(f'Goal {goal_id} failed with status {status}')\n                self.handle_goal_failure(goal_id)\n\n        except Exception as e:\n            self.get_logger().error(f'Error getting result for {goal_id}: {e}')\n            self.handle_goal_failure(goal_id)\n\n    def feedback_callback(self, feedback_msg):\n        \"\"\"Handle feedback (just log for this example).\"\"\"\n        self.get_logger().debug(f'Feedback received: {len(feedback_msg.partial_sequence)} numbers')\n\n    def check_timeouts(self):\n        \"\"\"Check for goals that have timed out.\"\"\"\n        current_time = time.time()\n        timed_out_goals = []\n\n        for goal_id, goal_info in self.active_goals.items():\n            time_elapsed = current_time - goal_info['timestamp']\n\n            if time_elapsed > self.goal_timeout:\n                timed_out_goals.append(goal_id)\n\n        for goal_id in timed_out_goals:\n            self.get_logger().warn(f'Goal {goal_id} timed out after {self.goal_timeout}s')\n            self.handle_goal_timeout(goal_id)\n\n    def handle_goal_timeout(self, goal_id):\n        \"\"\"Handle a goal that has timed out.\"\"\"\n        if goal_id not in self.active_goals:\n            return\n\n        goal_info = self.active_goals[goal_id]\n\n        # Attempt retry if under retry limit\n        if goal_info['retry_count'] < self.max_retries:\n            self.retry_goal(goal_id)\n        else:\n            self.get_logger().error(f'Goal {goal_id} failed after {self.max_retries} retries')\n            del self.active_goals[goal_id]\n\n    def handle_goal_failure(self, goal_id):\n        \"\"\"Handle a failed goal (rejected, aborted, etc.).\"\"\"\n        if goal_id not in self.active_goals:\n            return\n\n        goal_info = self.active_goals[goal_id]\n\n        # Attempt retry if under retry limit\n        if goal_info['retry_count'] < self.max_retries:\n            self.retry_goal(goal_id)\n        else:\n            self.get_logger().error(f'Goal {goal_id} failed after {self.max_retries} retries')\n            if goal_id in self.active_goals:\n                del self.active_goals[goal_id]\n\n    def retry_goal(self, goal_id):\n        \"\"\"Retry a failed or timed-out goal.\"\"\"\n        if goal_id not in self.active_goals:\n            return\n\n        goal_info = self.active_goals[goal_id]\n        retry_count = goal_info['retry_count'] + 1\n\n        self.get_logger().info(f'Retrying goal {goal_id} (attempt {retry_count}/{self.max_retries})')\n\n        # Update retry count\n        goal_info['retry_count'] = retry_count\n        goal_info['timestamp'] = time.time()\n\n        # Create new goal request with original parameters\n        self._goal_request.order = goal_info['original_request']\n\n        # Send new goal\n        send_future = self._action_client.send_goal_async(\n            self._goal_request,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Update goal info\n        goal_info['send_future'] = send_future\n        goal_info['state'] = 'pending'\n\n        send_future.add_done_callback(\n            lambda future, gid=goal_id: self.goal_response_callback(future, gid)\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    timeout_client = TimeoutActionClient()\n\n    try:\n        rclpy.spin(timeout_client)\n    except KeyboardInterrupt:\n        timeout_client.get_logger().info('Interrupted, shutting down...')\n    finally:\n        timeout_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"action-client-best-practices",children:"Action Client Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Server Availability"}),": Always wait for the action server before sending goals"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Asynchronous Operations"}),": Use ",(0,o.jsx)(n.code,{children:"send_goal_async()"})," and handle futures properly"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Error Handling"}),": Handle goal rejection, cancellation, and execution failures"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Timeout Management"}),": Implement appropriate timeouts for long-running operations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Resource Management"}),": Track active goals and avoid resource leaks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Feedback Processing"}),": Handle feedback appropriately for your application"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"working-with-custom-action-types",children:"Working with Custom Action Types"}),"\n",(0,o.jsx)(n.p,{children:"While ROS 2 provides some standard action types, you'll often need to define custom action types for your specific application. Custom actions enable sophisticated long-running operations with feedback and are essential for building specialized robotic applications."}),"\n",(0,o.jsx)(n.h3,{id:"defining-custom-action-types",children:"Defining Custom Action Types"}),"\n",(0,o.jsxs)(n.p,{children:["Action types are defined in ",(0,o.jsx)(n.code,{children:".action"})," files with three sections:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"# In your_robot_package/action/MoveToPose.action\n# Goal definition (input parameters)\ngeometry_msgs/Pose target_pose\nfloat64 tolerance\nstring description\n---\n# Result definition (final output)\nbool success\nstring message\ngeometry_msgs/Pose final_pose\nfloat64 execution_time\n---\n# Feedback definition (intermediate updates)\nfloat64 distance_to_goal\nfloat64 progress_percentage\nstring status\ngeometry_msgs/Pose current_pose\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"# In your_robot_package/action/ExecuteTrajectory.action\n# Goal\ntrajectory_msgs/JointTrajectory trajectory\nbool blocking\nfloat64 max_velocity\n---\n# Result\nbool success\nstring message\nint32 error_code\n---\n# Feedback\nfloat64 progress_percentage\nint32 current_waypoint\nstring status\n"})}),"\n",(0,o.jsx)(n.h3,{id:"implementing-custom-actions",children:"Implementing Custom Actions"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Action server for custom MoveToPose action\nimport rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom your_robot_package.action import MoveToPose\nfrom geometry_msgs.msg import Pose\nfrom rclpy.executors import MultiThreadedExecutor\nimport time\nimport threading\nimport math\n\nclass MoveToPoseActionServer(Node):\n    \"\"\"\n    An action server that implements a custom MoveToPose action for robot navigation.\n    This demonstrates working with complex custom action definitions.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('move_to_pose_action_server')\n\n        # Create the action server\n        self._action_server = ActionServer(\n            self,\n            MoveToPose,\n            'move_to_pose',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n        # Simulated robot state\n        self.current_pose = Pose()\n        self.current_pose.position.x = 0.0\n        self.current_pose.position.y = 0.0\n        self.current_pose.position.z = 0.0\n        self.current_pose.orientation.w = 1.0  # No rotation initially\n\n        # Robot movement parameters\n        self.linear_speed = 0.5  # m/s\n        self.angular_speed = 0.5  # rad/s\n        self.arrival_tolerance = 0.1  # m\n\n        self.get_logger().info('MoveToPose Action Server initialized')\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject move-to-pose goals.\"\"\"\n        # Validate the target pose\n        target = goal_request.target_pose\n        tolerance = goal_request.tolerance\n\n        # Check if target is valid (not NaN or inf)\n        if (math.isnan(target.position.x) or math.isnan(target.position.y) or\n            math.isinf(target.position.x) or math.isinf(target.position.y)):\n            self.get_logger().warn('Rejecting goal: invalid target pose coordinates')\n            return GoalResponse.REJECT\n\n        # Check if tolerance is positive\n        if tolerance <= 0:\n            self.get_logger().warn(f'Rejecting goal: invalid tolerance {tolerance}')\n            return GoalResponse.REJECT\n\n        self.get_logger().info(\n            f'Accepting goal: move to ({target.position.x:.2f}, {target.position.y:.2f}), '\n            f'tolerance: {tolerance:.2f}, description: {goal_request.description}'\n        )\n\n        return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        \"\"\"Handle an accepted goal.\"\"\"\n        self.get_logger().info('MoveToPose goal accepted, executing...')\n\n        # Execute in a separate thread\n        goal_thread = threading.Thread(\n            target=self.execute_goal,\n            args=(goal_handle,)\n        )\n        goal_thread.start()\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Handle cancel requests.\"\"\"\n        self.get_logger().info('MoveToPose cancel request received')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute callback (not directly used in this implementation).\"\"\"\n        pass\n\n    def execute_goal(self, goal_handle):\n        \"\"\"Execute the move-to-pose goal.\"\"\"\n        start_time = time.time()\n        target_pose = goal_handle.request.target_pose\n        tolerance = goal_handle.request.tolerance\n        description = goal_handle.request.description\n\n        # Initialize feedback\n        feedback_msg = MoveToPose.Feedback()\n        feedback_msg.current_pose = self.current_pose\n        feedback_msg.status = 'Moving to pose'\n\n        try:\n            # Calculate distance to target\n            dx = target_pose.position.x - self.current_pose.position.x\n            dy = target_pose.position.y - self.current_pose.position.y\n            distance_to_target = math.sqrt(dx*dx + dy*dy)\n\n            # Move toward the target\n            step_size = 0.05  # 5cm steps\n            total_distance = distance_to_target\n\n            while distance_to_target > tolerance:\n                # Check for cancellation\n                if goal_handle.is_cancel_requested:\n                    goal_handle.canceled()\n                    self.get_logger().info('MoveToPose goal canceled')\n                    return\n\n                # Calculate movement vector\n                move_x = dx * step_size / distance_to_target\n                move_y = dy * step_size / distance_to_target\n\n                # Update current pose\n                self.current_pose.position.x += move_x\n                self.current_pose.position.y += move_y\n\n                # Calculate remaining distance\n                dx = target_pose.position.x - self.current_pose.position.x\n                dy = target_pose.position.y - self.current_pose.position.y\n                distance_to_target = math.sqrt(dx*dx + dy*dy)\n\n                # Calculate progress\n                distance_traveled = total_distance - distance_to_target\n                progress = min(100.0, (distance_traveled / total_distance) * 100) if total_distance > 0 else 100.0\n\n                # Update feedback\n                feedback_msg.distance_to_goal = distance_to_target\n                feedback_msg.progress_percentage = progress\n                feedback_msg.status = f'Moving to pose: {description}'\n                feedback_msg.current_pose = self.current_pose\n\n                goal_handle.publish_feedback(feedback_msg)\n\n                # Log progress periodically\n                if int(progress) % 10 == 0:  # Log every 10%\n                    self.get_logger().info(\n                        f'MoveToPose progress: {progress:.1f}% - '\n                        f'Distance to goal: {distance_to_target:.2f}m'\n                    )\n\n                # Simulate movement time\n                time.sleep(0.1)\n\n            # Goal reached\n            execution_time = time.time() - start_time\n\n            # Create result\n            result = MoveToPose.Result()\n            result.success = True\n            result.message = f'Pose reached successfully in {execution_time:.2f}s'\n            result.final_pose = self.current_pose\n            result.execution_time = execution_time\n\n            goal_handle.succeed()\n            self.get_logger().info(\n                f'MoveToPose goal completed: {description} - '\n                f'Final position: ({self.current_pose.position.x:.2f}, {self.current_pose.position.y:.2f})'\n            )\n\n        except Exception as e:\n            self.get_logger().error(f'Error executing MoveToPose goal: {e}')\n            result = MoveToPose.Result()\n            result.success = False\n            result.message = f'Execution error: {str(e)}'\n            goal_handle.abort()\n\n        return result\n\n# Action client for custom MoveToPose action\nclass MoveToPoseActionClient(Node):\n    \"\"\"\n    An action client that uses the custom MoveToPose action.\n    This demonstrates how to call custom actions from Python.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('move_to_pose_action_client')\n\n        # Create the action client\n        self._action_client = ActionClient(self, MoveToPose, 'move_to_pose')\n\n        # Wait for the action server\n        self.get_logger().info('Waiting for MoveToPose action server...')\n        self._action_client.wait_for_server()\n\n        # Goal request template\n        self._goal_request = MoveToPose.Goal()\n\n        # Timer for demonstration\n        self.timer = self.create_timer(10.0, self.send_navigation_goal)\n\n        self.get_logger().info('MoveToPose Action Client initialized')\n\n    def send_navigation_goal(self):\n        \"\"\"Send a navigation goal to the robot.\"\"\"\n        # Create a target pose\n        target_pose = Pose()\n        target_pose.position.x = 2.0 + (self.get_clock().now().nanoseconds % 100) / 50.0  # Vary x position\n        target_pose.position.y = 1.0 + (self.get_clock().now().nanoseconds % 80) / 40.0   # Vary y position\n        target_pose.position.z = 0.0\n        target_pose.orientation.w = 1.0\n\n        # Set up the goal\n        self._goal_request.target_pose = target_pose\n        self._goal_request.tolerance = 0.1\n        self._goal_request.description = f'Navigation goal at {time.time():.0f}'\n\n        self.get_logger().info(\n            f'Sending navigation goal: ({target_pose.position.x:.2f}, {target_pose.position.y:.2f})'\n        )\n\n        # Send the goal\n        send_future = self._action_client.send_goal_async(\n            self._goal_request,\n            feedback_callback=self.feedback_callback\n        )\n\n        send_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        \"\"\"Handle goal response.\"\"\"\n        goal_handle = future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().warn('Navigation goal rejected by server')\n            return\n\n        self.get_logger().info('Navigation goal accepted')\n\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        \"\"\"Handle navigation feedback.\"\"\"\n        self.get_logger().info(\n            f'Navigation feedback: {feedback_msg.progress_percentage:.1f}% complete, '\n            f'{feedback_msg.distance_to_goal:.2f}m to goal'\n        )\n\n    def result_callback(self, future):\n        \"\"\"Handle navigation result.\"\"\"\n        goal_result = future.result()\n        result = goal_result.result\n        status = goal_result.status\n\n        if status == 2:  # SUCCEEDED\n            self.get_logger().info(f'Navigation succeeded: {result.message}')\n        else:\n            self.get_logger().warn(f'Navigation failed with status {status}: {result.message}')\n\ndef main_server(args=None):\n    rclpy.init(args=args)\n    server = MoveToPoseActionServer()\n\n    try:\n        executor = MultiThreadedExecutor()\n        executor.add_node(server)\n        executor.spin()\n    except KeyboardInterrupt:\n        server.get_logger().info('MoveToPose server interrupted')\n    finally:\n        server.destroy_node()\n        rclpy.shutdown()\n\ndef main_client(args=None):\n    rclpy.init(args=args)\n    client = MoveToPoseActionClient()\n\n    try:\n        rclpy.spin(client)\n    except KeyboardInterrupt:\n        client.get_logger().info('MoveToPose client interrupted')\n    finally:\n        client.destroy_node()\n        rclpy.shutdown()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"complex-custom-action-example",children:"Complex Custom Action Example"}),"\n",(0,o.jsx)(n.p,{children:"For more sophisticated applications, you might need actions with complex feedback and result structures:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"# In your_robot_package/action/ComplexManipulation.action\n# Goal\nstring manipulation_type  # 'pick', 'place', 'move', 'assemble'\ngeometry_msgs/Pose target_pose\nstring object_id\nfloat64 gripper_force\nbool use_vision\n---\n# Result\nbool success\nstring message\nint32 error_code\ngeometry_msgs/Pose final_pose\nbuiltin_interfaces/Time execution_start\nbuiltin_interfaces/Time execution_end\n---\n# Feedback\nstring phase  # 'approaching', 'grasping', 'lifting', 'moving', 'placing'\nfloat64 progress_percentage\ngeometry_msgs/Pose current_pose\nstring status_message\nbuiltin_interfaces/Time phase_start\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom your_robot_package.action import ComplexManipulation\nfrom geometry_msgs.msg import Pose\nfrom builtin_interfaces.msg import Time\nfrom rclpy.executors import MultiThreadedExecutor\nimport time\nimport threading\n\nclass ComplexManipulationServer(Node):\n    \"\"\"\n    A server for complex manipulation actions with detailed feedback.\n    This demonstrates working with complex custom action types.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('complex_manipulation_server')\n\n        self._action_server = ActionServer(\n            self,\n            ComplexManipulation,\n            'complex_manipulation',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n        # Simulated robot state\n        self.current_pose = Pose()\n        self.current_pose.position.x = 0.0\n        self.current_pose.position.y = 0.0\n        self.current_pose.position.z = 1.0  # Default height\n\n        self.get_logger().info('Complex Manipulation Server initialized')\n\n    def goal_callback(self, goal_request):\n        \"\"\"Validate and accept manipulation goals.\"\"\"\n        valid_types = ['pick', 'place', 'move', 'assemble']\n\n        if goal_request.manipulation_type not in valid_types:\n            self.get_logger().warn(f'Invalid manipulation type: {goal_request.manipulation_type}')\n            return GoalResponse.REJECT\n\n        self.get_logger().info(\n            f'Accepting manipulation goal: {goal_request.manipulation_type} '\n            f'for object {goal_request.object_id}'\n        )\n\n        return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        \"\"\"Handle accepted goal.\"\"\"\n        goal_thread = threading.Thread(\n            target=self.execute_manipulation,\n            args=(goal_handle,)\n        )\n        goal_thread.start()\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Handle cancel request.\"\"\"\n        self.get_logger().info('Manipulation cancel requested')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute callback.\"\"\"\n        pass\n\n    def execute_manipulation(self, goal_handle):\n        \"\"\"Execute the complex manipulation.\"\"\"\n        start_time = self.get_clock().now().to_msg()\n        request = goal_handle.request\n\n        # Initialize feedback\n        feedback_msg = ComplexManipulation.Feedback()\n        feedback_msg.current_pose = self.current_pose\n        feedback_msg.phase = 'initializing'\n        feedback_msg.progress_percentage = 0.0\n        feedback_msg.status_message = f'Starting {request.manipulation_type} operation'\n\n        try:\n            # Phase 1: Approach\n            feedback_msg.phase = 'approaching'\n            feedback_msg.status_message = f'Approaching {request.object_id}'\n\n            for i in range(20):  # Simulate approach\n                if goal_handle.is_cancel_requested:\n                    goal_handle.canceled()\n                    return\n\n                feedback_msg.progress_percentage = i * 5.0  # 0% to 100% over phases\n                feedback_msg.current_pose.position.x += 0.02\n                feedback_msg.current_pose.position.y += 0.01\n                goal_handle.publish_feedback(feedback_msg)\n                time.sleep(0.1)\n\n            # Phase 2: Execute manipulation based on type\n            if request.manipulation_type == 'pick':\n                feedback_msg.phase = 'grasping'\n                feedback_msg.status_message = f'Grasping {request.object_id}'\n\n                for i in range(10):\n                    if goal_handle.is_cancel_requested:\n                        goal_handle.canceled()\n                        return\n                    feedback_msg.progress_percentage = 50.0 + i * 5.0\n                    goal_handle.publish_feedback(feedback_msg)\n                    time.sleep(0.2)\n\n            elif request.manipulation_type == 'place':\n                feedback_msg.phase = 'placing'\n                feedback_msg.status_message = f'Placing {request.object_id}'\n\n                for i in range(10):\n                    if goal_handle.is_cancel_requested:\n                        goal_handle.canceled()\n                        return\n                    feedback_msg.progress_percentage = 50.0 + i * 5.0\n                    goal_handle.publish_feedback(feedback_msg)\n                    time.sleep(0.2)\n\n            # Finalize\n            end_time = self.get_clock().now().to_msg()\n\n            result = ComplexManipulation.Result()\n            result.success = True\n            result.message = f'{request.manipulation_type.title()} operation completed successfully'\n            result.error_code = 0\n            result.final_pose = self.current_pose\n            result.execution_start = start_time\n            result.execution_end = end_time\n\n            goal_handle.succeed()\n            self.get_logger().info(f'Manipulation completed: {result.message}')\n\n        except Exception as e:\n            result = ComplexManipulation.Result()\n            result.success = False\n            result.message = f'Manipulation error: {str(e)}'\n            result.error_code = 1\n            goal_handle.abort()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    server = ComplexManipulationServer()\n\n    try:\n        executor = MultiThreadedExecutor()\n        executor.add_node(server)\n        executor.spin()\n    except KeyboardInterrupt:\n        server.get_logger().info('Complex manipulation server interrupted')\n    finally:\n        server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"custom-action-best-practices",children:"Custom Action Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action Design"}),": Design actions with clear phases and meaningful feedback"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Error Handling"}),": Include comprehensive error reporting in results"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cancellation"}),": Properly handle cancellation requests during execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Progress Tracking"}),": Provide meaningful progress indicators in feedback"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Validation"}),": Validate goal parameters before accepting them"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Resource Management"}),": Track and manage resources used by active goals"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"python-agent-bridge-for-actions",children:"Python Agent Bridge for Actions"}),"\n",(0,o.jsx)(n.p,{children:"Actions provide an excellent mechanism for connecting Python AI agents to ROS controllers for long-running operations that require feedback and cancellation capabilities. This pattern is particularly useful for AI agents that need to monitor and potentially interrupt robot operations like navigation, manipulation, or complex task execution."}),"\n",(0,o.jsx)(n.h3,{id:"action-bridge-architecture",children:"Action Bridge Architecture"}),"\n",(0,o.jsx)(n.p,{children:"The action bridge architecture enables AI agents to send long-running goals to robot controllers while maintaining the ability to monitor progress and cancel operations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionClient, ActionServer\nfrom rclpy.node import Node\nfrom your_robot_package.action import MoveToPose, ComplexManipulation\nfrom geometry_msgs.msg import Pose\nfrom std_msgs.msg import String\nfrom std_srvs.srv import Trigger\nimport time\nimport threading\nfrom typing import Dict, Any\nfrom enum import Enum\n\nclass AgentActionBridge(Node):\n    \"\"\"\n    A bridge node that connects Python AI agents to ROS controllers using actions.\n    This enables long-running operations with feedback and cancellation.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('agent_action_bridge')\n\n        # Declare bridge configuration parameters\n        self.declare_parameter('bridge_frequency', 10.0)  # Hz\n        self.declare_parameter('action_timeout', 60.0)    # seconds\n        self.declare_parameter('enable_cancellation', True)\n\n        # Get parameter values\n        self.bridge_frequency = self.get_parameter('bridge_frequency').value\n        self.action_timeout = self.get_parameter('action_timeout').value\n        self.enable_cancellation = self.get_parameter('enable_cancellation').value\n\n        # Create action clients for robot operations\n        self.nav_client = ActionClient(self, MoveToPose, '/robot/move_to_pose')\n        self.manip_client = ActionClient(self, ComplexManipulation, '/robot/manipulation')\n\n        # Create services for agent interface\n        self.nav_service = self.create_service(\n            MoveToPose, '/agent/navigate', self.agent_navigate_callback\n        )\n        self.manip_service = self.create_service(\n            ComplexManipulation, '/agent/manipulate', self.agent_manipulate_callback\n        )\n\n        # Create action servers for agent interface\n        self.agent_nav_server = ActionServer(\n            self,\n            MoveToPose,\n            '/agent/action_navigate',\n            execute_callback=self.agent_action_navigate_execute,\n            goal_callback=self.agent_action_goal_callback,\n            handle_accepted_callback=self.agent_action_handle_accepted,\n            cancel_callback=self.agent_action_cancel_callback\n        )\n\n        # Wait for robot action servers\n        self.get_logger().info('Waiting for robot action servers...')\n        self.nav_client.wait_for_server()\n        self.manip_client.wait_for_server()\n\n        # Goal tracking\n        self.active_agent_goals: Dict[str, Dict[str, Any]] = {}\n        self.active_robot_goals: Dict[str, Dict[str, Any]] = {}\n\n        # Initialize request objects\n        self.nav_request = MoveToPose.Goal()\n        self.manip_request = ComplexManipulation.Goal()\n\n        self.get_logger().info('Agent Action Bridge initialized')\n\n    def agent_navigate_callback(self, request, response):\n        \"\"\"Handle navigation requests from Python AI agents.\"\"\"\n        try:\n            # Forward the navigation request to the robot\n            self.nav_request.target_pose = request.target_pose\n            self.nav_request.tolerance = request.tolerance\n            self.nav_request.description = f'Agent: {request.description}'\n\n            # Send the goal to the robot\n            send_future = self.nav_client.send_goal_async(self.nav_request)\n\n            # Wait for acceptance (synchronous from agent's perspective)\n            rclpy.spin_until_future_complete(self, send_future, timeout_sec=5.0)\n\n            if send_future.done():\n                goal_handle = send_future.result()\n                if goal_handle and goal_handle.accepted:\n                    # Wait for result\n                    result_future = goal_handle.get_result_async()\n                    rclpy.spin_until_future_complete(self, result_future, timeout_sec=self.action_timeout)\n\n                    if result_future.done():\n                        result_msg = result_future.result()\n                        result = result_msg.result\n\n                        response.success = result.success\n                        response.message = result.message\n                        response.final_pose = result.final_pose\n                        response.execution_time = result.execution_time\n                    else:\n                        response.success = False\n                        response.message = f'Navigation timed out after {self.action_timeout}s'\n                else:\n                    response.success = False\n                    response.message = 'Navigation goal was rejected by robot'\n            else:\n                response.success = False\n                response.message = 'Failed to send navigation goal to robot'\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Navigation error: {str(e)}'\n            self.get_logger().error(f'Navigation error: {e}')\n\n        return response\n\n    def agent_manipulate_callback(self, request, response):\n        \"\"\"Handle manipulation requests from Python AI agents.\"\"\"\n        try:\n            # Forward the manipulation request to the robot\n            self.manip_request.manipulation_type = request.manipulation_type\n            self.manip_request.target_pose = request.target_pose\n            self.manip_request.object_id = request.object_id\n            self.manip_request.gripper_force = request.gripper_force\n            self.manip_request.use_vision = request.use_vision\n\n            # Send the goal to the robot\n            send_future = self.manip_client.send_goal_async(self.manip_request)\n\n            # Wait for acceptance\n            rclpy.spin_until_future_complete(self, send_future, timeout_sec=5.0)\n\n            if send_future.done():\n                goal_handle = send_future.result()\n                if goal_handle and goal_handle.accepted:\n                    # Wait for result\n                    result_future = goal_handle.get_result_async()\n                    rclpy.spin_until_future_complete(self, result_future, timeout_sec=self.action_timeout)\n\n                    if result_future.done():\n                        result_msg = result_future.result()\n                        result = result_msg.result\n\n                        response.success = result.success\n                        response.message = result.message\n                        response.error_code = result.error_code\n                    else:\n                        response.success = False\n                        response.message = f'Manipulation timed out after {self.action_timeout}s'\n                else:\n                    response.success = False\n                    response.message = 'Manipulation goal was rejected by robot'\n            else:\n                response.success = False\n                response.message = 'Failed to send manipulation goal to robot'\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Manipulation error: {str(e)}'\n            self.get_logger().error(f'Manipulation error: {e}')\n\n        return response\n\n    def agent_action_goal_callback(self, goal_request):\n        \"\"\"Handle action goals from AI agents.\"\"\"\n        self.get_logger().info(f'Agent action goal received: {goal_request.description}')\n        return GoalResponse.ACCEPT\n\n    def agent_action_handle_accepted(self, goal_handle):\n        \"\"\"Handle accepted agent action goal.\"\"\"\n        goal_id = str(goal_handle.goal_id.uuid)\n\n        # Store goal info\n        self.active_agent_goals[goal_id] = {\n            'goal_handle': goal_handle,\n            'timestamp': time.time(),\n            'state': 'forwarding'\n        }\n\n        # Forward to robot in a separate thread\n        goal_thread = threading.Thread(\n            target=self.forward_agent_goal,\n            args=(goal_handle, goal_id)\n        )\n        goal_thread.start()\n\n    def forward_agent_goal(self, agent_goal_handle, agent_goal_id):\n        \"\"\"Forward an agent goal to the robot.\"\"\"\n        try:\n            # Extract goal from agent\n            agent_request = agent_goal_handle.request\n\n            # Forward to robot navigation\n            self.nav_request.target_pose = agent_request.target_pose\n            self.nav_request.tolerance = agent_request.tolerance\n            self.nav_request.description = f'Bridge: {agent_request.description}'\n\n            # Send to robot\n            send_future = self.nav_client.send_goal_async(\n                self.nav_request,\n                feedback_callback=lambda fb: self.robot_feedback_callback(fb, agent_goal_id)\n            )\n\n            # Wait for robot to accept\n            rclpy.spin_until_future_complete(self, send_future, timeout_sec=5.0)\n\n            if send_future.done():\n                robot_goal_handle = send_future.result()\n                if robot_goal_handle and robot_goal_handle.accepted:\n                    # Store robot goal info\n                    robot_goal_id = str(robot_goal_handle.goal_id.uuid)\n                    self.active_agent_goals[agent_goal_id]['robot_goal_handle'] = robot_goal_handle\n                    self.active_agent_goals[agent_goal_id]['robot_goal_id'] = robot_goal_id\n\n                    # Wait for robot result\n                    result_future = robot_goal_handle.get_result_async()\n                    rclpy.spin_until_future_complete(self, result_future, timeout_sec=self.action_timeout)\n\n                    if result_future.done():\n                        result_msg = result_future.result()\n                        robot_result = result_msg.result\n\n                        # Forward result back to agent\n                        if result_msg.status == 2:  # SUCCEEDED\n                            agent_goal_handle.succeed()\n                        elif result_msg.status == 5:  # CANCELED\n                            agent_goal_handle.canceled()\n                        else:\n                            agent_goal_handle.abort()\n\n                        # Create and return result\n                        agent_result = MoveToPose.Result()\n                        agent_result.success = robot_result.success\n                        agent_result.message = robot_result.message\n                        agent_result.final_pose = robot_result.final_pose\n                        agent_result.execution_time = robot_result.execution_time\n\n                        if agent_goal_id in self.active_agent_goals:\n                            del self.active_agent_goals[agent_goal_id]\n\n                        return agent_result\n                    else:\n                        agent_goal_handle.abort()\n                        agent_result = MoveToPose.Result()\n                        agent_result.success = False\n                        agent_result.message = f'Robot operation timed out after {self.action_timeout}s'\n\n                        if agent_goal_id in self.active_agent_goals:\n                            del self.active_agent_goals[agent_goal_id]\n\n                        return agent_result\n                else:\n                    agent_goal_handle.abort()\n                    agent_result = MoveToPose.Result()\n                    agent_result.success = False\n                    agent_result.message = 'Robot rejected the goal'\n\n                    if agent_goal_id in self.active_agent_goals:\n                        del self.active_agent_goals[agent_goal_id]\n\n                    return agent_result\n            else:\n                agent_goal_handle.abort()\n                agent_result = MoveToPose.Result()\n                agent_result.success = False\n                agent_result.message = 'Failed to send goal to robot'\n\n                if agent_goal_id in self.active_agent_goals:\n                    del self.active_agent_goals[agent_goal_id]\n\n                return agent_result\n\n        except Exception as e:\n            self.get_logger().error(f'Error forwarding agent goal {agent_goal_id}: {e}')\n            agent_goal_handle.abort()\n            agent_result = MoveToPose.Result()\n            agent_result.success = False\n            agent_result.message = f'Forwarding error: {str(e)}'\n\n            if agent_goal_id in self.active_agent_goals:\n                del self.active_agent_goals[agent_goal_id]\n\n            return agent_result\n\n    def robot_feedback_callback(self, feedback_msg, agent_goal_id):\n        \"\"\"Forward robot feedback to the agent.\"\"\"\n        if agent_goal_id in self.active_agent_goals:\n            # Create agent feedback (same structure as robot feedback for this example)\n            agent_feedback = MoveToPose.Feedback()\n            agent_feedback.distance_to_goal = feedback_msg.distance_to_goal\n            agent_feedback.progress_percentage = feedback_msg.progress_percentage\n            agent_feedback.status = feedback_msg.status\n            agent_feedback.current_pose = feedback_msg.current_pose\n\n            # Get the agent goal handle and publish feedback\n            agent_goal_handle = self.active_agent_goals[agent_goal_id]['goal_handle']\n            agent_goal_handle.publish_feedback(agent_feedback)\n\n    def agent_action_cancel_callback(self, goal_handle):\n        \"\"\"Handle cancel requests from AI agents.\"\"\"\n        goal_id = str(goal_handle.goal_id.uuid)\n\n        self.get_logger().info(f'Cancel request for agent goal {goal_id}')\n\n        # If we have a corresponding robot goal, cancel it too\n        if goal_id in self.active_agent_goals:\n            robot_goal_handle = self.active_agent_goals[goal_id].get('robot_goal_handle')\n            if robot_goal_handle:\n                cancel_future = robot_goal_handle.cancel_goal_async()\n                # We could add a callback here to handle the robot's cancel response\n\n        return CancelResponse.ACCEPT\n\n    def agent_action_navigate_execute(self, goal_handle):\n        \"\"\"Execute callback for agent navigation action.\"\"\"\n        # This is handled in the thread created by handle_accepted_callback\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    bridge = AgentActionBridge()\n\n    try:\n        rclpy.spin(bridge)\n    except KeyboardInterrupt:\n        bridge.get_logger().info('Agent action bridge interrupted')\n    finally:\n        bridge.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"advanced-action-bridge-with-priority-management",children:"Advanced Action Bridge with Priority Management"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionClient, ActionServer\nfrom rclpy.node import Node\nfrom your_robot_package.action import MoveToPose\nfrom std_msgs.msg import String\nfrom rclpy.executors import MultiThreadedExecutor\nimport time\nimport threading\nfrom typing import Dict, Any\nfrom enum import Enum\nfrom queue import PriorityQueue\n\nclass Priority(Enum):\n    LOW = 1\n    NORMAL = 2\n    HIGH = 3\n    EMERGENCY = 4\n\nclass AdvancedActionBridgeNode(Node):\n    \"\"\"\n    An advanced action bridge supporting multiple AI agents with priority-based\n    goal scheduling and sophisticated resource management.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_action_bridge')\n\n        # Declare advanced parameters\n        self.declare_parameter('max_concurrent_goals', 2)\n        self.declare_parameter('goal_queue_size', 10)\n        self.declare_parameter('enable_preemption', True)\n\n        # Get parameter values\n        self.max_concurrent_goals = self.get_parameter('max_concurrent_goals').value\n        self.goal_queue_size = self.get_parameter('goal_queue_size').value\n        self.enable_preemption = self.get_parameter('enable_preemption').value\n\n        # Create action client for robot\n        self.robot_client = ActionClient(self, MoveToPose, '/robot/move_to_pose')\n\n        # Create action server for agents\n        self.agent_server = ActionServer(\n            self,\n            MoveToPose,\n            '/multi_agent/navigate',\n            execute_callback=self.agent_execute_callback,\n            goal_callback=self.agent_goal_callback,\n            handle_accepted_callback=self.agent_handle_accepted,\n            cancel_callback=self.agent_cancel_callback\n        )\n\n        # Wait for robot server\n        self.get_logger().info('Waiting for robot action server...')\n        self.robot_client.wait_for_server()\n\n        # Priority queue for goals\n        self.goal_queue = PriorityQueue(maxsize=self.goal_queue_size)\n        self.active_goals = {}\n        self.goal_counter = 0\n\n        # Thread for processing goals\n        self.processing_thread = threading.Thread(target=self.process_goals, daemon=True)\n        self.processing_thread.start()\n\n        self.get_logger().info('Advanced Action Bridge initialized')\n\n    def agent_goal_callback(self, goal_request):\n        \"\"\"Handle goal requests with priority assignment.\"\"\"\n        # Extract priority from goal description or assign default\n        priority = Priority.NORMAL\n\n        if 'emergency' in goal_request.description.lower():\n            priority = Priority.EMERGENCY\n        elif 'high' in goal_request.description.lower():\n            priority = Priority.HIGH\n        elif 'low' in goal_request.description.lower():\n            priority = Priority.LOW\n\n        self.get_logger().info(\n            f'Received goal with priority {priority.name}: {goal_request.description}'\n        )\n\n        # Check if queue is full\n        if self.goal_queue.qsize() >= self.goal_queue_size:\n            self.get_logger().warn('Goal queue is full, rejecting goal')\n            return GoalResponse.REJECT\n\n        return GoalResponse.ACCEPT\n\n    def agent_handle_accepted(self, goal_handle):\n        \"\"\"Handle accepted goal with priority.\"\"\"\n        goal_id = str(goal_handle.goal_id.uuid)\n\n        # Determine priority based on goal description\n        description = goal_handle.request.description.lower()\n        if 'emergency' in description:\n            priority = Priority.EMERGENCY.value\n        elif 'high' in description:\n            priority = Priority.HIGH.value\n        elif 'low' in description:\n            priority = Priority.LOW.value\n        else:\n            priority = Priority.NORMAL.value\n\n        # Add to priority queue\n        queue_item = (\n            priority,  # Priority (lower number = higher priority)\n            time.time(),  # Timestamp for tie-breaking\n            goal_id,\n            goal_handle\n        )\n\n        try:\n            self.goal_queue.put_nowait(queue_item)\n            self.get_logger().info(f'Goal {goal_id} added to queue with priority {priority}')\n        except:\n            self.get_logger().error(f'Failed to add goal {goal_id} to queue')\n            goal_handle.abort()\n\n    def process_goals(self):\n        \"\"\"Process goals from the priority queue.\"\"\"\n        while rclpy.ok():\n            try:\n                # Get next goal from queue\n                priority, timestamp, goal_id, goal_handle = self.goal_queue.get(timeout=1.0)\n\n                # Check if we can start this goal (respect concurrent limit)\n                active_count = len([g for g in self.active_goals.values() if g['status'] == 'active'])\n\n                if active_count >= self.max_concurrent_goals:\n                    # Put it back in the queue and wait\n                    self.goal_queue.put((priority, timestamp, goal_id, goal_handle))\n                    time.sleep(0.1)\n                    continue\n\n                # Start processing the goal\n                self.active_goals[goal_id] = {\n                    'goal_handle': goal_handle,\n                    'status': 'active',\n                    'priority': priority,\n                    'start_time': time.time()\n                }\n\n                # Execute the goal in a separate thread\n                goal_thread = threading.Thread(\n                    target=self.execute_robot_goal,\n                    args=(goal_handle, goal_id)\n                )\n                goal_thread.start()\n\n            except Exception as e:\n                # Queue is empty (timeout) or other error\n                if str(e) != \"queue is empty\":\n                    self.get_logger().debug(f'Goal processing: {e}')\n                time.sleep(0.01)\n\n    def execute_robot_goal(self, agent_goal_handle, agent_goal_id):\n        \"\"\"Execute a goal on the robot.\"\"\"\n        try:\n            # Forward to robot\n            robot_request = MoveToPose.Goal()\n            robot_request.target_pose = agent_goal_handle.request.target_pose\n            robot_request.tolerance = agent_goal_handle.request.tolerance\n            robot_request.description = f'Agent bridge: {agent_goal_handle.request.description}'\n\n            # Send to robot with feedback\n            send_future = self.robot_client.send_goal_async(\n                robot_request,\n                feedback_callback=lambda fb: self.forward_feedback(fb, agent_goal_id)\n            )\n\n            # Wait for acceptance\n            rclpy.spin_until_future_complete(self, send_future, timeout_sec=5.0)\n\n            if send_future.done():\n                robot_goal_handle = send_future.result()\n                if robot_goal_handle and robot_goal_handle.accepted:\n                    # Wait for result\n                    result_future = robot_goal_handle.get_result_async()\n                    rclpy.spin_until_future_complete(self, result_future, timeout_sec=120.0)\n\n                    if result_future.done():\n                        result_msg = result_future.result()\n\n                        # Complete the agent goal based on robot result\n                        if result_msg.status == 2:  # SUCCEEDED\n                            agent_goal_handle.succeed()\n                        elif result_msg.status == 5:  # CANCELED\n                            agent_goal_handle.canceled()\n                        else:\n                            agent_goal_handle.abort()\n\n                    else:\n                        agent_goal_handle.abort()\n                else:\n                    agent_goal_handle.abort()\n            else:\n                agent_goal_handle.abort()\n\n        except Exception as e:\n            self.get_logger().error(f'Error executing goal {agent_goal_id}: {e}')\n            agent_goal_handle.abort()\n\n        finally:\n            # Mark as complete in our tracking\n            if agent_goal_id in self.active_goals:\n                self.active_goals[agent_goal_id]['status'] = 'completed'\n                # Clean up after a delay\n                time.sleep(1)\n                if agent_goal_id in self.active_goals:\n                    del self.active_goals[agent_goal_id]\n\n    def forward_feedback(self, robot_feedback, agent_goal_id):\n        \"\"\"Forward robot feedback to the agent.\"\"\"\n        if agent_goal_id in self.active_goals:\n            agent_goal_handle = self.active_goals[agent_goal_id]['goal_handle']\n\n            # Forward feedback to agent\n            agent_feedback = MoveToPose.Feedback()\n            agent_feedback.distance_to_goal = robot_feedback.distance_to_goal\n            agent_feedback.progress_percentage = robot_feedback.progress_percentage\n            agent_feedback.status = robot_feedback.status\n            agent_feedback.current_pose = robot_feedback.current_pose\n\n            agent_goal_handle.publish_feedback(agent_feedback)\n\n    def agent_execute_callback(self, goal_handle):\n        \"\"\"Execute callback (handled by processing thread).\"\"\"\n        pass\n\n    def agent_cancel_callback(self, goal_handle):\n        \"\"\"Handle cancel requests.\"\"\"\n        goal_id = str(goal_handle.goal_id.uuid)\n        self.get_logger().info(f'Cancel request for goal {goal_id}')\n\n        # In a real system, you'd need to implement cancellation logic\n        # This is complex because goals are processed in separate threads\n\n        return CancelResponse.ACCEPT\n\ndef main(args=None):\n    rclpy.init(args=args)\n    advanced_bridge = AdvancedActionBridgeNode()\n\n    try:\n        executor = MultiThreadedExecutor()\n        executor.add_node(advanced_bridge)\n        executor.spin()\n    except KeyboardInterrupt:\n        advanced_bridge.get_logger().info('Advanced action bridge interrupted')\n    finally:\n        advanced_bridge.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"action-bridge-benefits",children:"Action Bridge Benefits"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Long-Running Operations"}),": Perfect for tasks that take significant time to complete"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Progress Monitoring"}),": AI agents can monitor operation progress in real-time"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cancellation Support"}),": Operations can be interrupted when necessary"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Feedback Integration"}),": Continuous feedback during execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Priority Management"}),": Can implement sophisticated scheduling algorithms"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Resource Management"}),": Better control over robot resources during operations"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(n.p,{children:["In this section, we've explored actions in ROS 2 using ",(0,o.jsx)(n.code,{children:"rclpy"}),". You've learned:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action server creation"})," and implementation with proper goal management"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action client implementation"})," with goal submission and feedback handling"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Custom action types"})," for specialized long-running operations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action communication patterns"})," for complex robot tasks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Python agent bridge patterns"})," for connecting AI algorithms to robot controllers using actions"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Actions provide a sophisticated communication mechanism that bridges the gap between simple services and continuous topic publishing, enabling complex operations with feedback, progress tracking, and cancellation capabilities that are essential for advanced robotic applications."}),"\n",(0,o.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Custom Action Creation"}),": Define and implement a custom action for robot arm manipulation that includes path planning, execution, and detailed feedback."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Action Client with State Machine"}),": Create an action client that implements a state machine to manage complex multi-step operations."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Priority-Based Action Bridge"}),": Implement an action bridge that supports multiple AI agents with different priority levels for robot resources."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Action Composition"}),": Create an action that coordinates multiple other actions to perform complex behaviors (e.g., navigate to location, then perform manipulation)."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Action Monitoring System"}),": Implement a system that monitors and logs all action executions in a robotic system."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Safety-Enhanced Action"}),": Create an action server that includes safety checks and automatic cancellation based on sensor data."]}),"\n"]}),"\n"]})]})}function _(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(g,{...e})}):g(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>i});var t=a(6540);const o={},l=t.createContext(o);function r(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);