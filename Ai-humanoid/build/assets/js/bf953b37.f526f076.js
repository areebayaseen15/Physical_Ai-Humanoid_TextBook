"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[7220],{3033:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Module1-ROS/Chapter1-Introduction-to-ROS2/index","title":"Introduction to ROS 2 for Physical AI","description":"1.1 The Dawn of Physical AI and Robotics","source":"@site/docs/Module1-ROS/Chapter1-Introduction-to-ROS2/index.md.md","sourceDirName":"Module1-ROS/Chapter1-Introduction-to-ROS2","slug":"/Module1-ROS/Chapter1-Introduction-to-ROS2/index","permalink":"/docs/Module1-ROS/Chapter1-Introduction-to-ROS2/index","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module1-ROS/Chapter1-Introduction-to-ROS2/index.md.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"index","title":"Introduction to ROS 2 for Physical AI","sidebar_label":"Chapter 1:Introduction to ROS 2","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Introduction to Ros2","permalink":"/docs/category/chapter-1-introduction-to-ros2"},"next":{"title":"Chapter 2:Nodes,TopicsService,Action","permalink":"/docs/category/chapter-2nodestopicsserviceaction"}}');var r=s(4848),o=s(8453);const t={id:"index",title:"Introduction to ROS 2 for Physical AI",sidebar_label:"Chapter 1:Introduction to ROS 2",sidebar_position:1},a="Chapter 1: Introduction to ROS 2 for Physical AI",c={},l=[{value:"1.1 The Dawn of Physical AI and Robotics",id:"11-the-dawn-of-physical-ai-and-robotics",level:3},{value:"1.2 Why ROS 2? A Framework for Robotic Intelligence",id:"12-why-ros-2-a-framework-for-robotic-intelligence",level:3},{value:"1.3 ROS 2 Core Concepts: An Overview",id:"13-ros-2-core-concepts-an-overview",level:3},{value:"Nodes",id:"nodes",level:4},{value:"Communication Patterns",id:"communication-patterns",level:4},{value:"<code>rclpy</code>: Python Client Library",id:"rclpy-python-client-library",level:4},{value:"1.4 Setting Up Your ROS 2 Humble Environment",id:"14-setting-up-your-ros-2-humble-environment",level:3},{value:"1.4.1 ROS 2 Humble Installation",id:"141-ros-2-humble-installation",level:4},{value:"1.4.2 <code>colcon</code> Workspace Management",id:"142-colcon-workspace-management",level:4},{value:"1.4.3 Basic ROS 2 CLI Commands",id:"143-basic-ros-2-cli-commands",level:4},{value:"Recommended Python Exercises / Examples",id:"recommended-python-exercises--examples",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-1-introduction-to-ros-2-for-physical-ai",children:"Chapter 1: Introduction to ROS 2 for Physical AI"})}),"\n",(0,r.jsx)(n.h2,{id:""}),"\n",(0,r.jsx)(n.h3,{id:"11-the-dawn-of-physical-ai-and-robotics",children:"1.1 The Dawn of Physical AI and Robotics"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Learning Objectives:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand the current landscape and trajectory of physical AI and robotics."}),"\n",(0,r.jsx)(n.li,{children:"Appreciate the increasing complexity inherent in modern robotic systems."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The convergence of artificial intelligence (AI) with physical systems has ushered in a new era of robotics, moving beyond pre-programmed automation to intelligent, adaptive machines capable of interacting with and learning from complex environments. This paradigm shift, often termed ",(0,r.jsx)(n.strong,{children:"Physical AI"})," or embodied AI, is particularly evident in ",(0,r.jsx)(n.strong,{children:"humanoid robotics"}),", where machines are designed to mimic human form and function, enabling them to operate in human-centric spaces and perform intricate tasks."]}),"\n",(0,r.jsx)(n.p,{children:"Building these intelligent physical systems presents significant challenges. Modern robots are not isolated entities; they are intricate networks of sensors, actuators, computational units, and communication interfaces. Managing the flow of data from high-fidelity cameras, LiDARs, IMUs, and other sensors, coupled with precise control signals to numerous motors, requires a robust, flexible, and scalable software framework. As robotic capabilities expand from industrial arms to autonomous mobile platforms and bipedal humanoids, the software complexity grows exponentially. This necessitates a middleware that can abstract hardware, facilitate inter-process communication, ensure real-time performance, and provide a modular architecture for developing sophisticated AI algorithms."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Terms for RAG:"})," Physical AI, Humanoid Robotics, Robotic Systems Complexity, AI-Robot Convergence, Intelligent Physical Systems."]}),"\n",(0,r.jsx)(n.h2,{id:"-1"}),"\n",(0,r.jsx)(n.h3,{id:"12-why-ros-2-a-framework-for-robotic-intelligence",children:"1.2 Why ROS 2? A Framework for Robotic Intelligence"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Learning Objectives:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Identify the fundamental architectural and operational challenges that ROS 2 is designed to solve in complex robotics applications."}),"\n",(0,r.jsx)(n.li,{children:"Articulate the key architectural improvements and advantages of ROS 2 over its predecessor, ROS 1."}),"\n",(0,r.jsx)(n.li,{children:"Justify the selection of ROS 2 as a foundational framework for developing advanced physical AI and humanoid robotics systems."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Robot Operating System (ROS)"})," has been the de facto standard for robotics software development for over a decade. However, as robotics evolved towards more advanced applications involving real-time constraints, multi-robot systems, and stringent security requirements, the original ROS (now referred to as ",(0,r.jsx)(n.strong,{children:"ROS 1"}),") began to show its limitations. Enter ",(0,r.jsx)(n.strong,{children:"ROS 2 (Robot Operating System 2)"}),", a complete re-architecture designed to address these modern demands, making it an indispensable framework for ",(0,r.jsx)(n.strong,{children:"physical AI"})," and ",(0,r.jsx)(n.strong,{children:"humanoid robotics"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 fundamentally addresses challenges such as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real-time Performance:"})," Critical for dynamic control and safety in physical robots, ROS 2 offers improved deterministic behavior."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distributed Architecture:"})," Built upon the ",(0,r.jsx)(n.strong,{children:"Data Distribution Service (DDS)"})," standard, ROS 2 enables truly distributed systems without a central master node, enhancing scalability and fault tolerance for complex, multi-component robots or robot fleets."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security:"})," Out-of-the-box security features, including authentication, authorization, and encryption, are vital for robots operating in public or sensitive environments."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability:"})," Designed for seamless deployment across various platforms, from embedded systems to cloud computing, supporting the diverse computational needs of AI-driven robots."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-robot Systems:"})," Native support for multiple robots operating concurrently, each with its own ROS 2 graph."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Unlike ROS 1's master-centric design, which could become a single point of failure and bottleneck, ROS 2 leverages DDS for direct, peer-to-peer communication between nodes. This paradigm shift greatly improves robustness, latency, and throughput, crucial for the high data rates and low-latency control loops characteristic of advanced AI robotics."}),"\n",(0,r.jsx)(n.p,{children:"For humanoid robots, where precise, real-time control of numerous degrees of freedom, integration of advanced perception (e.g., vision, force sensing), and complex decision-making are paramount, ROS 2 provides the necessary infrastructure. Its robust communication patterns and extensible nature allow developers to build sophisticated AI algorithms on top of a reliable robotic middleware."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Terms for RAG:"})," ROS 2, DDS (Data Distribution Service), Distributed Architecture, Real-time Robotics, ROS 2 Security, Scalability in Robotics, ROS 1 vs ROS 2, Robotic Frameworks."]}),"\n",(0,r.jsx)(n.h2,{id:"-2"}),"\n",(0,r.jsx)(n.h3,{id:"13-ros-2-core-concepts-an-overview",children:"1.3 ROS 2 Core Concepts: An Overview"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Learning Objectives:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Define a ROS 2 ",(0,r.jsx)(n.code,{children:"node"})," and its role as an atomic computational unit."]}),"\n",(0,r.jsxs)(n.li,{children:["Describe the fundamental communication patterns: ",(0,r.jsx)(n.code,{children:"topics"})," (publish/subscribe), ",(0,r.jsx)(n.code,{children:"services"})," (request/response), and ",(0,r.jsx)(n.code,{children:"actions"})," (long-running tasks)."]}),"\n",(0,r.jsxs)(n.li,{children:["Introduce ",(0,r.jsx)(n.code,{children:"rclpy"})," as the standard Python client library for ROS 2, emphasizing its importance for AI-driven robotics."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"At the heart of any ROS 2 system are its core communication concepts, which enable disparate software components to interact seamlessly. These primitives facilitate the modular design crucial for complex robotic architectures."}),"\n",(0,r.jsx)(n.h4,{id:"nodes",children:"Nodes"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsxs)(n.strong,{children:["ROS 2 ",(0,r.jsx)(n.code,{children:"node"})]})," is an executable process that performs computations. It's the fundamental unit of computation in ROS 2. For instance, a robot's camera driver might run as one node, an image processing algorithm as another, and a motor controller as a third. Each node is designed to be atomic and responsible for a single logical task, promoting modularity and reusability. Nodes communicate with each other using the mechanisms described below."]}),"\n",(0,r.jsx)(n.h4,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 offers several paradigms for inter-node communication:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Topics (Publish/Subscribe):"})," This is a many-to-many, asynchronous communication method. A node can ",(0,r.jsx)(n.strong,{children:"publish"})," messages to a named topic, and any number of other nodes can ",(0,r.jsx)(n.strong,{children:"subscribe"})," to that topic to receive those messages. This is ideal for continuous data streams like sensor readings (e.g., LiDAR scans, IMU data) or actuator commands."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Services (Request/Response):"})," Services provide a one-to-one, synchronous communication mechanism. A ",(0,r.jsx)(n.strong,{children:"service client"})," sends a request to a ",(0,r.jsx)(n.strong,{children:"service server"}),', which processes the request and sends back a single response. This is suitable for requests that expect an immediate result, such as triggering a specific action (e.g., "turn on lights") or querying data (e.g., "get current robot pose").']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Actions (Goal/Feedback/Result):"})," Actions are designed for long-running, goal-oriented tasks that may provide periodic feedback and a final result. An ",(0,r.jsx)(n.strong,{children:"action client"})," sends a goal to an ",(0,r.jsx)(n.strong,{children:"action server"}),', which processes the goal, provides continuous feedback on its progress, and ultimately returns a result. This is perfect for tasks like "navigate to a waypoint" or "perform a complex manipulation sequence," where monitoring progress is important.']}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"rclpy-python-client-library",children:[(0,r.jsx)(n.code,{children:"rclpy"}),": Python Client Library"]}),"\n",(0,r.jsxs)(n.p,{children:["For Python developers, ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"rclpy"})})," is the official client library for interacting with ROS 2. It provides Python bindings for the core ROS 2 C++ API (",(0,r.jsx)(n.code,{children:"rcl"}),") and allows for the easy creation of ROS 2 nodes, publishers, subscribers, service servers, service clients, and action interfaces. ",(0,r.jsx)(n.code,{children:"rclpy"})," is particularly important in AI-driven robotics due to Python's extensive ecosystem for machine learning, data analysis, and rapid prototyping. It enables seamless integration of AI algorithms into the ROS 2 framework."]}),"\n",(0,r.jsxs)(n.p,{children:["Here's a minimal example demonstrating node initialization and a simple timer callback using ",(0,r.jsx)(n.code,{children:"rclpy"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Minimal ROS 2 Python Node\r\nimport rclpy\r\nfrom rclpy.node import Node\r\n\r\nclass MinimalNode(Node):\r\n    def __init__(self):\r\n        super().__init__('minimal_node')\r\n        self.get_logger().info('Minimal Node started.') # Log info message\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args) # Initialize rclpy\r\n    minimal_node = MinimalNode()\r\n    rclpy.spin(minimal_node) # Keep node alive until shutdown\r\n    minimal_node.destroy_node() # Clean up node resources\r\n    rclpy.shutdown() # Shut down rclpy\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This ",(0,r.jsx)(n.code,{children:"MinimalNode"})," demonstrates the basic lifecycle of a ROS 2 Python node. The ",(0,r.jsx)(n.code,{children:"super().__init__('minimal_node')"})," call registers the node with the ROS 2 graph under the name 'minimal_node'. The ",(0,r.jsx)(n.code,{children:"rclpy.spin()"})," function keeps the node running, allowing it to process events like incoming messages or timer callbacks."]}),"\n",(0,r.jsx)(n.p,{children:"A slightly more complex example with a periodic activity:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Simple ROS 2 Python Node with Timer\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nimport time\r\n\r\nclass SimpleTimerNode(Node):\r\n    def __init__(self):\r\n        super().__init__('simple_timer_node')\r\n        # Create a timer that calls timer_callback every 1.0 seconds\r\n        self.timer = self.create_timer(1.0, self.timer_callback)\r\n        self.get_logger().info('Simple Timer Node started.')\r\n\r\n    def timer_callback(self):\r\n        # This function will be called periodically by the timer\r\n        self.get_logger().info(f'Timer event triggered at {time.time()}!')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    simple_timer_node = SimpleTimerNode()\r\n    rclpy.spin(simple_timer_node)\r\n    simple_timer_node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This ",(0,r.jsx)(n.code,{children:"SimpleTimerNode"})," creates a timer that triggers ",(0,r.jsx)(n.code,{children:"timer_callback"})," every second, printing a message. This illustrates how nodes can perform background tasks."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Terms for RAG:"})," ROS 2 Nodes, Topics (Publisher, Subscriber), Services (Server, Client), Actions (Action Server, Action Client), ",(0,r.jsx)(n.code,{children:"rclpy"}),", Inter-node Communication, Message Types, ",(0,r.jsx)(n.code,{children:"rclpy.init()"}),", ",(0,r.jsx)(n.code,{children:"rclpy.spin()"}),", ",(0,r.jsx)(n.code,{children:"Node.get_logger()"}),", ",(0,r.jsx)(n.code,{children:"Node.create_timer()"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cross-Reference:"})," The detailed implementation and hands-on usage of nodes, topics, services, and actions will be the primary focus of [Chapter 2: Nodes, Topics, Services, and Actions]. Advanced development of Python-based ROS 2 agents using ",(0,r.jsx)(n.code,{children:"rclpy"})," will be covered in depth in [Chapter 3: Python Agents with rclpy]."]}),"\n",(0,r.jsx)(n.h2,{id:"-3"}),"\n",(0,r.jsx)(n.h3,{id:"14-setting-up-your-ros-2-humble-environment",children:"1.4 Setting Up Your ROS 2 Humble Environment"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Learning Objectives:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Successfully install and configure a ROS 2 Humble development environment on a Linux-based system (e.g., Ubuntu)."}),"\n",(0,r.jsxs)(n.li,{children:["Understand the purpose and workflow of ",(0,r.jsx)(n.code,{children:"colcon"})," for building, testing, and installing ROS 2 packages within a workspace."]}),"\n",(0,r.jsx)(n.li,{children:"Execute fundamental ROS 2 command-line interface (CLI) tools to inspect and manage a running ROS 2 system."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["To begin developing with ",(0,r.jsx)(n.strong,{children:"ROS 2 (Robot Operating System 2)"}),", setting up a functional environment is the crucial first step. This section guides you through the installation of ",(0,r.jsx)(n.strong,{children:"ROS 2 Humble"}),", the long-term supported (LTS) release, on an Ubuntu Linux system, and introduces the ",(0,r.jsx)(n.code,{children:"colcon"})," build system and essential command-line tools."]}),"\n",(0,r.jsx)(n.h4,{id:"141-ros-2-humble-installation",children:"1.4.1 ROS 2 Humble Installation"}),"\n",(0,r.jsx)(n.p,{children:"The following commands will prepare your Ubuntu system and install the ROS 2 Humble Desktop environment. It is highly recommended to follow these steps carefully."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Set locale to ensure ROS 2 compatibility\r\nsudo apt update && sudo apt install locales\r\nsudo locale-gen en_US en_US.UTF-8\r\nsudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\r\nexport LANG=en_US.UTF-8\r\n\r\n# Add the ROS 2 apt repository to your system sources\r\nsudo apt install software-properties-common -y\r\nsudo add-apt-repository universe -y\r\nsudo apt update && sudo apt install curl -y\r\nsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\r\necho "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null\r\n\r\n# Install ROS 2 Humble Desktop, which includes essential tools and simulation packages\r\nsudo apt update\r\nsudo apt upgrade -y # Ensure all existing packages are up to date\r\nsudo apt install ros-humble-desktop -y\r\n\r\n# Source the ROS 2 setup file to make ROS 2 commands available in your current shell\r\n# For persistence across new terminal sessions, add this line to your ~/.bashrc file\r\nsource /opt/ros/humble/setup.bash\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"142-colcon-workspace-management",children:["1.4.2 ",(0,r.jsx)(n.code,{children:"colcon"})," Workspace Management"]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"ROS 2 workspace"})," is a directory where you develop, build, and install your ROS 2 packages. ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"colcon"})})," is the command-line tool used for building sets of packages, replacing ",(0,r.jsx)(n.code,{children:"catkin"})," from ROS 1."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Create a new workspace directory and its source directory\r\nmkdir -p ~/ros2_ws/src\r\ncd ~/ros2_ws\r\n\r\n# Create a minimal Python package named 'my_robot_controller'\r\n# '--build-type ament_python' specifies it's a Python package\r\nros2 pkg create --build-type ament_python my_robot_controller\r\n\r\n# Navigate to the workspace root and build all packages\r\n# 'colcon build' compiles C++ packages, processes Python packages, etc.\r\ncd ~/ros2_ws\r\ncolcon build\r\n\r\n# Source the workspace's setup file. This makes your newly built packages\r\n# available to ROS 2. This must be done AFTER sourcing the main ROS 2 setup.bash.\r\nsource install/setup.bash\n"})}),"\n",(0,r.jsx)(n.h4,{id:"143-basic-ros-2-cli-commands",children:"1.4.3 Basic ROS 2 CLI Commands"}),"\n",(0,r.jsxs)(n.p,{children:["Once your environment is set up and sourced, you can use the ",(0,r.jsx)(n.code,{children:"ros2"})," command-line interface (CLI) tools to interact with your ROS 2 system."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# List all currently active ROS 2 nodes\r\nros2 node list\r\n\r\n# List all currently active ROS 2 topics\r\nros2 topic list\r\n\r\n# Run a sample ROS 2 demo node (a publisher)\r\n# This will start publishing messages on a topic\r\nros2 run demo_nodes_py talker\r\n\r\n# In a NEW terminal (remember to source setup.bash in the new terminal!),\r\n# run a corresponding listener node to receive messages\r\nros2 run demo_nodes_py listener\n"})}),"\n",(0,r.jsx)(n.p,{children:"These basic commands are your gateway to inspecting and verifying the operation of your ROS 2 applications."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Terms for RAG:"})," ROS 2 Humble, ",(0,r.jsx)(n.code,{children:"colcon"}),", ROS 2 Workspace, Environment Setup, ",(0,r.jsx)(n.code,{children:"ros2 run"}),", ",(0,r.jsx)(n.code,{children:"ros2 node list"}),", ",(0,r.jsx)(n.code,{children:"ros2 topic list"}),", ",(0,r.jsx)(n.code,{children:"ament_python"}),", Ubuntu ROS 2 Installation."]}),"\n",(0,r.jsx)(n.h2,{id:"recommended-python-exercises--examples",children:"Recommended Python Exercises / Examples"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exercise 1.1: Hello ROS 2 Node (Python/rclpy):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task:"})," Create a standalone Python script that initializes an ",(0,r.jsx)(n.code,{children:"rclpy"}),' node, logs "Hello ROS 2!" using ',(0,r.jsx)(n.code,{children:"self.get_logger().info()"}),", and then gracefully shuts down."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution:"})," Execute this script directly using ",(0,r.jsx)(n.code,{children:"python3 <script_name>.py"}),". Subsequently, modify your ",(0,r.jsx)(n.code,{children:"my_robot_controller"})," package (",(0,r.jsx)(n.code,{children:"~/ros2_ws/src/my_robot_controller/setup.py"})," and add an executable entry point) to run this node using ",(0,r.jsx)(n.code,{children:"ros2 run my_robot_controller hello_node"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Learning:"})," Understand the basic ",(0,r.jsx)(n.code,{children:"rclpy"})," node lifecycle and two methods of launching nodes."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exercise 1.2: ROS 2 Environment Verification (Bash):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task:"})," Develop a Bash script (",(0,r.jsx)(n.code,{children:"check_ros_env.sh"}),") that performs the following checks:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Verify that ",(0,r.jsx)(n.code,{children:"ROS_DISTRO"})," environment variable is set to ",(0,r.jsx)(n.code,{children:"humble"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Confirm that ",(0,r.jsx)(n.code,{children:"/opt/ros/humble/setup.bash"})," (and your workspace ",(0,r.jsx)(n.code,{children:"install/setup.bash"})," if applicable) has been sourced."]}),"\n",(0,r.jsxs)(n.li,{children:["Attempt to run a simple ",(0,r.jsx)(n.code,{children:"ros2"})," command (e.g., ",(0,r.jsx)(n.code,{children:"ros2 help"}),") to confirm functionality."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Output:"})," The script should output clear pass/fail messages for each check."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Learning:"})," Reinforce understanding of ROS 2 environment variables and setup."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exercise 1.3: Node Naming and Inspection (Python/Bash):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task:"})," Create two separate Python scripts. Each script should define a simple ",(0,r.jsx)(n.code,{children:"rclpy"})," node with a unique name (e.g., ",(0,r.jsx)(n.code,{children:"my_first_node"}),", ",(0,r.jsx)(n.code,{children:"my_second_node"}),"). Run both nodes concurrently in different terminals (remembering to source your workspace in each)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inspection:"})," Use ",(0,r.jsx)(n.code,{children:"ros2 node list"})," in a third terminal to observe both running nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Learning:"})," Gain practical experience with node identification within the ROS 2 graph."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(6540);const r={},o=i.createContext(r);function t(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);