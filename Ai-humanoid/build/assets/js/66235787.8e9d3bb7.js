"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[1373],{511:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/building-simulation-environments","title":"building simulation environments","description":"Creating effective simulation environments is crucial for successful robotics development. In Isaac Sim, the process involves understanding Universal Scene Description (USD), managing assets effectively, creating realistic materials and textures, and configuring proper lighting and camera systems. This chapter will guide you through the complete process of building sophisticated simulation environments.","source":"@site/docs/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/building-simulation-environments.md","sourceDirName":"Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation","slug":"/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/building-simulation-environments","permalink":"/docs/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/building-simulation-environments","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/building-simulation-environments.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"id":"building-simulation-environments","title":"building simulation environments","sidebar_label":"building simulation environments","sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"advanced scene creation","permalink":"/docs/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/advanced-scene-creation"},"next":{"title":"introduction to isaac sim","permalink":"/docs/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/introduction-to-isaac-sim"}}');var s=i(4848),r=i(8453);const a={id:"building-simulation-environments",title:"building simulation environments",sidebar_label:"building simulation environments",sidebar_position:0},l="3.2.2 Building Simulation Environments",o={},c=[{value:"Introduction to USD (Universal Scene Description)",id:"introduction-to-usd-universal-scene-description",level:2},{value:"USD Core Concepts",id:"usd-core-concepts",level:3},{value:"USD File Structure",id:"usd-file-structure",level:3},{value:"USD in Isaac Sim Workflow",id:"usd-in-isaac-sim-workflow",level:3},{value:"Working with USD Programmatically",id:"working-with-usd-programmatically",level:3},{value:"Asset Import and Management",id:"asset-import-and-management",level:2},{value:"Supported Asset Formats",id:"supported-asset-formats",level:3},{value:"Asset Import Process",id:"asset-import-process",level:3},{value:"Asset Organization Strategy",id:"asset-organization-strategy",level:3},{value:"Asset Optimization Techniques",id:"asset-optimization-techniques",level:3},{value:"Material and Texture Creation",id:"material-and-texture-creation",level:2},{value:"PBR Material Properties",id:"pbr-material-properties",level:3},{value:"Creating Materials in Isaac Sim",id:"creating-materials-in-isaac-sim",level:3},{value:"Material Creation Example",id:"material-creation-example",level:3},{value:"Advanced Material Techniques",id:"advanced-material-techniques",level:3},{value:"Texture Map Guidelines",id:"texture-map-guidelines",level:3},{value:"Lighting and Camera Setup",id:"lighting-and-camera-setup",level:2},{value:"Lighting Types in Isaac Sim",id:"lighting-types-in-isaac-sim",level:3},{value:"Lighting Setup Best Practices",id:"lighting-setup-best-practices",level:3},{value:"Camera Configuration",id:"camera-configuration",level:3},{value:"Camera Placement and Configuration Example",id:"camera-placement-and-configuration-example",level:3},{value:"Environment Templates",id:"environment-templates",level:2},{value:"Warehouse Environment Template",id:"warehouse-environment-template",level:3},{value:"Office Environment Template",id:"office-environment-template",level:3},{value:"Home Environment Template",id:"home-environment-template",level:3},{value:"Creating Environment Templates",id:"creating-environment-templates",level:3},{value:"Best Practices for Environment Creation",id:"best-practices-for-environment-creation",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Realism Considerations",id:"realism-considerations",level:3},{value:"Collaboration and Version Control",id:"collaboration-and-version-control",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"322-building-simulation-environments",children:"3.2.2 Building Simulation Environments"})}),"\n",(0,s.jsx)(n.p,{children:"Creating effective simulation environments is crucial for successful robotics development. In Isaac Sim, the process involves understanding Universal Scene Description (USD), managing assets effectively, creating realistic materials and textures, and configuring proper lighting and camera systems. This chapter will guide you through the complete process of building sophisticated simulation environments."}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-usd-universal-scene-description",children:"Introduction to USD (Universal Scene Description)"}),"\n",(0,s.jsx)(n.p,{children:"Universal Scene Description (USD) is Pixar's open-source scene description and interchange format that serves as the backbone of Isaac Sim's scene architecture. USD provides a powerful and extensible foundation for creating, assembling, and reading 3D scenes."}),"\n",(0,s.jsx)(n.h3,{id:"usd-core-concepts",children:"USD Core Concepts"}),"\n",(0,s.jsx)(n.p,{children:"USD is built around several core concepts that enable complex scene composition:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Prims (Primitives)"}),": The fundamental building blocks of USD scenes. Each object in a scene is represented as a prim, which can contain properties, relationships, and other prims as children."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Schemas"}),": Predefined templates that define the structure and properties of specific types of prims. For example, ",(0,s.jsx)(n.code,{children:"Xform"})," schema defines transform properties (position, rotation, scale), while ",(0,s.jsx)(n.code,{children:"Mesh"})," schema defines geometric properties."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Layers"}),": USD scenes are composed of multiple layers that can be combined to create complex scenes. Each layer can contain prims, properties, and relationships."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Variants"}),": Mechanism for storing multiple versions of the same scene element within a single USD file, allowing for different configurations of the same basic structure."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Payloads"}),": Mechanism for referencing large assets without loading them into memory until needed, enabling efficient handling of complex scenes."]}),"\n",(0,s.jsx)(n.h3,{id:"usd-file-structure",children:"USD File Structure"}),"\n",(0,s.jsx)(n.p,{children:"A typical USD file structure includes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"warehouse.usda\n\u251c\u2500\u2500 /World\n\u2502   \u251c\u2500\u2500 /Robot\n\u2502   \u2502   \u251c\u2500\u2500 /Chassis (Xform schema)\n\u2502   \u2502   \u251c\u2500\u2500 /Wheel_FL (Xform schema)\n\u2502   \u2502   \u2514\u2500\u2500 /Wheel_FR (Xform schema)\n\u2502   \u251c\u2500\u2500 /Environment\n\u2502   \u2502   \u251c\u2500\u2500 /Floor (Xform + Mesh schema)\n\u2502   \u2502   \u2514\u2500\u2500 /Shelf_01 (Xform + Mesh schema)\n\u2502   \u2514\u2500\u2500 /Lighting\n\u2502       \u251c\u2500\u2500 /DistantLight (DistantLight schema)\n\u2502       \u2514\u2500\u2500 /DomeLight (DomeLight schema)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"usd-in-isaac-sim-workflow",children:"USD in Isaac Sim Workflow"}),"\n",(0,s.jsx)(n.p,{children:"In Isaac Sim, USD files are used to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define robot models and their kinematic structures"}),"\n",(0,s.jsx)(n.li,{children:"Create complex environments with multiple objects"}),"\n",(0,s.jsx)(n.li,{children:"Store material and texture information"}),"\n",(0,s.jsx)(n.li,{children:"Define sensor placements and configurations"}),"\n",(0,s.jsx)(n.li,{children:"Maintain scene hierarchies and relationships"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"working-with-usd-programmatically",children:"Working with USD Programmatically"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Example: Creating a simple USD scene programmatically\nfrom pxr import Usd, UsdGeom, Gf, Sdf\n\ndef create_simple_warehouse_stage(file_path):\n    """Create a simple warehouse stage using USD API"""\n\n    # Create a new stage\n    stage = Usd.Stage.CreateNew(file_path)\n\n    # Create world prim\n    world_prim = stage.DefinePrim("/World", "Xform")\n\n    # Create floor\n    floor_prim = stage.DefinePrim("/World/Floor", "Mesh")\n    floor_mesh = UsdGeom.Mesh(floor_prim)\n\n    # Set floor properties\n    floor_mesh.CreatePointsAttr([[-5, 0, -5], [5, 0, -5], [5, 0, 5], [-5, 0, 5]])\n    floor_mesh.CreateFaceVertexIndicesAttr([0, 1, 2, 3])\n    floor_mesh.CreateFaceVertexCountsAttr([4])\n\n    # Create a simple shelf\n    shelf_prim = stage.DefinePrim("/World/Shelf", "Xform")\n    shelf_xform = UsdGeom.Xform(shelf_prim)\n    shelf_xform.AddTranslateOp().Set((0, 0.5, 0))  # Position shelf\n\n    # Create shelf geometry\n    shelf_mesh_prim = stage.DefinePrim("/World/Shelf/Geometry", "Mesh")\n    shelf_mesh = UsdGeom.Mesh(shelf_mesh_prim)\n\n    # Set shelf properties (1x2x0.3m shelf)\n    shelf_points = [\n        [-0.5, 0, -1], [0.5, 0, -1], [0.5, 0, 1], [-0.5, 0, 1],  # Bottom\n        [-0.5, 2, -1], [0.5, 2, -1], [0.5, 2, 1], [-0.5, 2, 1],  # Top\n        [-0.5, 0, -1], [-0.5, 2, -1], [0.5, 2, -1], [0.5, 0, -1],  # Front\n        [0.5, 0, 1], [0.5, 2, 1], [-0.5, 2, 1], [-0.5, 0, 1],      # Back\n    ]\n    shelf_mesh.CreatePointsAttr(shelf_points)\n    shelf_mesh.CreateFaceVertexIndicesAttr([\n        0, 1, 2, 3,  # Bottom\n        4, 5, 6, 7,  # Top\n        8, 9, 10, 11, # Front\n        12, 13, 14, 15 # Back\n    ])\n    shelf_mesh.CreateFaceVertexCountsAttr([4, 4, 4, 4])\n\n    # Save the stage\n    stage.GetRootLayer().Save()\n\n    return stage\n\n# Usage\nstage = create_simple_warehouse_stage("./simple_warehouse.usd")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"asset-import-and-management",children:"Asset Import and Management"}),"\n",(0,s.jsx)(n.p,{children:"Effective asset management is crucial for creating complex and realistic simulation environments. Isaac Sim supports a wide variety of 3D asset formats and provides tools for organizing and optimizing assets."}),"\n",(0,s.jsx)(n.h3,{id:"supported-asset-formats",children:"Supported Asset Formats"}),"\n",(0,s.jsx)(n.p,{children:"Isaac Sim supports the following asset formats:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"USD (.usd, .usda, .usdc, .usdz)"}),": Native format, preferred for complex scenes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"FBX (.fbx)"}),": Industry standard for 3D models"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"OBJ (.obj)"}),": Simple geometry format"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GLTF/GLB (.gltf, .glb)"}),": Modern format with material support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Alembic (.abc)"}),": Animation and geometry cache format"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"asset-import-process",children:"Asset Import Process"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prepare Assets"}),": Ensure assets are properly scaled, have appropriate materials, and are optimized for real-time rendering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Import to Isaac Sim"}),": Use the import tools to bring assets into the scene"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configure Materials"}),": Adjust materials for photorealistic rendering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Set Physics Properties"}),": Configure collision shapes and physical properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimize for Performance"}),": Apply level of detail and optimization techniques"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"asset-organization-strategy",children:"Asset Organization Strategy"}),"\n",(0,s.jsx)(n.p,{children:"A well-organized asset library improves workflow efficiency:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Assets/\n\u251c\u2500\u2500 Robots/\n\u2502   \u251c\u2500\u2500 Humanoid/\n\u2502   \u2502   \u251c\u2500\u2500 Atlas/\n\u2502   \u2502   \u2514\u2500\u2500 Valkyrie/\n\u2502   \u2514\u2500\u2500 Wheeled/\n\u2502       \u251c\u2500\u2500 TurtleBot3/\n\u2502       \u2514\u2500\u2500 Jackal/\n\u251c\u2500\u2500 Environments/\n\u2502   \u251c\u2500\u2500 Indoor/\n\u2502   \u2502   \u251c\u2500\u2500 Warehouse/\n\u2502   \u2502   \u251c\u2500\u2500 Office/\n\u2502   \u2502   \u2514\u2500\u2500 Home/\n\u2502   \u2514\u2500\u2500 Outdoor/\n\u2502       \u251c\u2500\u2500 Urban/\n\u2502       \u2514\u2500\u2500 Natural/\n\u251c\u2500\u2500 Props/\n\u2502   \u251c\u2500\u2500 Industrial/\n\u2502   \u251c\u2500\u2500 Furniture/\n\u2502   \u2514\u2500\u2500 Obstacles/\n\u251c\u2500\u2500 Materials/\n\u2502   \u251c\u2500\u2500 Metals/\n\u2502   \u251c\u2500\u2500 Plastics/\n\u2502   \u2514\u2500\u2500 Fabrics/\n\u2514\u2500\u2500 Sensors/\n    \u251c\u2500\u2500 Cameras/\n    \u251c\u2500\u2500 LiDAR/\n    \u2514\u2500\u2500 IMU/\n"})}),"\n",(0,s.jsx)(n.h3,{id:"asset-optimization-techniques",children:"Asset Optimization Techniques"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Geometry Optimization"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduce polygon count for distant objects"}),"\n",(0,s.jsx)(n.li,{children:"Use normal maps to maintain visual detail with fewer polygons"}),"\n",(0,s.jsx)(n.li,{children:"Implement level of detail (LOD) systems"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Material Optimization"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use texture atlasing to reduce draw calls"}),"\n",(0,s.jsx)(n.li,{children:"Implement material instancing for similar objects"}),"\n",(0,s.jsx)(n.li,{children:"Use physically-based materials for consistency"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Memory Management"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stream assets based on camera proximity"}),"\n",(0,s.jsx)(n.li,{children:"Use texture streaming for large environments"}),"\n",(0,s.jsx)(n.li,{children:"Implement occlusion culling for hidden objects"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"material-and-texture-creation",children:"Material and Texture Creation"}),"\n",(0,s.jsx)(n.p,{children:"Creating realistic materials is essential for photorealistic simulation and effective synthetic data generation. Isaac Sim uses Physically-Based Rendering (PBR) materials that accurately simulate real-world light interactions."}),"\n",(0,s.jsx)(n.h3,{id:"pbr-material-properties",children:"PBR Material Properties"}),"\n",(0,s.jsx)(n.p,{children:"PBR materials are defined by several key properties:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Albedo/Diffuse"}),": The base color of the material, representing how much light is reflected at each wavelength\n",(0,s.jsx)(n.strong,{children:"Metallic"}),": Defines whether the surface behaves like a metal (0.0 = non-metal, 1.0 = metal)\n",(0,s.jsx)(n.strong,{children:"Roughness"}),": Controls the microsurface detail, affecting how light scatters\n",(0,s.jsx)(n.strong,{children:"Normal Map"}),": Simulates surface detail without adding geometric complexity\n",(0,s.jsx)(n.strong,{children:"Occlusion"}),": Simulates ambient light occlusion in crevices and corners\n",(0,s.jsx)(n.strong,{children:"Emission"}),": Defines areas that emit light"]}),"\n",(0,s.jsx)(n.h3,{id:"creating-materials-in-isaac-sim",children:"Creating Materials in Isaac Sim"}),"\n",(0,s.jsx)(n.p,{children:"Materials can be created using several approaches:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Using the Material Library"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Open the Material Library in Isaac Sim"}),"\n",(0,s.jsx)(n.li,{children:"Browse existing materials for reference"}),"\n",(0,s.jsx)(n.li,{children:"Duplicate and modify existing materials"}),"\n",(0,s.jsx)(n.li,{children:"Apply to objects in the scene"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Creating Custom Materials"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a new material using the Material Graph"}),"\n",(0,s.jsx)(n.li,{children:"Connect appropriate texture maps"}),"\n",(0,s.jsx)(n.li,{children:"Adjust PBR properties"}),"\n",(0,s.jsx)(n.li,{children:"Apply to objects"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"material-creation-example",children:"Material Creation Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Example: Creating a custom material programmatically\nfrom pxr import Usd, UsdShade, Sdf, Gf\n\ndef create_custom_material(stage, material_path, albedo_color=(0.8, 0.8, 0.8)):\n    """Create a custom material with specific properties"""\n\n    # Create material prim\n    material_prim = stage.DefinePrim(material_path, "Material")\n    material = UsdShade.Material(material_prim)\n\n    # Create shader\n    shader_path = material_path + "/Shader"\n    shader_prim = stage.DefinePrim(shader_path, "Shader")\n    shader = UsdShade.Shader(shader_prim)\n    shader.CreateIdAttr("UsdPreviewSurface")\n\n    # Set shader parameters\n    shader.CreateInput("diffuseColor", Sdf.ValueTypeNames.Color3f).Set(albedo_color)\n    shader.CreateInput("metallic", Sdf.ValueTypeNames.Float).Set(0.0)\n    shader.CreateInput("roughness", Sdf.ValueTypeNames.Float).Set(0.5)\n    shader.CreateInput("clearcoat", Sdf.ValueTypeNames.Float).Set(0.0)\n\n    # Connect shader to material surface output\n    material.CreateSurfaceOutput().ConnectToSource(shader.ConnectableAPI(), "surface")\n\n    return material\n\n# Usage example\nstage = Usd.Stage.CreateNew("./material_example.usd")\ncustom_material = create_custom_material(stage, "/World/Looks/CustomMaterial", (0.2, 0.6, 0.8))\nstage.GetRootLayer().Save()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-material-techniques",children:"Advanced Material Techniques"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Subsurface Scattering"}),": For materials like skin, wax, or marble where light penetrates the surface\n",(0,s.jsx)(n.strong,{children:"Anisotropic Reflection"}),": For materials with directional surface patterns like brushed metal\n",(0,s.jsx)(n.strong,{children:"Clearcoat"}),": For materials with a thin transparent coating like car paint\n",(0,s.jsx)(n.strong,{children:"Sheen"}),": For fabric materials that exhibit a soft, fabric-like reflection"]}),"\n",(0,s.jsx)(n.h3,{id:"texture-map-guidelines",children:"Texture Map Guidelines"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Resolution"}),": Use appropriate texture resolution based on object size and viewing distance\n",(0,s.jsx)(n.strong,{children:"Color Space"}),": Ensure textures are in the correct color space (sRGB for albedo, linear for roughness/metallic)\n",(0,s.jsx)(n.strong,{children:"Tiling"}),": Create seamless textures for large surfaces\n",(0,s.jsx)(n.strong,{children:"Compression"}),": Balance quality with memory usage"]}),"\n",(0,s.jsx)(n.h2,{id:"lighting-and-camera-setup",children:"Lighting and Camera Setup"}),"\n",(0,s.jsx)(n.p,{children:"Proper lighting and camera configuration are essential for creating realistic simulations and generating high-quality synthetic data."}),"\n",(0,s.jsx)(n.h3,{id:"lighting-types-in-isaac-sim",children:"Lighting Types in Isaac Sim"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Distant Light"}),": Simulates sunlight or other distant light sources"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Directional light with parallel rays"}),"\n",(0,s.jsx)(n.li,{children:"No position, only direction and intensity"}),"\n",(0,s.jsx)(n.li,{children:"Ideal for outdoor scenes"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Dome Light"}),": Simulates environment lighting"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"360-degree lighting from all directions"}),"\n",(0,s.jsx)(n.li,{children:"Can use HDR environment maps"}),"\n",(0,s.jsx)(n.li,{children:"Creates realistic global illumination"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sphere Light"}),": Point light source"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Omnidirectional light emission"}),"\n",(0,s.jsx)(n.li,{children:"Position-based with falloff"}),"\n",(0,s.jsx)(n.li,{children:"Good for localized lighting"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Disk Light"}),": Area light source"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Light emitted from a circular area"}),"\n",(0,s.jsx)(n.li,{children:"Creates soft shadows"}),"\n",(0,s.jsx)(n.li,{children:"Useful for realistic lighting"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"lighting-setup-best-practices",children:"Lighting Setup Best Practices"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Three-Point Lighting"}),": Classic lighting setup with key, fill, and back lights\n",(0,s.jsx)(n.strong,{children:"HDR Environment Maps"}),": Use high dynamic range images for realistic environment lighting\n",(0,s.jsx)(n.strong,{children:"Color Temperature"}),": Match lighting color temperature to scene requirements\n",(0,s.jsx)(n.strong,{children:"Intensity Balancing"}),": Balance different light sources to avoid overexposure"]}),"\n",(0,s.jsx)(n.h3,{id:"camera-configuration",children:"Camera Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Isaac Sim supports various camera types for different simulation needs:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"RGB Camera"}),": Standard color camera with configurable parameters"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Resolution, field of view, focal length"}),"\n",(0,s.jsx)(n.li,{children:"Exposure settings and noise models"}),"\n",(0,s.jsx)(n.li,{children:"Distortion parameters"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Depth Camera"}),": Generates depth information"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Depth range and accuracy"}),"\n",(0,s.jsx)(n.li,{children:"Noise characteristics"}),"\n",(0,s.jsx)(n.li,{children:"Alignment with RGB camera"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Stereo Camera"}),": Two cameras for depth perception"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Baseline distance between cameras"}),"\n",(0,s.jsx)(n.li,{children:"Synchronization settings"}),"\n",(0,s.jsx)(n.li,{children:"Disparity computation"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"camera-placement-and-configuration-example",children:"Camera Placement and Configuration Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Example: Setting up a camera system programmatically\nfrom pxr import Usd, UsdGeom, Gf\n\ndef setup_robot_camera_system(stage, robot_path):\n    """Set up a camera system on a robot"""\n\n    # Create camera parent prim\n    camera_parent_path = f"{robot_path}/CameraMount"\n    camera_parent = stage.DefinePrim(camera_parent_path, "Xform")\n\n    # Position camera mount\n    camera_xform = UsdGeom.Xform(camera_parent)\n    camera_xform.AddTranslateOp().Set((0.1, 0.5, 0.0))  # Position relative to robot\n\n    # Create RGB camera\n    rgb_camera_path = f"{camera_parent_path}/RGBCamera"\n    rgb_camera = UsdGeom.Camera(stage.DefinePrim(rgb_camera_path, "Camera"))\n\n    # Configure RGB camera properties\n    rgb_camera.GetFocalLengthAttr().Set(24.0)  # mm\n    rgb_camera.GetHorizontalApertureAttr().Set(36.0)  # mm\n    rgb_camera.GetVerticalApertureAttr().Set(20.25)  # mm\n    rgb_camera.GetClippingRangeAttr().Set((0.1, 1000.0))  # meters\n\n    # Create depth camera\n    depth_camera_path = f"{camera_parent_path}/DepthCamera"\n    depth_camera = UsdGeom.Camera(stage.DefinePrim(depth_camera_path, "Camera"))\n\n    # Configure depth camera properties\n    depth_camera.GetFocalLengthAttr().Set(24.0)\n    depth_camera.GetHorizontalApertureAttr().Set(36.0)\n    depth_camera.GetVerticalApertureAttr().Set(20.25)\n    depth_camera.GetClippingRangeAttr().Set((0.1, 10.0))\n\n    # Synchronize both cameras\n    rgb_camera.GetPurposeAttr().Set("render")\n    depth_camera.GetPurposeAttr().Set("render")\n\n# Usage example\nstage = Usd.Stage.CreateNew("./camera_setup.usd")\nsetup_robot_camera_system(stage, "/World/Robot")\nstage.GetRootLayer().Save()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"environment-templates",children:"Environment Templates"}),"\n",(0,s.jsx)(n.p,{children:"Creating template environments accelerates the development process and ensures consistency across different simulation scenarios."}),"\n",(0,s.jsx)(n.h3,{id:"warehouse-environment-template",children:"Warehouse Environment Template"}),"\n",(0,s.jsx)(n.p,{children:"A typical warehouse environment includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Structural Elements"}),": Floors, walls, ceiling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Storage Systems"}),": Shelves, racks, containers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Navigation Paths"}),": Aisles, corridors, loading areas"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lighting"}),": Overhead lighting, emergency lighting"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety Elements"}),": Fire exits, safety equipment"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"office-environment-template",children:"Office Environment Template"}),"\n",(0,s.jsx)(n.p,{children:"An office environment template includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Furniture"}),": Desks, chairs, filing cabinets"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Partitions"}),": Walls, cubicles, doors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Electronics"}),": Computers, printers, phones"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Decorative Elements"}),": Plants, artwork, blinds"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lighting"}),": Desk lamps, ceiling lights, windows"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"home-environment-template",children:"Home Environment Template"}),"\n",(0,s.jsx)(n.p,{children:"A home environment template includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rooms"}),": Kitchen, living room, bedroom, bathroom"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Furniture"}),": Sofas, tables, beds, appliances"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fixtures"}),": Lighting, windows, doors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Personal Items"}),": Books, decorations, clothing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Kitchen Elements"}),": Appliances, utensils, food items"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"creating-environment-templates",children:"Creating Environment Templates"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Example: Creating a warehouse template programmatically\ndef create_warehouse_template(file_path, width=20, depth=20, height=5):\n    """Create a basic warehouse template"""\n\n    stage = Usd.Stage.CreateNew(file_path)\n\n    # Create world root\n    world = stage.DefinePrim("/World", "Xform")\n\n    # Create floor\n    floor = UsdGeom.Mesh.Define(stage, "/World/Floor")\n    # ... (floor geometry setup as in previous example)\n\n    # Create walls\n    create_walls(stage, width, depth, height)\n\n    # Create basic lighting\n    create_basic_lighting(stage, width, depth)\n\n    # Create basic shelving system\n    create_shelving_system(stage, width, depth)\n\n    stage.GetRootLayer().Save()\n    return stage\n\ndef create_walls(stage, width, depth, height):\n    """Create basic walls for the warehouse"""\n\n    # Front wall\n    front_wall = UsdGeom.Mesh.Define(stage, "/World/Walls/Front")\n    # Wall geometry definition...\n\n    # Back wall\n    back_wall = UsdGeom.Mesh.Define(stage, "/World/Walls/Back")\n    # Wall geometry definition...\n\n    # Side walls\n    left_wall = UsdGeom.Mesh.Define(stage, "/World/Walls/Left")\n    right_wall = UsdGeom.Mesh.Define(stage, "/World/Walls/Right")\n    # Wall geometry definition...\n\ndef create_basic_lighting(stage, width, depth):\n    """Create basic overhead lighting"""\n\n    # Create lighting group\n    lights = stage.DefinePrim("/World/Lighting", "Xform")\n\n    # Add overhead lights in grid pattern\n    light_spacing = 4.0  # meters between lights\n    for x in range(0, int(width/light_spacing)):\n        for y in range(0, int(depth/light_spacing)):\n            light_pos = (x * light_spacing - width/2, 4.0, y * light_spacing - depth/2)\n            create_overhead_light(stage, f"/World/Lighting/Light_{x}_{y}", light_pos)\n\ndef create_overhead_light(stage, path, position):\n    """Create an overhead light"""\n    light_prim = stage.DefinePrim(path, "DistantLight")\n    light = UsdGeom.Xform(light_prim)\n    light.AddTranslateOp().Set(position)\n    # Configure light properties\n\n# Usage\nwarehouse_stage = create_warehouse_template("./warehouse_template.usd")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-environment-creation",children:"Best Practices for Environment Creation"}),"\n",(0,s.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LOD Systems"}),": Implement level of detail for distant objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Occlusion Culling"}),": Hide objects not visible to cameras"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Texture Streaming"}),": Load textures based on camera proximity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Instance Management"}),": Use instancing for repeated objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Optimization"}),": Simplify collision geometry where appropriate"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"realism-considerations",children:"Realism Considerations"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Material Accuracy"}),": Use physically accurate materials"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lighting Consistency"}),": Maintain consistent lighting throughout the scene"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scale Accuracy"}),": Ensure all objects are properly scaled"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Realism"}),": Configure realistic physical properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor Accuracy"}),": Match sensor parameters to real hardware"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"collaboration-and-version-control",children:"Collaboration and Version Control"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"USD Layering"}),": Use layers for different aspects of the environment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Asset References"}),": Use references for shared assets"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Naming Conventions"}),": Maintain consistent naming throughout"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation"}),": Document scene structure and asset usage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"}),": Implement validation checks for scene integrity"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Exercise 1"}),": Create a simple office environment with at least 5 different furniture items using USD import and manual creation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Exercise 2"}),": Implement a material system with 3 different PBR materials (metal, plastic, fabric) and apply them to different objects in your scene."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Exercise 3"}),": Set up a camera system with both RGB and depth cameras on a simple robot model and verify the sensor data generation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Exercise 4"}),": Create a template for an outdoor urban environment with buildings, roads, and street furniture."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Building simulation environments in Isaac Sim requires understanding of USD for scene description, effective asset management strategies, realistic material creation, and proper lighting and camera configuration. The combination of photorealistic rendering, accurate physics, and seamless ROS 2 integration makes Isaac Sim a powerful platform for creating complex and realistic simulation environments."}),"\n",(0,s.jsx)(n.p,{children:"The template-based approach to environment creation accelerates development and ensures consistency across different simulation scenarios. Proper optimization techniques ensure that complex environments can run in real-time while maintaining the visual fidelity necessary for effective sim-to-real transfer."}),"\n",(0,s.jsx)(n.p,{children:"As we continue through this module, we'll explore physics simulation in detail, which adds another layer of realism to these carefully crafted environments. The foundation of well-structured environments enables the advanced simulation capabilities that make Isaac Sim a premier choice for robotics development."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(6540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);