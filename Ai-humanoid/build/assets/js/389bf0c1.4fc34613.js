"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[9009],{4739:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-2-PublishSubscribe","title":"1 3.2 PublishSubscribe","description":"Introduction to Publish-Subscribe Pattern","source":"@site/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3.2 PublishSubscribe.md","sourceDirName":"Module1-ROS/Chapter3-PythonAgentsWithRclpy","slug":"/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-2-PublishSubscribe","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-2-PublishSubscribe","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3.2 PublishSubscribe.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"id":"1-3-2-PublishSubscribe","title":"1 3.2 PublishSubscribe","sidebar_label":"1 3.2 PublishSubscribe","sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Python Agents with rclpy","permalink":"/docs/category/chapter-3-python-agents-with-rclpy"},"next":{"title":"1 3.3 Services","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-3-Services"}}');var i=s(4848),r=s(8453);const a={id:"1-3-2-PublishSubscribe",title:"1 3.2 PublishSubscribe",sidebar_label:"1 3.2 PublishSubscribe",sidebar_position:0},o="Chapter 3-02: Implementing Topics in Python with rclpy",l={},c=[{value:"Introduction to Publish-Subscribe Pattern",id:"introduction-to-publish-subscribe-pattern",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Creating Publishers",id:"creating-publishers",level:2},{value:"Basic Publisher Implementation",id:"basic-publisher-implementation",level:3},{value:"Publisher with Parameters",id:"publisher-with-parameters",level:3},{value:"Publisher Best Practices",id:"publisher-best-practices",level:3},{value:"Creating Subscribers",id:"creating-subscribers",level:2},{value:"Basic Subscriber Implementation",id:"basic-subscriber-implementation",level:3},{value:"Advanced Subscriber with Data Processing",id:"advanced-subscriber-with-data-processing",level:3},{value:"Subscriber Best Practices",id:"subscriber-best-practices",level:3},{value:"Working with Custom Message Types",id:"working-with-custom-message-types",level:2},{value:"Creating and Using Custom Messages",id:"creating-and-using-custom-messages",level:3},{value:"Complex Custom Message Example",id:"complex-custom-message-example",level:3},{value:"Custom Message Best Practices",id:"custom-message-best-practices",level:3},{value:"Quality of Service (QoS) Settings",id:"quality-of-service-qos-settings",level:2},{value:"Understanding QoS Profiles",id:"understanding-qos-profiles",level:3},{value:"Common QoS Patterns",id:"common-qos-patterns",level:3},{value:"QoS Best Practices",id:"qos-best-practices",level:3},{value:"Python Agent Bridge for Topics",id:"python-agent-bridge-for-topics",level:2},{value:"Bridge Architecture for Topic Communication",id:"bridge-architecture-for-topic-communication",level:3},{value:"Advanced Bridge Features",id:"advanced-bridge-features",level:3},{value:"Bridge Pattern Benefits for Topics",id:"bridge-pattern-benefits-for-topics",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-3-02-implementing-topics-in-python-with-rclpy",children:"Chapter 3-02: Implementing Topics in Python with rclpy"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-publish-subscribe-pattern",children:"Introduction to Publish-Subscribe Pattern"}),"\n",(0,i.jsx)(n.p,{children:"The publish-subscribe (pub/sub) pattern is the most fundamental communication paradigm in ROS 2 (Robot Operating System 2). It enables asynchronous, decoupled communication between nodes through topics. In this pattern, publishers send messages to topics without knowing which subscribers will receive them, and subscribers receive messages from topics without knowing which publishers sent them."}),"\n",(0,i.jsx)(n.p,{children:"This decoupling is essential for creating flexible, scalable robotic systems where components can be developed, tested, and deployed independently. The publish-subscribe pattern allows for one-to-many, many-to-one, and many-to-many communication patterns, making it ideal for distributed robotics applications."}),"\n",(0,i.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create publishers that send messages to ROS 2 topics"}),"\n",(0,i.jsx)(n.li,{children:"Create subscribers that receive messages from ROS 2 topics"}),"\n",(0,i.jsx)(n.li,{children:"Implement Quality of Service (QoS) settings for different communication needs"}),"\n",(0,i.jsx)(n.li,{children:"Work with custom message types in Python"}),"\n",(0,i.jsx)(n.li,{children:"Bridge Python agents to ROS controllers using publish-subscribe patterns"}),"\n",(0,i.jsx)(n.li,{children:"Structure topic communication content for RAG (Retrieval-Augmented Generation) indexing"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Topic"}),": A named channel through which messages flow"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Publisher"}),": A node that sends messages to a topic"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Subscriber"}),": A node that receives messages from a topic"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message"}),": The data structure sent between nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"QoS (Quality of Service)"}),": Settings that control message delivery characteristics"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-publishers",children:"Creating Publishers"}),"\n",(0,i.jsxs)(n.p,{children:["Publishers allow nodes to send messages to topics in the publish-subscribe pattern. Creating a publisher in ",(0,i.jsx)(n.code,{children:"rclpy"})," involves using the ",(0,i.jsx)(n.code,{children:"create_publisher()"})," method of a node instance."]}),"\n",(0,i.jsx)(n.h3,{id:"basic-publisher-implementation",children:"Basic Publisher Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Int32, Float32\nimport time\n\nclass DataPublisher(Node):\n    \"\"\"\n    A publisher node that demonstrates creating and using multiple publishers\n    to send different types of data to different topics.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('data_publisher')\n\n        # Create multiple publishers for different data types\n        self.string_publisher = self.create_publisher(String, 'string_topic', 10)\n        self.int_publisher = self.create_publisher(Int32, 'int_topic', 10)\n        self.float_publisher = self.create_publisher(Float32, 'float_topic', 10)\n\n        # Timer to publish data at regular intervals\n        self.timer = self.create_timer(0.5, self.publish_data)\n        self.counter = 0\n\n        self.get_logger().info('Data Publisher initialized')\n\n    def publish_data(self):\n        \"\"\"Publish data to all topics.\"\"\"\n        # Publish string message\n        str_msg = String()\n        str_msg.data = f'Data packet {self.counter}'\n        self.string_publisher.publish(str_msg)\n\n        # Publish integer message\n        int_msg = Int32()\n        int_msg.data = self.counter\n        self.int_publisher.publish(int_msg)\n\n        # Publish float message\n        float_msg = Float32()\n        float_msg.data = float(self.counter) * 0.1\n        self.float_publisher.publish(float_msg)\n\n        self.get_logger().info(f'Published data packet {self.counter}')\n        self.counter += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    data_publisher = DataPublisher()\n\n    try:\n        rclpy.spin(data_publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        data_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"publisher-with-parameters",children:"Publisher with Parameters"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nimport time\n\nclass ParameterizedPublisher(Node):\n    \"\"\"\n    A publisher that uses parameters to configure its behavior.\n    This demonstrates how to make publishers configurable at runtime.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('parameterized_publisher')\n\n        # Declare parameters for publisher configuration\n        self.declare_parameter('publish_frequency', 2.0)  # Hz\n        self.declare_parameter('topic_name', 'parameterized_topic')\n        self.declare_parameter('message_prefix', 'Parameterized message')\n        self.declare_parameter('max_count', 100)\n\n        # Get parameter values\n        self.publish_frequency = self.get_parameter('publish_frequency').value\n        self.topic_name = self.get_parameter('topic_name').value\n        self.message_prefix = self.get_parameter('message_prefix').value\n        self.max_count = self.get_parameter('max_count').value\n\n        # Create publisher with parameterized topic name\n        self.publisher = self.create_publisher(String, self.topic_name, 10)\n\n        # Set up timer based on frequency parameter\n        timer_period = 1.0 / self.publish_frequency\n        self.timer = self.create_timer(timer_period, self.publish_message)\n\n        # Initialize state\n        self.counter = 0\n\n        # Log configuration\n        self.get_logger().info(f'Parameterized Publisher initialized')\n        self.get_logger().info(f'Publishing to: {self.topic_name}')\n        self.get_logger().info(f'Frequency: {self.publish_frequency} Hz')\n        self.get_logger().info(f'Message prefix: {self.message_prefix}')\n\n    def publish_message(self):\n        \"\"\"Publish a parameterized message.\"\"\"\n        if self.counter >= self.max_count:\n            self.get_logger().info('Maximum count reached, stopping publisher')\n            # In a real application, you might want to stop the timer or shutdown\n            return\n\n        msg = String()\n        msg.data = f'{self.message_prefix} #{self.counter} at {time.time()}'\n        self.publisher.publish(msg)\n\n        self.get_logger().info(f'Published: {msg.data}')\n        self.counter += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    param_publisher = ParameterizedPublisher()\n\n    try:\n        rclpy.spin(param_publisher)\n    except KeyboardInterrupt:\n        param_publisher.get_logger().info('Interrupted, shutting down...')\n    finally:\n        param_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"publisher-best-practices",children:"Publisher Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Queue Size"}),": Choose appropriate queue sizes based on your application needs (typically 10 for most applications)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Construction"}),": Construct messages efficiently, avoiding unnecessary computations in publish loops"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Management"}),": Properly manage publisher resources by destroying them when the node is destroyed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": While ",(0,i.jsx)(n.code,{children:"rclpy"})," handles most communication errors, ensure your application logic is robust"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameter Configuration"}),": Use parameters to make publishers configurable without code changes"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-subscribers",children:"Creating Subscribers"}),"\n",(0,i.jsxs)(n.p,{children:["Subscribers receive messages from topics in the publish-subscribe pattern. Creating a subscriber in ",(0,i.jsx)(n.code,{children:"rclpy"})," involves using the ",(0,i.jsx)(n.code,{children:"create_subscription()"})," method of a node instance, which requires a callback function to process incoming messages."]}),"\n",(0,i.jsx)(n.h3,{id:"basic-subscriber-implementation",children:"Basic Subscriber Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Int32, Float32\n\nclass DataSubscriber(Node):\n    """\n    A subscriber node that demonstrates creating and using multiple subscribers\n    to receive different types of data from different topics.\n    """\n\n    def __init__(self):\n        super().__init__(\'data_subscriber\')\n\n        # Create subscribers for different message types\n        self.string_subscription = self.create_subscription(\n            String,\n            \'string_topic\',\n            self.string_callback,\n            10)\n        self.string_subscription  # prevent unused variable warning\n\n        self.int_subscription = self.create_subscription(\n            Int32,\n            \'int_topic\',\n            self.int_callback,\n            10)\n        self.int_subscription  # prevent unused variable warning\n\n        self.float_subscription = self.create_subscription(\n            Float32,\n            \'float_topic\',\n            self.float_callback,\n            10)\n        self.float_subscription  # prevent unused variable warning\n\n        self.get_logger().info(\'Data Subscriber initialized\')\n\n    def string_callback(self, msg):\n        """Handle incoming string messages."""\n        self.get_logger().info(f\'Received string: {msg.data}\')\n\n    def int_callback(self, msg):\n        """Handle incoming integer messages."""\n        self.get_logger().info(f\'Received integer: {msg.data}\')\n\n    def float_callback(self, msg):\n        """Handle incoming float messages."""\n        self.get_logger().info(f\'Received float: {msg.data:.2f}\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    data_subscriber = DataSubscriber()\n\n    try:\n        rclpy.spin(data_subscriber)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        data_subscriber.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-subscriber-with-data-processing",children:"Advanced Subscriber with Data Processing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float32, String\nfrom collections import deque\nimport statistics\n\nclass ProcessingSubscriber(Node):\n    \"\"\"\n    A subscriber that processes incoming data and maintains statistics.\n    This demonstrates how subscribers can perform computations on received data.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('processing_subscriber')\n\n        # Declare parameters for processing configuration\n        self.declare_parameter('history_size', 10)\n        self.declare_parameter('threshold', 5.0)\n        self.declare_parameter('topic_name', 'sensor_data')\n\n        # Get parameter values\n        self.history_size = self.get_parameter('history_size').value\n        self.threshold = self.get_parameter('threshold').value\n        self.topic_name = self.get_parameter('topic_name').value\n\n        # Create subscription\n        self.subscription = self.create_subscription(\n            Float32,\n            self.topic_name,\n            self.data_callback,\n            10\n        )\n\n        # Publisher for processed results\n        self.result_publisher = self.create_publisher(String, 'processed_results', 10)\n\n        # Data storage and statistics\n        self.data_history = deque(maxlen=self.history_size)\n        self.event_counter = 0\n\n        # Log configuration\n        self.get_logger().info(f'Processing Subscriber initialized')\n        self.get_logger().info(f'Subscribing to: {self.topic_name}')\n        self.get_logger().info(f'History size: {self.history_size}')\n        self.get_logger().info(f'Threshold: {self.threshold}')\n\n    def data_callback(self, msg):\n        \"\"\"Process incoming sensor data.\"\"\"\n        # Add new data to history\n        self.data_history.append(msg.data)\n\n        # Calculate statistics\n        if len(self.data_history) > 0:\n            current_value = msg.data\n            avg_value = statistics.mean(self.data_history)\n            min_value = min(self.data_history)\n            max_value = max(self.data_history)\n\n            # Check for threshold crossing\n            if current_value > self.threshold:\n                self.event_counter += 1\n                event_msg = f'EVENT #{self.event_counter}: Value {current_value} exceeded threshold {self.threshold}'\n                self.get_logger().warn(event_msg)\n\n                # Publish event notification\n                result_msg = String()\n                result_msg.data = event_msg\n                self.result_publisher.publish(result_msg)\n\n            # Log statistics periodically\n            if len(self.data_history) == self.history_size:\n                stats_msg = f'Current: {current_value:.2f}, Avg: {avg_value:.2f}, Min: {min_value:.2f}, Max: {max_value:.2f}'\n                self.get_logger().info(stats_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    processor = ProcessingSubscriber()\n\n    try:\n        rclpy.spin(processor)\n    except KeyboardInterrupt:\n        processor.get_logger().info('Interrupted, shutting down...')\n    finally:\n        processor.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"subscriber-best-practices",children:"Subscriber Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Callback Efficiency"}),": Keep subscriber callbacks lightweight to avoid blocking message processing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Handling"}),": Process messages efficiently and avoid unnecessary copies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Threading"}),": Be aware that callbacks run in the same thread as the executor by default"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Queue Management"}),": Choose appropriate queue sizes to handle message bursts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Handle potential errors in message processing gracefully"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"working-with-custom-message-types",children:"Working with Custom Message Types"}),"\n",(0,i.jsxs)(n.p,{children:["While ROS 2 provides standard message types in ",(0,i.jsx)(n.code,{children:"std_msgs"}),", ",(0,i.jsx)(n.code,{children:"sensor_msgs"}),", and other packages, you'll often need to define custom message types for your specific application. Custom messages enable precise data exchange between nodes and are essential for building specialized robotic applications."]}),"\n",(0,i.jsx)(n.h3,{id:"creating-and-using-custom-messages",children:"Creating and Using Custom Messages"}),"\n",(0,i.jsxs)(n.p,{children:["First, you would define your custom message in a ",(0,i.jsx)(n.code,{children:".msg"})," file (typically in a package's ",(0,i.jsx)(n.code,{children:"msg/"})," directory):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# In your_robot_package/msg/RobotPose.msg\nfloat64 x\nfloat64 y\nfloat64 theta\nstring robot_name\nuint8[] status_flags\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then use it in your publisher/subscriber:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Publisher with custom message\nimport rclpy\nfrom rclpy.node import Node\nfrom your_robot_package.msg import RobotPose  # Custom message type\n\nclass RobotPosePublisher(Node):\n    \"\"\"\n    A publisher that sends custom RobotPose messages.\n    This demonstrates how to work with custom message types in Python.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('robot_pose_publisher')\n\n        # Create publisher for custom message type\n        self.publisher = self.create_publisher(RobotPose, 'robot_pose', 10)\n\n        # Timer for periodic publishing\n        self.timer = self.create_timer(0.1, self.publish_pose)\n\n        self.robot_id = 0\n        self.get_logger().info('Robot Pose Publisher initialized')\n\n    def publish_pose(self):\n        \"\"\"Publish robot pose information.\"\"\"\n        msg = RobotPose()\n        msg.x = 1.0 + self.robot_id * 0.1  # Simulated position\n        msg.y = 2.0 + self.robot_id * 0.1\n        msg.theta = 1.57  # 90 degrees in radians\n        msg.robot_name = f'robot_{self.robot_id}'\n        msg.status_flags = [1, 0, 1, 0]  # Example status flags\n\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Published pose for {msg.robot_name}: ({msg.x}, {msg.y}, {msg.theta})')\n\n        self.robot_id = (self.robot_id + 1) % 10  # Cycle through robot IDs\n\n# Subscriber for custom message\nclass RobotPoseSubscriber(Node):\n    \"\"\"\n    A subscriber that receives custom RobotPose messages.\n    This demonstrates how to process custom message types in Python.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('robot_pose_subscriber')\n\n        # Create subscription for custom message type\n        self.subscription = self.create_subscription(\n            RobotPose,\n            'robot_pose',\n            self.pose_callback,\n            10\n        )\n\n        self.get_logger().info('Robot Pose Subscriber initialized')\n\n    def pose_callback(self, msg):\n        \"\"\"Handle incoming robot pose messages.\"\"\"\n        self.get_logger().info(\n            f'Received pose for {msg.robot_name}: '\n            f'Position({msg.x:.2f}, {msg.y:.2f}), '\n            f'Orientation: {msg.theta:.2f} rad'\n        )\n\n        # Process status flags\n        if len(msg.status_flags) > 0:\n            status_str = ''.join([str(flag) for flag in msg.status_flags])\n            self.get_logger().info(f'Status flags: {status_str}')\n"})}),"\n",(0,i.jsx)(n.h3,{id:"complex-custom-message-example",children:"Complex Custom Message Example"}),"\n",(0,i.jsx)(n.p,{children:"For more complex applications, you might need nested message structures:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# In your_robot_package/msg/RobotState.msg\nRobotPose pose\nsensor_msgs/BatteryState battery\ngeometry_msgs/Twist velocity\nuint8[] sensor_readings\nbuiltin_interfaces/Time timestamp\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom your_robot_package.msg import RobotState  # Custom message with nested types\nfrom sensor_msgs.msg import BatteryState\nfrom geometry_msgs.msg import Twist\nfrom builtin_interfaces.msg import Time\n\nclass RobotStatePublisher(Node):\n    \"\"\"\n    A publisher that sends complex RobotState messages with nested types.\n    This demonstrates working with complex custom message structures.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('robot_state_publisher')\n\n        self.publisher = self.create_publisher(RobotState, 'robot_state', 10)\n        self.timer = self.create_timer(0.5, self.publish_state)\n\n        self.sequence = 0\n        self.get_logger().info('Robot State Publisher initialized')\n\n    def publish_state(self):\n        \"\"\"Publish comprehensive robot state information.\"\"\"\n        msg = RobotState()\n\n        # Set pose information\n        msg.pose.x = 1.0 + self.sequence * 0.01\n        msg.pose.y = 2.0 + self.sequence * 0.01\n        msg.pose.theta = 0.0\n        msg.pose.robot_name = f'robot_{self.sequence % 10}'\n        msg.pose.status_flags = [1, 1, 0, 1]\n\n        # Set battery information\n        msg.battery.voltage = 12.6 - (self.sequence * 0.01)  # Simulated discharge\n        msg.battery.current = 2.5\n        msg.battery.charge = 85.0 - (self.sequence * 0.1)\n        msg.battery.percentage = msg.battery.charge / 100.0\n        msg.battery.power_supply_status = BatteryState.POWER_SUPPLY_STATUS_DISCHARGING\n\n        # Set velocity information\n        msg.velocity.linear.x = 0.5 + (self.sequence % 3) * 0.1\n        msg.velocity.linear.y = 0.0\n        msg.velocity.linear.z = 0.0\n        msg.velocity.angular.x = 0.0\n        msg.velocity.angular.y = 0.0\n        msg.velocity.angular.z = 0.1 * (self.sequence % 5 - 2)\n\n        # Set sensor readings (simulated)\n        msg.sensor_readings = [i + self.sequence for i in range(8)]\n\n        # Set timestamp\n        current_time = self.get_clock().now().to_msg()\n        msg.timestamp.sec = current_time.sec\n        msg.timestamp.nanosec = current_time.nanosec\n\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Published state for {msg.pose.robot_name}')\n\n        self.sequence += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    state_publisher = RobotStatePublisher()\n\n    try:\n        rclpy.spin(state_publisher)\n    except KeyboardInterrupt:\n        state_publisher.get_logger().info('Interrupted, shutting down...')\n    finally:\n        state_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"custom-message-best-practices",children:"Custom Message Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Design"}),": Design messages to be efficient and include only necessary data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Naming Conventions"}),": Use clear, descriptive names for message fields"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Types"}),": Choose appropriate data types to balance precision and efficiency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": Document message fields and their expected values"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Versioning"}),": Consider how message changes will affect compatibility"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"quality-of-service-qos-settings",children:"Quality of Service (QoS) Settings"}),"\n",(0,i.jsx)(n.p,{children:"Quality of Service (QoS) settings in ROS 2 control how messages are delivered between publishers and subscribers. These settings allow you to optimize communication for different requirements such as reliability, latency, and resource usage."}),"\n",(0,i.jsx)(n.h3,{id:"understanding-qos-profiles",children:"Understanding QoS Profiles"}),"\n",(0,i.jsx)(n.p,{children:"QoS settings include several key parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reliability"}),": Whether messages are guaranteed to be delivered"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Durability"}),": Whether late-joining subscribers receive old messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"History"}),": How many messages to store"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deadline"}),": Maximum time between consecutive messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Liveliness"}),": How to detect if a publisher is still active"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy\nfrom std_msgs.msg import String\n\nclass QoSPublisher(Node):\n    \"\"\"\n    A publisher that demonstrates different QoS settings for various use cases.\n    This shows how to configure communication characteristics for different needs.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('qos_publisher')\n\n        # Create different QoS profiles for different use cases\n\n        # Real-time sensor data: Best effort, volatile, small history\n        sensor_qos = QoSProfile(\n            depth=5,  # Small history for real-time data\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n        self.sensor_publisher = self.create_publisher(String, 'sensor_data', sensor_qos)\n\n        # Critical commands: Reliable, volatile, small history\n        command_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n        self.command_publisher = self.create_publisher(String, 'robot_commands', command_qos)\n\n        # Configuration data: Reliable, transient local, larger history\n        config_qos = QoSProfile(\n            depth=100,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.TRANSIENT_LOCAL,\n            history=HistoryPolicy.KEEP_ALL\n        )\n        self.config_publisher = self.create_publisher(String, 'configuration', config_qos)\n\n        # Timer for publishing different types of data\n        self.timer = self.create_timer(1.0, self.publish_messages)\n\n        self.message_counter = 0\n        self.get_logger().info('QoS Publisher initialized with different profiles')\n\n    def publish_messages(self):\n        \"\"\"Publish messages with different QoS requirements.\"\"\"\n        # Publish sensor data (best effort)\n        sensor_msg = String()\n        sensor_msg.data = f'Sensor reading {self.message_counter}'\n        self.sensor_publisher.publish(sensor_msg)\n\n        # Publish command data (reliable)\n        command_msg = String()\n        command_msg.data = f'Command {self.message_counter}'\n        self.command_publisher.publish(command_msg)\n\n        # Publish configuration data (reliable, persistent)\n        config_msg = String()\n        config_msg.data = f'Configuration setting {self.message_counter}'\n        self.config_publisher.publish(config_msg)\n\n        self.get_logger().info(f'Published messages: {self.message_counter}')\n        self.message_counter += 1\n\nclass QoSSubscriber(Node):\n    \"\"\"\n    A subscriber that uses matching QoS profiles to receive messages properly.\n    This demonstrates how subscribers must match or be compatible with publisher QoS.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('qos_subscriber')\n\n        # Create QoS profiles that match the publisher\n        sensor_qos = QoSProfile(\n            depth=5,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE\n        )\n        self.sensor_subscription = self.create_subscription(\n            String, 'sensor_data', self.sensor_callback, sensor_qos\n        )\n\n        command_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE\n        )\n        self.command_subscription = self.create_subscription(\n            String, 'robot_commands', self.command_callback, command_qos\n        )\n\n        config_qos = QoSProfile(\n            depth=100,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.TRANSIENT_LOCAL\n        )\n        self.config_subscription = self.create_subscription(\n            String, 'configuration', self.config_callback, config_qos\n        )\n\n        self.get_logger().info('QoS Subscriber initialized')\n\n    def sensor_callback(self, msg):\n        \"\"\"Handle best-effort sensor data.\"\"\"\n        self.get_logger().info(f'Received sensor data: {msg.data}')\n\n    def command_callback(self, msg):\n        \"\"\"Handle reliable command data.\"\"\"\n        self.get_logger().info(f'Received command: {msg.data}')\n\n    def config_callback(self, msg):\n        \"\"\"Handle persistent configuration data.\"\"\"\n        self.get_logger().info(f'Received config: {msg.data}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    # Run both publisher and subscriber in the same process for demonstration\n    qos_publisher = QoSPublisher()\n    qos_subscriber = QoSSubscriber()\n\n    try:\n        # Create a MultiThreadedExecutor to handle both nodes\n        from rclpy.executors import MultiThreadedExecutor\n        executor = MultiThreadedExecutor()\n        executor.add_node(qos_publisher)\n        executor.add_node(qos_subscriber)\n\n        executor.spin()\n    except KeyboardInterrupt:\n        qos_publisher.get_logger().info('Interrupted, shutting down...')\n        qos_subscriber.get_logger().info('Subscriber shutting down...')\n    finally:\n        qos_publisher.destroy_node()\n        qos_subscriber.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"common-qos-patterns",children:"Common QoS Patterns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy\n\n# Predefined QoS profiles for common use cases\n\n# Sensor data: Best effort, small history, volatile\nSENSOR_DATA_QOS = QoSProfile(\n    depth=10,\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    durability=DurabilityPolicy.VOLATILE,\n    history=HistoryPolicy.KEEP_LAST\n)\n\n# Control commands: Reliable, small history, volatile\nCOMMAND_QOS = QoSProfile(\n    depth=10,\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.VOLATILE,\n    history=HistoryPolicy.KEEP_LAST\n)\n\n# Configuration: Reliable, large history, transient local\nCONFIG_QOS = QoSProfile(\n    depth=100,\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.TRANSIENT_LOCAL,\n    history=HistoryPolicy.KEEP_LAST\n)\n\n# Log data: Reliable, keep all, volatile (be careful with memory usage)\nLOG_QOS = QoSProfile(\n    depth=1000,\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.VOLATILE,\n    history=HistoryPolicy.KEEP_ALL\n)\n\n# Image data: Best effort, small history, volatile\nIMAGE_QOS = QoSProfile(\n    depth=1,\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    durability=DurabilityPolicy.VOLATILE,\n    history=HistoryPolicy.KEEP_LAST\n)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"qos-best-practices",children:"QoS Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Match Publisher/Subscriber QoS"}),": Subscribers should use compatible QoS settings to receive messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Choose Appropriate Reliability"}),": Use BEST_EFFORT for real-time data, RELIABLE for commands"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Manage History Depth"}),": Balance between data availability and memory usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consider Durability"}),": Use TRANSIENT_LOCAL for configuration data that new subscribers need"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test Compatibility"}),": Verify that your QoS settings work as expected in your system"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"python-agent-bridge-for-topics",children:"Python Agent Bridge for Topics"}),"\n",(0,i.jsx)(n.p,{children:"One of the most important applications of publish-subscribe communication in robotics is bridging Python AI agents to ROS controllers. This pattern enables AI algorithms to send commands to robot controllers and receive sensor feedback through ROS topics."}),"\n",(0,i.jsx)(n.h3,{id:"bridge-architecture-for-topic-communication",children:"Bridge Architecture for Topic Communication"}),"\n",(0,i.jsx)(n.p,{children:"The bridge architecture involves creating ROS 2 nodes that translate between Python agent outputs and ROS messages:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Float32, Bool\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\nfrom nav_msgs.msg import Odometry\nimport numpy as np\nimport time\n\nclass TopicBridgeNode(Node):\n    \"\"\"\n    A bridge node that connects Python AI agents to ROS controllers using topics.\n    This demonstrates how to use publish-subscribe for AI-robot communication.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('topic_bridge')\n\n        # Declare bridge configuration parameters\n        self.declare_parameter('bridge_frequency', 20)  # Hz\n        self.declare_parameter('safety_threshold', 0.5)  # meters\n        self.declare_parameter('max_linear_velocity', 1.0)\n        self.declare_parameter('max_angular_velocity', 1.0)\n\n        # Get parameter values\n        self.bridge_frequency = self.get_parameter('bridge_frequency').value\n        self.safety_threshold = self.get_parameter('safety_threshold').value\n        self.max_linear_vel = self.get_parameter('max_linear_velocity').value\n        self.max_angular_vel = self.get_parameter('max_angular_velocity').value\n\n        # Publishers to send commands to robot controllers\n        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.agent_status_publisher = self.create_publisher(String, '/agent_status', 10)\n\n        # Subscribers to receive sensor data from robot\n        self.laser_subscriber = self.create_subscription(\n            LaserScan, '/scan', self.laser_callback, 10\n        )\n        self.odom_subscriber = self.create_subscription(\n            Odometry, '/odom', self.odom_callback, 10\n        )\n\n        # Subscribers for agent commands and control signals\n        self.agent_command_subscriber = self.create_subscription(\n            String, '/agent_commands', self.agent_command_callback, 10\n        )\n        self.agent_control_subscriber = self.create_subscription(\n            Bool, '/agent_enabled', self.agent_control_callback, 10\n        )\n\n        # Timer for bridge processing loop\n        timer_period = 1.0 / self.bridge_frequency\n        self.bridge_timer = self.create_timer(timer_period, self.bridge_process)\n\n        # State variables\n        self.latest_laser_data = None\n        self.latest_odom_data = None\n        self.latest_agent_command = None\n        self.agent_enabled = True\n        self.safety_mode = False\n        self.last_command_time = time.time()\n\n        # Agent state tracking\n        self.agent_state = {\n            'position': (0.0, 0.0),\n            'orientation': 0.0,\n            'velocity': (0.0, 0.0),\n            'safety_status': 'normal',\n            'last_action': 'none'\n        }\n\n        # Log initialization\n        self.get_logger().info('Topic Bridge Node initialized')\n        self.get_logger().info(f'Bridge frequency: {self.bridge_frequency} Hz')\n        self.get_logger().info(f'Safety threshold: {self.safety_threshold} m')\n\n    def laser_callback(self, msg):\n        \"\"\"Handle incoming laser scan data from the robot.\"\"\"\n        self.latest_laser_data = msg\n        self.get_logger().debug(f'Received laser scan with {len(msg.ranges)} ranges')\n\n        # Update safety status based on laser data\n        if self.latest_laser_data:\n            valid_ranges = [r for r in self.latest_laser_data.ranges\n                          if r != float('inf') and not np.isnan(r) and r > 0]\n            if valid_ranges:\n                min_range = min(valid_ranges)\n                if min_range < self.safety_threshold:\n                    self.safety_mode = True\n                    self.agent_state['safety_status'] = 'obstacle_detected'\n                    self.get_logger().warn(f'Safety threshold violated: {min_range:.2f}m < {self.safety_threshold:.2f}m')\n                else:\n                    self.safety_mode = False\n                    self.agent_state['safety_status'] = 'normal'\n\n    def odom_callback(self, msg):\n        \"\"\"Handle incoming odometry data from the robot.\"\"\"\n        self.latest_odom_data = msg\n\n        # Update agent state with position information\n        self.agent_state['position'] = (msg.pose.pose.position.x, msg.pose.pose.position.y)\n        # Simplified orientation extraction (in a real system, you'd use quaternions properly)\n        self.agent_state['orientation'] = 0.0  # Placeholder\n        self.agent_state['velocity'] = (msg.twist.twist.linear.x, msg.twist.twist.angular.z)\n\n    def agent_command_callback(self, msg):\n        \"\"\"Handle high-level commands from the Python agent.\"\"\"\n        self.latest_agent_command = msg.data\n        self.agent_state['last_action'] = msg.data\n        self.last_command_time = time.time()\n\n        self.get_logger().info(f'Received agent command: {msg.data}')\n\n        # Process special agent commands\n        if msg.data == 'enable':\n            self.agent_enabled = True\n            self.get_logger().info('Agent enabled')\n        elif msg.data == 'disable':\n            self.agent_enabled = False\n            self.get_logger().info('Agent disabled')\n        elif msg.data == 'reset_safety':\n            self.safety_mode = False\n            self.agent_state['safety_status'] = 'normal'\n            self.get_logger().info('Safety mode reset')\n\n    def agent_control_callback(self, msg):\n        \"\"\"Handle enable/disable commands for the agent bridge.\"\"\"\n        self.agent_enabled = msg.data\n        status = 'enabled' if self.agent_enabled else 'disabled'\n        self.get_logger().info(f'Agent bridge {status} via control topic')\n\n    def bridge_process(self):\n        \"\"\"Main bridge processing loop that runs at bridge_frequency.\"\"\"\n        if not self.agent_enabled:\n            return\n\n        # Safety check - if in safety mode, stop the robot\n        if self.safety_mode:\n            self.emergency_stop()\n            return\n\n        # Process sensor data and make decisions if available\n        if self.latest_laser_data and self.latest_odom_data:\n            # Example AI decision based on sensor data\n            cmd_vel = self.make_decision_from_sensors()\n\n            # Publish the command to the robot controller\n            if cmd_vel:\n                self.cmd_vel_publisher.publish(cmd_vel)\n                self.get_logger().debug(f'Sent command: linear={cmd_vel.linear.x:.2f}, angular={cmd_vel.angular.z:.2f}')\n\n        # Publish agent status periodically\n        if time.time() - self.last_command_time > 1.0:  # Every second\n            self.publish_agent_status()\n\n    def make_decision_from_sensors(self):\n        \"\"\"\n        Example AI decision-making function based on sensor data.\n        This function analyzes sensor information and returns navigation commands.\n        \"\"\"\n        if not self.latest_laser_data or not self.latest_odom_data:\n            return None\n\n        # Analyze laser data for navigation\n        laser = self.latest_laser_data\n        front_ranges = laser.ranges[330:] + laser.ranges[:30]  # Front 60 degrees\n        valid_ranges = [r for r in front_ranges if r != float('inf') and not np.isnan(r) and r > 0]\n\n        if not valid_ranges:\n            # If no valid ranges in front, move forward slowly\n            cmd = Twist()\n            cmd.linear.x = 0.2\n            cmd.angular.z = 0.0\n            return cmd\n\n        min_front_distance = min(valid_ranges)\n\n        # Navigation algorithm based on obstacle distance\n        cmd = Twist()\n\n        if min_front_distance < self.safety_threshold * 1.2:  # Safety buffer\n            # Too close to obstacle, turn away\n            cmd.linear.x = 0.0\n            cmd.angular.z = 0.8  # Turn right\n        elif min_front_distance < self.safety_threshold * 2.5:\n            # Moderate distance, move forward slowly and check surroundings\n            cmd.linear.x = 0.3\n            # Add slight turning to scan environment\n            cmd.angular.z = 0.1 * np.sin(time.time())  # Gentle oscillation\n        else:\n            # Safe distance, move forward at normal speed\n            cmd.linear.x = 0.8\n            cmd.angular.z = 0.0\n\n        return cmd\n\n    def publish_agent_status(self):\n        \"\"\"Publish current agent status for monitoring.\"\"\"\n        status_msg = String()\n        status_msg.data = f'Agent running - Pos:({self.agent_state[\"position\"][0]:.2f},{self.agent_state[\"position\"][1]:.2f}) ' \\\n                         f'Status:{self.agent_state[\"safety_status\"]} ' \\\n                         f'Action:{self.agent_state[\"last_action\"]}'\n        self.agent_status_publisher.publish(status_msg)\n\n    def emergency_stop(self):\n        \"\"\"Send emergency stop command to robot.\"\"\"\n        cmd = Twist()\n        cmd.linear.x = 0.0\n        cmd.angular.z = 0.0\n        self.cmd_vel_publisher.publish(cmd)\n        self.get_logger().warn('Emergency stop command sent due to safety violation')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    bridge_node = TopicBridgeNode()\n\n    try:\n        rclpy.spin(bridge_node)\n    except KeyboardInterrupt:\n        bridge_node.get_logger().info('Interrupted, shutting down...')\n    finally:\n        bridge_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-bridge-features",children:"Advanced Bridge Features"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Float32MultiArray\nfrom sensor_msgs.msg import LaserScan, Image\nfrom geometry_msgs.msg import Twist\nfrom cv_bridge import CvBridge\nimport numpy as np\nimport time\nimport threading\nfrom queue import Queue\n\nclass AdvancedTopicBridgeNode(Node):\n    \"\"\"\n    An advanced bridge node with multiple features for AI-robot communication.\n    This includes sensor fusion, command queuing, and advanced safety systems.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_topic_bridge')\n\n        # Declare advanced configuration parameters\n        self.declare_parameter('bridge_frequency', 30)\n        self.declare_parameter('safety_check_frequency', 100)\n        self.declare_parameter('command_timeout', 2.0)\n        self.declare_parameter('max_command_queue', 10)\n\n        # Get parameter values\n        self.bridge_frequency = self.get_parameter('bridge_frequency').value\n        self.safety_frequency = self.get_parameter('safety_check_frequency').value\n        self.command_timeout = self.get_parameter('command_timeout').value\n        self.max_queue_size = self.get_parameter('max_command_queue').value\n\n        # Publishers\n        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.status_publisher = self.create_publisher(String, '/bridge_status', 10)\n\n        # Subscribers\n        self.laser_subscriber = self.create_subscription(LaserScan, '/scan', self.laser_callback, 10)\n        self.image_subscriber = self.create_subscription(Image, '/camera/image_raw', self.image_callback, 10)\n\n        # Agent command subscribers\n        self.agent_command_subscriber = self.create_subscription(String, '/agent_commands', self.agent_command_callback, 10)\n\n        # Timers\n        self.bridge_timer = self.create_timer(1.0/self.bridge_frequency, self.bridge_process)\n        self.safety_timer = self.create_timer(1.0/self.safety_frequency, self.safety_check)\n\n        # Data storage\n        self.laser_data = None\n        self.image_data = None\n        self.command_queue = Queue(maxsize=self.max_queue_size)\n        self.last_command_time = time.time()\n        self.bridge_enabled = True\n        self.safety_violation = False\n\n        # Threading for image processing (if needed)\n        self.image_lock = threading.Lock()\n\n        # CV Bridge for image processing\n        try:\n            self.cv_bridge = CvBridge()\n        except ImportError:\n            self.get_logger().warn('cv_bridge not available, image processing disabled')\n            self.cv_bridge = None\n\n        self.get_logger().info('Advanced Topic Bridge Node initialized')\n\n    def laser_callback(self, msg):\n        \"\"\"Handle laser scan data.\"\"\"\n        self.laser_data = msg\n\n    def image_callback(self, msg):\n        \"\"\"Handle image data.\"\"\"\n        with self.image_lock:\n            self.image_data = msg\n\n    def agent_command_callback(self, msg):\n        \"\"\"Handle agent commands with queuing.\"\"\"\n        try:\n            if not self.command_queue.full():\n                self.command_queue.put((time.time(), msg.data))\n                self.last_command_time = time.time()\n            else:\n                self.get_logger().warn('Command queue full, dropping command')\n        except Exception as e:\n            self.get_logger().error(f'Error adding command to queue: {e}')\n\n    def safety_check(self):\n        \"\"\"High-frequency safety checks.\"\"\"\n        if not self.bridge_enabled:\n            return\n\n        if self.laser_data:\n            # Check for imminent collision\n            valid_ranges = [r for r in self.laser_data.ranges\n                          if r != float('inf') and not np.isnan(r) and r > 0 and r < 0.3]\n            if valid_ranges:\n                self.safety_violation = True\n                self.emergency_stop()\n                self.get_logger().error('SAFETY VIOLATION: Obstacle too close')\n            else:\n                self.safety_violation = False\n\n        # Check for command timeout\n        if time.time() - self.last_command_time > self.command_timeout:\n            self.get_logger().warn('No commands received recently, stopping robot')\n            self.emergency_stop()\n\n    def bridge_process(self):\n        \"\"\"Main bridge processing loop.\"\"\"\n        if not self.bridge_enabled or self.safety_violation:\n            return\n\n        # Process commands from queue\n        processed_count = 0\n        while not self.command_queue.empty() and processed_count < 3:  # Process up to 3 commands per cycle\n            try:\n                timestamp, command = self.command_queue.get_nowait()\n\n                # Check if command is too old\n                if time.time() - timestamp > self.command_timeout:\n                    self.get_logger().debug(f'Discarding old command: {command}')\n                    continue\n\n                # Process the command\n                self.process_agent_command(command)\n                processed_count += 1\n            except:\n                break  # Queue is empty\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f'Bridge active - Commands in queue: {self.command_queue.qsize()}, ' \\\n                         f'Safety: {\"OK\" if not self.safety_violation else \"VIOLATION\"}'\n        self.status_publisher.publish(status_msg)\n\n    def process_agent_command(self, command):\n        \"\"\"Process a single agent command.\"\"\"\n        self.get_logger().debug(f'Processing agent command: {command}')\n\n        # Example command processing\n        if command.startswith('move:'):\n            try:\n                parts = command.split(':')\n                if len(parts) >= 3:\n                    linear = float(parts[1])\n                    angular = float(parts[2])\n\n                    cmd = Twist()\n                    cmd.linear.x = max(-1.0, min(1.0, linear))  # Clamp to reasonable values\n                    cmd.angular.z = max(-1.0, min(1.0, angular))\n\n                    self.cmd_vel_publisher.publish(cmd)\n                    self.get_logger().info(f'Sent movement command: linear={linear}, angular={angular}')\n            except ValueError:\n                self.get_logger().error(f'Invalid move command format: {command}')\n\n    def emergency_stop(self):\n        \"\"\"Immediate stop for safety.\"\"\"\n        cmd = Twist()\n        cmd.linear.x = 0.0\n        cmd.angular.z = 0.0\n        self.cmd_vel_publisher.publish(cmd)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    advanced_bridge = AdvancedTopicBridgeNode()\n\n    try:\n        rclpy.spin(advanced_bridge)\n    except KeyboardInterrupt:\n        advanced_bridge.get_logger().info('Interrupted, shutting down...')\n    finally:\n        advanced_bridge.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"bridge-pattern-benefits-for-topics",children:"Bridge Pattern Benefits for Topics"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decoupling"}),": AI agents and robot controllers operate independently"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scalability"}),": Multiple agents can potentially influence the same robot"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety"}),": The bridge can implement safety checks and override agent decisions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flexibility"}),": Different AI algorithms can be swapped without changing controllers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitoring"}),": Bridge nodes can log and monitor AI-robot interactions"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.p,{children:["In this section, we've explored the publish-subscribe pattern in ROS 2 using ",(0,i.jsx)(n.code,{children:"rclpy"}),". You've learned:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Publisher creation"})," and configuration with various parameters"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Subscriber implementation"})," with efficient message processing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Custom message types"})," for specialized applications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Quality of Service settings"})," for different communication requirements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Python agent bridge patterns"})," for connecting AI algorithms to robot controllers using topics"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The publish-subscribe pattern is fundamental to ROS 2 and enables the distributed, asynchronous communication that makes robotic systems flexible and scalable."}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Multi-topic Publisher"}),": Create a publisher that sends synchronized sensor data (e.g., temperature, humidity, pressure) to multiple topics with appropriate QoS settings."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Aggregating Subscriber"}),": Implement a subscriber that receives data from multiple topics and publishes a combined summary message."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Custom Message Publisher/Subscriber"}),": Define and use a custom message type to represent robot health status (battery, temperature, error flags) and implement both publisher and subscriber."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"QoS Experimentation"}),": Create a system with different QoS profiles and observe how message delivery changes under network stress or node failures."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Advanced Bridge"}),": Implement a bridge node that combines sensor data from multiple sources (laser, camera, IMU) and provides a unified interface for Python AI agents."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Safety-Enhanced Bridge"}),": Extend the bridge example to include multiple safety checks (laser, camera, IMU) and implement a safety state machine."]}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);