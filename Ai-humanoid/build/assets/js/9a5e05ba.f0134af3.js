"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[3657],{8453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var i=a(6540);const r={},t=i.createContext(r);function s(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(t.Provider,{value:n},e.children)}},8967:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Module1-ROS/Chapter4-LaunchParamsLifecycle/Chapter4-LaunchParamsLifecycle","title":"Chapter 4 - Launch Files, Parameters, and Lifecycle Nodes","description":"Overview","source":"@site/docs/Module1-ROS/Chapter4-LaunchParamsLifecycle/index.md","sourceDirName":"Module1-ROS/Chapter4-LaunchParamsLifecycle","slug":"/Module1-ROS/Chapter4-LaunchParamsLifecycle/","permalink":"/docs/Module1-ROS/Chapter4-LaunchParamsLifecycle/","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module1-ROS/Chapter4-LaunchParamsLifecycle/index.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"Chapter4-LaunchParamsLifecycle","title":"Chapter 4 - Launch Files, Parameters, and Lifecycle Nodes","sidebar_label":"Launch Files, Parameters, Lifecycle","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Launch Params Lifecycle","permalink":"/docs/category/chapter-4-launch-params-lifecycle"},"next":{"title":"Chapter 1: Physics Simulation","permalink":"/docs/category/chapter-1-physics-simulation"}}');var r=a(4848),t=a(8453);const s={id:"Chapter4-LaunchParamsLifecycle",title:"Chapter 4 - Launch Files, Parameters, and Lifecycle Nodes",sidebar_label:"Launch Files, Parameters, Lifecycle",sidebar_position:4},o="Chapter 4: Launch Files, Parameters, and Lifecycle Nodes",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Chapter Structure",id:"chapter-structure",level:2},{value:"Section 1: Introduction to Launch System",id:"section-1-introduction-to-launch-system",level:2},{value:"Purpose of the Launch System",id:"purpose-of-the-launch-system",level:3},{value:"Problems with Standalone CLI Node Launching",id:"problems-with-standalone-cli-node-launching",level:3},{value:"Launch System Architecture",id:"launch-system-architecture",level:3},{value:"Section 2: Launch Files Basics",id:"section-2-launch-files-basics",level:2},{value:"Launch File Structure",id:"launch-file-structure",level:3},{value:"Python Launch File Template",id:"python-launch-file-template",level:3},{value:"Launch Actions",id:"launch-actions",level:3},{value:"Node Action",id:"node-action",level:4},{value:"TimerAction",id:"timeraction",level:4},{value:"IncludeLaunchDescription",id:"includelaunchdescription",level:4},{value:"Launch Arguments &amp; Substitutions",id:"launch-arguments--substitutions",level:3},{value:"LaunchConfiguration",id:"launchconfiguration",level:4},{value:"Path Substitutions",id:"path-substitutions",level:4},{value:"Section 3: Multi-Node Launch Files",id:"section-3-multi-node-launch-files",level:2},{value:"Launching Multiple Nodes",id:"launching-multiple-nodes",level:3},{value:"Namespaces &amp; Remapping",id:"namespaces--remapping",level:3},{value:"Namespaces",id:"namespaces",level:4},{value:"Topic Remapping",id:"topic-remapping",level:4},{value:"Composable Nodes (Brief Introduction)",id:"composable-nodes-brief-introduction",level:3},{value:"Section 4: ROS 2 Parameters",id:"section-4-ros-2-parameters",level:2},{value:"Parameter Declaration",id:"parameter-declaration",level:3},{value:"YAML Parameter Files",id:"yaml-parameter-files",level:3},{value:"Getting and Setting Parameters",id:"getting-and-setting-parameters",level:3},{value:"Dynamic Parameters",id:"dynamic-parameters",level:3},{value:"Section 5: Lifecycle Nodes",id:"section-5-lifecycle-nodes",level:2},{value:"Lifecycle States",id:"lifecycle-states",level:3},{value:"Transition System",id:"transition-system",level:3},{value:"Launch Integration",id:"launch-integration",level:3},{value:"Section 6: Integrated Examples",id:"section-6-integrated-examples",level:2},{value:"Multi-Node Launch with Parameters",id:"multi-node-launch-with-parameters",level:3},{value:"Lifecycle Node with Transitions",id:"lifecycle-node-with-transitions",level:3},{value:"Section 7: Exercises",id:"section-7-exercises",level:2},{value:"Exercise Set",id:"exercise-set",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-4-launch-files-parameters-and-lifecycle-nodes",children:"Chapter 4: Launch Files, Parameters, and Lifecycle Nodes"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"This chapter covers the essential ROS 2 (Robot Operating System 2) concepts of launch files, parameters, and lifecycle nodes. These components form the backbone of production-ready robotic systems, enabling orchestrated node startup, configurable robot behavior, and robust state management."}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Create and use Python-based launch files for multi-node robot systems"}),"\n",(0,r.jsx)(n.li,{children:"Configure ROS 2 parameters using YAML files and runtime APIs"}),"\n",(0,r.jsx)(n.li,{children:"Implement lifecycle nodes with proper state management"}),"\n",(0,r.jsx)(n.li,{children:"Combine launch files, parameters, and lifecycle nodes in integrated systems"}),"\n",(0,r.jsx)(n.li,{children:"Structure content for RAG (Retrieval-Augmented Generation) systems"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"chapter-structure",children:"Chapter Structure"}),"\n",(0,r.jsx)(n.p,{children:"This chapter is divided into several comprehensive sections:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Section 1"}),": Introduction to the ROS 2 Launch System"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Section 2"}),": Launch Files Basics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Section 3"}),": Multi-Node Launch Files"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Section 4"}),": ROS 2 Parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Section 5"}),": Lifecycle Nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Section 6"}),": Integrated Examples"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Section 7"}),": Exercises"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each section includes practical examples, code snippets, and exercises designed to reinforce your understanding of these advanced ROS 2 concepts."}),"\n",(0,r.jsx)(n.h2,{id:"section-1-introduction-to-launch-system",children:"Section 1: Introduction to Launch System"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 provides a sophisticated launch system that enables orchestrated startup, configuration, and management of multiple nodes in a robotic system. The launch system addresses critical challenges that arise when working with complex robot applications that require multiple coordinated nodes."}),"\n",(0,r.jsx)(n.h3,{id:"purpose-of-the-launch-system",children:"Purpose of the Launch System"}),"\n",(0,r.jsx)(n.p,{children:"The ROS 2 launch system serves several critical purposes in robotic applications:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Orchestrated Startup"}),": Launch multiple nodes in a coordinated manner with proper dependencies and timing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration Management"}),": Pass parameters, namespaces, and remappings to nodes at startup"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Process Management"}),": Handle node lifecycle, restart policies, and graceful shutdown"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reusability"}),": Create reusable launch configurations for different robot types or operating modes"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"problems-with-standalone-cli-node-launching",children:"Problems with Standalone CLI Node Launching"}),"\n",(0,r.jsx)(n.p,{children:"Without a proper launch system, robotic applications face several challenges:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Manual Startup"}),": Each node must be started individually in separate terminals"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameter Management"}),": Parameters must be set manually for each node"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Coordination"}),": No way to ensure nodes start in the correct order"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Monitoring"}),": Difficult to monitor the overall system state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Recovery"}),": No automatic restart of failed nodes"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"launch-system-architecture",children:"Launch System Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The launch system consists of launch files that define the desired system configuration, launch actions that perform specific operations, and launch arguments that allow for parameterization."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Example of basic launch file structure\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        # Launch actions go here\n    ])\n"})}),"\n",(0,r.jsx)(n.h2,{id:"section-2-launch-files-basics",children:"Section 2: Launch Files Basics"}),"\n",(0,r.jsx)(n.h3,{id:"launch-file-structure",children:"Launch File Structure"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 launch files can be written in Python or XML, with Python being the preferred approach for complex systems. The basic structure of a Python launch file includes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Import statements"})," for launch and ROS-specific actions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LaunchDescription"})," that contains all actions to execute"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node actions"})," that define which nodes to launch"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameter files"})," that configure node behavior"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Launch arguments"})," that allow for runtime configuration"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"python-launch-file-template",children:"Python Launch File Template"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Define launch arguments\n    param_file = LaunchConfiguration('param_file')\n\n    # Declare launch arguments\n    param_file_arg = DeclareLaunchArgument(\n        'param_file',\n        default_value='path/to/params.yaml',\n        description='Path to parameters file'\n    )\n\n    # Define nodes\n    node_example = Node(\n        package='package_name',\n        executable='node_name',\n        name='node_name',\n        parameters=[param_file]\n    )\n\n    # Return launch description\n    return LaunchDescription([\n        param_file_arg,\n        node_example\n    ])\n"})}),"\n",(0,r.jsx)(n.h3,{id:"launch-actions",children:"Launch Actions"}),"\n",(0,r.jsx)(n.p,{children:"Launch actions are the building blocks of launch files. The most common actions include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node"}),": Launch a ROS 2 node"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TimerAction"}),": Execute an action after a specified time delay"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IncludeLaunchDescription"}),": Include another launch file"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GroupAction"}),": Group multiple actions together"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DeclareLaunchArgument"}),": Define a launch argument"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"node-action",children:"Node Action"}),"\n",(0,r.jsx)(n.p,{children:"The Node action is the most common launch action, used to start ROS 2 nodes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch_ros.actions import Node\n\nsensor_node = Node(\n    package='sensor_package',\n    executable='sensor_node',\n    name='lidar_sensor',\n    parameters=[\n        {'sensor_range': 10.0},\n        'path/to/params.yaml'\n    ],\n    remappings=[\n        ('/raw_data', '/filtered_data')\n    ]\n)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"timeraction",children:"TimerAction"}),"\n",(0,r.jsx)(n.p,{children:"TimerAction allows for delayed execution of other actions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch.actions import TimerAction\nfrom launch_ros.actions import Node\n\ndelayed_node = TimerAction(\n    period=5.0,  # Wait 5 seconds\n    actions=[Node(\n        package='package_name',\n        executable='delayed_node',\n        name='delayed_node'\n    )]\n)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"includelaunchdescription",children:"IncludeLaunchDescription"}),"\n",(0,r.jsx)(n.p,{children:"IncludeLaunchDescription allows for modular launch file organization:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\n\nincluded_launch = IncludeLaunchDescription(\n    PythonLaunchDescriptionSource([\n        PathJoinSubstitution([\n            FindPackageShare('package_name'),\n            'launch',\n            'other_launch_file.launch.py'\n        ])\n    ])\n)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"launch-arguments--substitutions",children:"Launch Arguments & Substitutions"}),"\n",(0,r.jsx)(n.p,{children:"Launch arguments provide a way to parameterize launch files, making them more flexible and reusable. Substitutions allow for dynamic value computation at launch time."}),"\n",(0,r.jsx)(n.h4,{id:"launchconfiguration",children:"LaunchConfiguration"}),"\n",(0,r.jsx)(n.p,{children:"LaunchConfiguration allows launch arguments to be used within other launch actions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch.substitutions import LaunchConfiguration\nfrom launch.actions import DeclareLaunchArgument\n\n# Declare argument\nparam_file_arg = DeclareLaunchArgument(\n    'param_file',\n    default_value='default_params.yaml',\n    description='Path to parameter file'\n)\n\n# Use in node\nconfig_file = LaunchConfiguration('param_file')\n\nnode_with_params = Node(\n    package='package_name',\n    executable='node_name',\n    parameters=[config_file]\n)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"path-substitutions",children:"Path Substitutions"}),"\n",(0,r.jsx)(n.p,{children:"Path substitutions help with file path construction:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch.substitutions import PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\n\n# Construct path to config file\nconfig_path = PathJoinSubstitution([\n    FindPackageShare('package_name'),\n    'config',\n    'params.yaml'\n])\n\nnode_with_path = Node(\n    package='package_name',\n    executable='node_name',\n    parameters=[config_path]\n)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"section-3-multi-node-launch-files",children:"Section 3: Multi-Node Launch Files"}),"\n",(0,r.jsx)(n.h3,{id:"launching-multiple-nodes",children:"Launching Multiple Nodes"}),"\n",(0,r.jsx)(n.p,{children:"Multi-node launch files allow for the coordinated startup of complex robotic systems. This is essential for production robots that require multiple coordinated components."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Define multiple nodes\n    sensor_node = Node(\n        package='sensor_package',\n        executable='lidar_driver',\n        name='lidar_driver',\n        parameters=['config/lidar_params.yaml']\n    )\n\n    processing_node = Node(\n        package='processing_package',\n        executable='pointcloud_processor',\n        name='pointcloud_processor',\n        parameters=['config/processing_params.yaml']\n    )\n\n    navigation_node = Node(\n        package='nav_package',\n        executable='navigation',\n        name='navigation',\n        parameters=['config/nav_params.yaml']\n    )\n\n    return LaunchDescription([\n        sensor_node,\n        processing_node,\n        navigation_node\n    ])\n"})}),"\n",(0,r.jsx)(n.h3,{id:"namespaces--remapping",children:"Namespaces & Remapping"}),"\n",(0,r.jsx)(n.p,{children:"Namespaces and remapping are crucial for organizing complex multi-node systems and avoiding naming conflicts."}),"\n",(0,r.jsx)(n.h4,{id:"namespaces",children:"Namespaces"}),"\n",(0,r.jsx)(n.p,{children:"Namespaces provide logical grouping of nodes and topics:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch.actions import GroupAction\nfrom launch_ros.actions import PushRosNamespace\n\n# Group nodes under a namespace\nsensor_group = GroupAction(\n    actions=[\n        PushRosNamespace('sensors'),\n        Node(\n            package='sensor_package',\n            executable='lidar_driver',\n            name='lidar'\n        ),\n        Node(\n            package='sensor_package',\n            executable='camera_driver',\n            name='camera'\n        )\n    ]\n)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"topic-remapping",children:"Topic Remapping"}),"\n",(0,r.jsx)(n.p,{children:"Topic remapping allows nodes to connect to different topics than their default names:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"sensor_node = Node(\n    package='sensor_package',\n    executable='sensor_driver',\n    name='sensor',\n    remappings=[\n        ('/sensor_raw', '/filtered_sensor_data'),\n        ('/sensor_info', '/robot/sensor_info')\n    ]\n)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"composable-nodes-brief-introduction",children:"Composable Nodes (Brief Introduction)"}),"\n",(0,r.jsx)(n.p,{children:"Composable nodes allow multiple nodes to run within a single process, reducing overhead and improving performance. This is achieved using the ComposableNodeContainer."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch_ros.actions import ComposableNodeContainer\nfrom launch_ros.descriptions import ComposableNode\n\n# Create a container for composable nodes\ncontainer = ComposableNodeContainer(\n    name=' perception_container',\n    namespace='',\n    package='rclcpp_components',\n    executable='component_container',\n    composable_node_descriptions=[\n        ComposableNode(\n            package='image_proc',\n            plugin='image_proc::RectifyNode',\n            name='rectify_node',\n            remappings=[\n                ('image', '/camera/image_raw'),\n                ('camera_info', '/camera/camera_info'),\n                ('image_rect', '/camera/image_rect')\n            ]\n        ),\n        ComposableNode(\n            package='image_view',\n            plugin='image_view::ImageViewNode',\n            name='image_view_node',\n            remappings=[\n                ('image', '/camera/image_rect')\n            ]\n        )\n    ]\n)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"section-4-ros-2-parameters",children:"Section 4: ROS 2 Parameters"}),"\n",(0,r.jsx)(n.h3,{id:"parameter-declaration",children:"Parameter Declaration"}),"\n",(0,r.jsx)(n.p,{children:"Parameters in ROS 2 provide a way to configure node behavior at runtime. They can be declared in the node code and accessed through the ROS 2 parameter system."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\n\nclass ParameterExampleNode(Node):\n    def __init__(self):\n        super().__init__('parameter_example_node')\n\n        # Declare parameters with default values and descriptions\n        self.declare_parameter('sensor_range', 10.0)\n        self.declare_parameter('update_frequency', 10)\n        self.declare_parameter('sensor_enabled', True)\n\n        # Access parameter values\n        self.sensor_range = self.get_parameter('sensor_range').value\n        self.update_frequency = self.get_parameter('update_frequency').value\n        self.sensor_enabled = self.get_parameter('sensor_enabled').value\n\n        self.get_logger().info(f'Sensor range: {self.sensor_range}')\n        self.get_logger().info(f'Update frequency: {self.update_frequency}')\n        self.get_logger().info(f'Sensor enabled: {self.sensor_enabled}')\n"})}),"\n",(0,r.jsx)(n.h3,{id:"yaml-parameter-files",children:"YAML Parameter Files"}),"\n",(0,r.jsx)(n.p,{children:"YAML files provide a convenient way to organize and load parameters for multiple nodes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# params.yaml\nlidar_driver:\n  ros__parameters:\n    sensor_range: 30.0\n    update_frequency: 10\n    sensor_enabled: true\n    frame_id: 'lidar_frame'\n\ncamera_driver:\n  ros__parameters:\n    image_width: 640\n    image_height: 480\n    fps: 30\n    exposure_time: 10000\n\nnavigation:\n  ros__parameters:\n    planner_frequency: 5.0\n    controller_frequency: 20.0\n    recovery_enabled: true\n"})}),"\n",(0,r.jsx)(n.p,{children:"Loading parameters from YAML in a launch file:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch_ros.actions import Node\n\nsensor_node = Node(\n    package='sensor_package',\n    executable='lidar_driver',\n    name='lidar_driver',\n    parameters=[\n        'config/lidar_params.yaml',\n        {'sensor_range': 25.0}  # Override specific parameter\n    ]\n)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"getting-and-setting-parameters",children:"Getting and Setting Parameters"}),"\n",(0,r.jsx)(n.p,{children:"Nodes can dynamically get and set parameters at runtime:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ParameterControlNode(Node):\n    def __init__(self):\n        super().__init__('parameter_control_node')\n\n        # Declare parameter\n        self.declare_parameter('control_mode', 'auto')\n\n        # Create timer to periodically check parameters\n        self.timer = self.create_timer(1.0, self.check_parameters)\n\n        # Create service to change parameters\n        self.set_param_service = self.create_service(\n            SetParameters,\n            'set_control_mode',\n            self.set_control_mode_callback\n        )\n\n    def check_parameters(self):\n        current_mode = self.get_parameter('control_mode').value\n        self.get_logger().info(f'Current control mode: {current_mode}')\n\n    def set_control_mode_callback(self, request, response):\n        # Set parameter value\n        self.set_parameters([Parameter('control_mode', Parameter.Type.STRING, 'manual')])\n        response.successful = True\n        response.result = 'Control mode set to manual'\n        return response\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-parameters",children:"Dynamic Parameters"}),"\n",(0,r.jsx)(n.p,{children:"Dynamic parameters allow for runtime configuration changes with validation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from rcl_interfaces.msg import SetParametersResult\n\nclass DynamicParameterNode(Node):\n    def __init__(self):\n        super().__init__('dynamic_parameter_node')\n\n        # Declare parameters with callbacks\n        self.declare_parameter('velocity_limit', 1.0)\n        self.declare_parameter('acceleration_limit', 0.5)\n\n        # Register parameter callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        # Initialize values\n        self.velocity_limit = self.get_parameter('velocity_limit').value\n        self.acceleration_limit = self.get_parameter('acceleration_limit').value\n\n    def parameter_callback(self, params):\n        result = SetParametersResult()\n        result.successful = True\n\n        for param in params:\n            if param.name == 'velocity_limit':\n                if param.value > 5.0:  # Maximum allowed velocity\n                    result.successful = False\n                    result.reason = 'Velocity limit too high'\n                    return result\n                self.velocity_limit = param.value\n            elif param.name == 'acceleration_limit':\n                if param.value > 2.0:  # Maximum allowed acceleration\n                    result.successful = False\n                    result.reason = 'Acceleration limit too high'\n                    return result\n                self.acceleration_limit = param.value\n\n        return result\n"})}),"\n",(0,r.jsx)(n.h2,{id:"section-5-lifecycle-nodes",children:"Section 5: Lifecycle Nodes"}),"\n",(0,r.jsx)(n.h3,{id:"lifecycle-states",children:"Lifecycle States"}),"\n",(0,r.jsx)(n.p,{children:"Lifecycle nodes provide a structured way to manage the state of ROS 2 nodes, enabling better coordination and resource management. The lifecycle state machine includes several states:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unconfigured"}),": Initial state after node creation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inactive"}),": Node configured but not active"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Active"}),": Node running and operational"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Finalized"}),": Node has been shut down and resources released"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error"}),": Node is in an error state"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"transition-system",children:"Transition System"}),"\n",(0,r.jsx)(n.p,{children:"The lifecycle transition system provides a controlled way to move nodes between states:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn\nfrom rclpy.lifecycle import LifecycleState\n\nclass LifecycleExampleNode(LifecycleNode):\n    def __init__(self):\n        super().__init__(\'lifecycle_example_node\')\n        self.get_logger().info(\'Lifecycle node created in unconfigured state\')\n\n    def on_configure(self, state):\n        """Called when transitioning from unconfigured to inactive"""\n        self.get_logger().info(\'Configuring node...\')\n        # Perform configuration tasks\n        self.timer = self.create_timer(1.0, self.timer_callback)\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_activate(self, state):\n        """Called when transitioning from inactive to active"""\n        self.get_logger().info(\'Activating node...\')\n        # Activate the timer\n        self.timer.reset()\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_deactivate(self, state):\n        """Called when transitioning from active to inactive"""\n        self.get_logger().info(\'Deactivating node...\')\n        # Deactivate the timer\n        self.timer.cancel()\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_cleanup(self, state):\n        """Called when transitioning from inactive to unconfigured"""\n        self.get_logger().info(\'Cleaning up node...\')\n        # Clean up resources\n        self.timer.destroy()\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_shutdown(self, state):\n        """Called when transitioning to finalized state"""\n        self.get_logger().info(\'Shutting down node...\')\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_error(self, state):\n        """Called when transitioning to error state"""\n        self.get_logger().info(\'Node in error state\')\n        return TransitionCallbackReturn.SUCCESS\n\n    def timer_callback(self):\n        self.get_logger().info(\'Timer callback in lifecycle node\')\n'})}),"\n",(0,r.jsx)(n.h3,{id:"launch-integration",children:"Launch Integration"}),"\n",(0,r.jsx)(n.p,{children:"Lifecycle nodes can be integrated with launch files to control their states:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch_ros.actions import LifecycleNode\nfrom launch.actions import EmitEvent\nfrom launch.event_handlers import OnProcessStart\nfrom launch.events import matches, Shutdown\n\ndef generate_launch_description():\n    # Define lifecycle node\n    lifecycle_node = LifecycleNode(\n        package='lifecycle_package',\n        executable='lifecycle_node',\n        name='lifecycle_example',\n        namespace='',\n        parameters=['config/lifecycle_params.yaml']\n    )\n\n    # Transition to inactive state\n    to_inactive = EmitEvent(\n        event=matches(LifecycleNode, 'lifecycle_example')\n    )\n\n    # Transition to active state\n    to_active = EmitEvent(\n        event=matches(LifecycleNode, 'lifecycle_example')\n    )\n\n    return LaunchDescription([\n        lifecycle_node,\n        # Additional launch actions for state transitions\n    ])\n"})}),"\n",(0,r.jsx)(n.p,{children:"Using lifecycle manager to control node states:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch_ros.actions import Node\n\n# Launch lifecycle manager\nlifecycle_manager = Node(\n    package='lifecycle',\n    executable='lifecycle_manager',\n    name='lifecycle_manager',\n    parameters=[\n        {'use_sim_time': False},\n        {'autostart_nodes': False}\n    ]\n)\n\n# Launch the lifecycle node\nlifecycle_node = Node(\n    package='lifecycle_package',\n    executable='lifecycle_node',\n    name='lifecycle_example',\n    # Note: This node will be managed by the lifecycle manager\n)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"section-6-integrated-examples",children:"Section 6: Integrated Examples"}),"\n",(0,r.jsx)(n.h3,{id:"multi-node-launch-with-parameters",children:"Multi-Node Launch with Parameters"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example combining multiple nodes with parameters and launch configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# robot_system.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Declare launch arguments\n    robot_name = DeclareLaunchArgument(\n        'robot_name',\n        default_value='robot1',\n        description='Name of the robot'\n    )\n\n    config_file = DeclareLaunchArgument(\n        'config_file',\n        default_value='default_params.yaml',\n        description='Path to parameter file'\n    )\n\n    # Get launch configurations\n    robot_name_config = LaunchConfiguration('robot_name')\n    config_file_config = LaunchConfiguration('config_file')\n\n    # Sensor node\n    sensor_node = Node(\n        package='sensor_package',\n        executable='lidar_driver',\n        name=['lidar_driver_', robot_name_config],\n        parameters=[\n            config_file_config,\n            {'robot_name': robot_name_config}\n        ],\n        remappings=[\n            ('/scan', [robot_name_config, '/scan'])\n        ]\n    )\n\n    # Navigation node\n    navigation_node = Node(\n        package='nav_package',\n        executable='navigation',\n        name=['navigation_', robot_name_config],\n        parameters=[config_file_config],\n        remappings=[\n            ('/cmd_vel', [robot_name_config, '/cmd_vel']),\n            ('/map', [robot_name_config, '/map'])\n        ]\n    )\n\n    # Localization node\n    localization_node = Node(\n        package='localization_package',\n        executable='amcl',\n        name=['localization_', robot_name_config],\n        parameters=[config_file_config],\n        remappings=[\n            ('/scan', [robot_name_config, '/scan']),\n            ('/tf', [robot_name_config, '/tf'])\n        ]\n    )\n\n    return LaunchDescription([\n        robot_name,\n        config_file,\n        sensor_node,\n        navigation_node,\n        localization_node\n    ])\n"})}),"\n",(0,r.jsx)(n.h3,{id:"lifecycle-node-with-transitions",children:"Lifecycle Node with Transitions"}),"\n",(0,r.jsx)(n.p,{children:"Example of a lifecycle node that integrates with parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# lifecycle_sensor.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn\nfrom sensor_msgs.msg import LaserScan\n\nclass LifecycleSensorNode(LifecycleNode):\n    def __init__(self):\n        super().__init__('lifecycle_sensor')\n\n        # Declare parameters\n        self.declare_parameter('sensor_range', 10.0)\n        self.declare_parameter('update_frequency', 10)\n        self.declare_parameter('sensor_enabled', True)\n\n        self.sensor_range = self.get_parameter('sensor_range').value\n        self.update_frequency = self.get_parameter('update_frequency').value\n        self.sensor_enabled = self.get_parameter('sensor_enabled').value\n\n        self.scan_publisher = None\n        self.scan_timer = None\n\n        self.get_logger().info('Lifecycle sensor node created')\n\n    def on_configure(self, state):\n        self.get_logger().info('Configuring lifecycle sensor...')\n\n        # Create publisher\n        self.scan_publisher = self.create_publisher(\n            LaserScan,\n            'scan',\n            10\n        )\n\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_activate(self, state):\n        self.get_logger().info('Activating lifecycle sensor...')\n\n        # Create and start timer\n        self.scan_timer = self.create_timer(\n            1.0 / self.update_frequency,\n            self.publish_scan\n        )\n\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_deactivate(self, state):\n        self.get_logger().info('Deactivating lifecycle sensor...')\n\n        # Cancel timer\n        if self.scan_timer:\n            self.scan_timer.cancel()\n\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_cleanup(self, state):\n        self.get_logger().info('Cleaning up lifecycle sensor...')\n\n        # Destroy publisher and timer\n        if self.scan_publisher:\n            self.scan_publisher.destroy()\n        if self.scan_timer:\n            self.scan_timer.destroy()\n\n        return TransitionCallbackReturn.SUCCESS\n\n    def publish_scan(self):\n        if not self.sensor_enabled:\n            return\n\n        # Create and publish scan message\n        scan_msg = LaserScan()\n        scan_msg.header.stamp = self.get_clock().now().to_msg()\n        scan_msg.header.frame_id = 'laser_frame'\n        scan_msg.angle_min = -1.57  # -90 degrees\n        scan_msg.angle_max = 1.57   # 90 degrees\n        scan_msg.angle_increment = 0.01\n        scan_msg.range_min = 0.1\n        scan_msg.range_max = self.sensor_range\n        scan_msg.ranges = [self.sensor_range / 2.0] * 314  # 314 points\n\n        self.scan_publisher.publish(scan_msg)\n        self.get_logger().info('Published scan message')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = LifecycleSensorNode()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"section-7-exercises",children:"Section 7: Exercises"}),"\n",(0,r.jsx)(n.h3,{id:"exercise-set",children:"Exercise Set"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Write a Multi-Node Launch File"}),": Create a launch file that starts three nodes (sensor, processing, and visualization) with appropriate parameter files and remappings."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implement Parameter YAML"}),": Create a YAML parameter file that configures different settings for a navigation stack including costmap parameters, planner settings, and controller parameters."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Convert Normal Node to Lifecycle Node"}),": Take a simple publisher node from Chapter 3 and convert it to a lifecycle node with proper state management."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Trigger Activation Transitions"}),": Create a script that uses lifecycle services to transition a lifecycle node through different states (configure \u2192 activate \u2192 deactivate \u2192 cleanup)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameter Validation"}),": Implement a node with dynamic parameter validation that ensures parameter values are within acceptable ranges."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Launch with Namespaces"}),": Create a launch file that launches the same node multiple times with different namespaces to avoid naming conflicts."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Composable Node Container"}),": Implement a launch file that uses a ComposableNodeContainer to run multiple simple nodes in a single process."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Launch Arguments"}),": Create a launch file that uses launch arguments to select between different robot configurations (indoor vs outdoor, different parameter sets)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"This chapter covered the essential ROS 2 concepts of launch files, parameters, and lifecycle nodes. These components are crucial for building production-ready robotic systems that require coordinated startup, configurable behavior, and robust state management. The launch system enables orchestrated node startup, parameters provide runtime configuration, and lifecycle nodes offer structured state management."}),"\n",(0,r.jsx)(n.p,{children:"Understanding these concepts is essential for creating scalable and maintainable robotic applications, and they build upon the foundational knowledge from Chapter 3 about Python agents with rclpy. These tools enable the creation of sophisticated robotic systems that can adapt to different operating conditions and manage complex state transitions safely."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);