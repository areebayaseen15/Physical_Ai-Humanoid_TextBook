"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[951],{5173:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"Module1-ROS/Chapter2-Nodes,TopicsService,Action/index","title":"Chapter 2 - Overview","description":"This chapter provides a comprehensive exploration of ROS 2 core communication primitives: Nodes, Topics, Services, and Actions. We will examine the underlying communication patterns including publish/subscribe, request/response, and goal/feedback/result with practical examples. The content includes comprehensive Python code snippets using rclpy to demonstrate the implementation of each concept. All content is optimally chunked for RAG (Retrieval-Augmented Generation) ingestion, with each major concept forming a distinct chunk. The examples adhere strictly to ROS 2 Humble conventions.","source":"@site/docs/Module1-ROS/Chapter2-Nodes,TopicsService,Action/index.md","sourceDirName":"Module1-ROS/Chapter2-Nodes,TopicsService,Action","slug":"/Module1-ROS/Chapter2-Nodes,TopicsService,Action/","permalink":"/docs/Module1-ROS/Chapter2-Nodes,TopicsService,Action/","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module1-ROS/Chapter2-Nodes,TopicsService,Action/index.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"index","title":"Chapter 2 - Overview","sidebar_label":"Chapter 2 Overview","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"2.4 - Actions","permalink":"/docs/Module1-ROS/Chapter2-Nodes,TopicsService,Action/1-2-4-Actions"},"next":{"title":"Chapter 3: Python Agents with rclpy","permalink":"/docs/category/chapter-3-python-agents-with-rclpy"}}');var t=i(4848),o=i(8453);const r={id:"index",title:"Chapter 2 - Overview",sidebar_label:"Chapter 2 Overview",sidebar_position:4},c="Chapter 2: Overview",l={},a=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"2.1 ROS 2 Nodes: The Computational Units",id:"21-ros-2-nodes-the-computational-units",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Basic Node Implementation",id:"basic-node-implementation",level:3},{value:"2.2 Topics: Asynchronous Data Streaming (Publish/Subscribe)",id:"22-topics-asynchronous-data-streaming-publishsubscribe",level:2},{value:"Key Concepts",id:"key-concepts-1",level:3},{value:"Basic Publisher Implementation",id:"basic-publisher-implementation",level:3},{value:"2.3 Services: Synchronous Request/Response",id:"23-services-synchronous-requestresponse",level:2},{value:"Key Concepts",id:"key-concepts-2",level:3},{value:"Basic Service Server Implementation",id:"basic-service-server-implementation",level:3},{value:"2.4 Actions: Asynchronous Goal-Oriented Tasks",id:"24-actions-asynchronous-goal-oriented-tasks",level:2},{value:"Key Concepts",id:"key-concepts-3",level:3},{value:"Basic Action Server Implementation",id:"basic-action-server-implementation",level:3},{value:"Recommended Exercises",id:"recommended-exercises",level:2},{value:"Exercise 2.1: ROS 2 Talker-Listener with Custom Message and QoS",id:"exercise-21-ros-2-talker-listener-with-custom-message-and-qos",level:3},{value:"Exercise 2.2: Simple Robot Control Service",id:"exercise-22-simple-robot-control-service",level:3},{value:"Exercise 2.3: &quot;Move to Goal&quot; Action with Cancellation",id:"exercise-23-move-to-goal-action-with-cancellation",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-2-overview",children:"Chapter 2: Overview"})}),"\n",(0,t.jsxs)(n.p,{children:["This chapter provides a comprehensive exploration of ROS 2 core communication primitives: Nodes, Topics, Services, and Actions. We will examine the underlying communication patterns including publish/subscribe, request/response, and goal/feedback/result with practical examples. The content includes comprehensive Python code snippets using ",(0,t.jsx)(n.code,{children:"rclpy"})," to demonstrate the implementation of each concept. All content is optimally chunked for RAG (Retrieval-Augmented Generation) ingestion, with each major concept forming a distinct chunk. The examples adhere strictly to ROS 2 Humble conventions."]}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand and implement ROS 2 nodes with proper lifecycle management"}),"\n",(0,t.jsx)(n.li,{children:"Create publishers and subscribers for asynchronous communication"}),"\n",(0,t.jsx)(n.li,{children:"Implement service servers and clients for synchronous communication"}),"\n",(0,t.jsx)(n.li,{children:"Design action servers and clients for long-running tasks with feedback"}),"\n",(0,t.jsx)(n.li,{children:"Apply Quality of Service (QoS) policies appropriately"}),"\n",(0,t.jsx)(n.li,{children:"Define and use custom message, service, and action types"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"21-ros-2-nodes-the-computational-units",children:"2.1 ROS 2 Nodes: The Computational Units"}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROS 2 Node"}),": An executable process that performs computation within the ROS 2 system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"rclpy.init()"})}),": Initializes the ROS 2 client library"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"rclpy.create_node()"})}),": Creates a new ROS 2 node instance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"rclpy.spin()"})}),": Keeps the node alive and processes callbacks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"rclpy.shutdown()"})}),": Shuts down the ROS 2 client library"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"basic-node-implementation",children:"Basic Node Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass MinimalNode(Node):\n    def __init__(self):\n        super().__init__('minimal_node')\n        self.get_logger().info('Minimal Node initialized.')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MinimalNode()\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Minimal Node shutting down.')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"22-topics-asynchronous-data-streaming-publishsubscribe",children:"2.2 Topics: Asynchronous Data Streaming (Publish/Subscribe)"}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts-1",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROS 2 Topics"}),": Named buses for passing messages between nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Publisher"}),": Node that sends messages to a topic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subscriber"}),": Node that receives messages from a topic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Publish/Subscribe Pattern"}),": Asynchronous communication model"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"basic-publisher-implementation",children:"Basic Publisher Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello ROS 2: {self.i}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"23-services-synchronous-requestresponse",children:"2.3 Services: Synchronous Request/Response"}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts-2",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROS 2 Services"}),": Synchronous request/response communication pattern"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Server"}),": Node that provides a service"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Client"}),": Node that requests a service"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Request/Response Pattern"}),": Synchronous communication model"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"basic-service-server-implementation",children:"Basic Service Server Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts # Standard service type\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n        self.get_logger().info('Add Two Ints Service Ready.')\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}, sum={response.sum}')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service = MinimalService()\n    rclpy.spin(minimal_service)\n    minimal_service.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"24-actions-asynchronous-goal-oriented-tasks",children:"2.4 Actions: Asynchronous Goal-Oriented Tasks"}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts-3",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROS 2 Actions"}),": Asynchronous goal/feedback/result communication pattern"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action Server"}),": Node that executes long-running tasks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action Client"}),": Node that sends goals and receives feedback/results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal"}),": Request sent to an action server"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback"}),": Periodic updates during task execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result"}),": Final outcome of the task"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"basic-action-server-implementation",children:"Basic Action Server Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer, ActionClient, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\n\n# Assuming custom action type in my_robot_controller/action/Fibonacci.action\n# int32 order\n# ---\n# int32[] sequence\n# ---\n# int32[] partial_sequence\nfrom my_robot_controller.action import Fibonacci # Import custom action\n\nimport time\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=ReentrantCallbackGroup() # Use reentrant group for concurrent callbacks\n        )\n        self.get_logger().info('Fibonacci Action Server Ready.')\n\n    def goal_callback(self, goal_request):\n        self.get_logger().info(f'Received goal request with order {goal_request.order}')\n        # Validate goal request\n        if goal_request.order > 1000: # Example validation\n            self.get_logger().warn('Goal order too high, rejecting.')\n            return GoalResponse.REJECT\n        return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        self.get_logger().info('Goal accepted, executing...')\n        # Start a new thread for execution to avoid blocking the main executor\n        # In a real robot, this would offload to a control loop\n        import threading\n        thread = threading.Thread(target=self.execute_callback, args=(goal_handle,))\n        thread.start()\n\n    def cancel_callback(self, goal_handle):\n        self.get_logger().info('Received cancel request')\n        # Implement logic to stop the long-running task if possible\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.partial_sequence = [0, 1]\n\n        # Fibonacci sequence generation\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled by client.')\n                return Fibonacci.Result()\n\n            feedback_msg.partial_sequence.append(\n                feedback_msg.partial_sequence[i] + feedback_msg.partial_sequence[i-1]\n            )\n            self.get_logger().info(f'Feedback: {feedback_msg.partial_sequence[-1]}')\n            goal_handle.publish_feedback(feedback_msg)\n            time.sleep(0.5) # Simulate work\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.partial_sequence\n        self.get_logger().info('Goal succeeded.')\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    executor = MultiThreadedExecutor()\n    action_server_node = FibonacciActionServer()\n    executor.add_node(action_server_node)\n\n    try:\n        executor.spin()\n    except KeyboardInterrupt:\n        pass\n    finally:\n        executor.shutdown()\n        action_server_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"recommended-exercises",children:"Recommended Exercises"}),"\n",(0,t.jsx)(n.h3,{id:"exercise-21-ros-2-talker-listener-with-custom-message-and-qos",children:"Exercise 2.1: ROS 2 Talker-Listener with Custom Message and QoS"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task:"})," Create a custom message type (e.g., ",(0,t.jsx)(n.code,{children:"RobotPose"})," with ",(0,t.jsx)(n.code,{children:"float32 x, y, theta"}),"). Implement a Python publisher that sends ",(0,t.jsx)(n.code,{children:"RobotPose"})," messages and a Python subscriber that receives and logs them. Experiment with different QoS settings (e.g., ",(0,t.jsx)(n.code,{children:"ReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE"})," vs. ",(0,t.jsx)(n.code,{children:"ReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT"}),") and observe their impact on message delivery under simulated lossy conditions."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"exercise-22-simple-robot-control-service",children:"Exercise 2.2: Simple Robot Control Service"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task:"})," Define a custom service (",(0,t.jsx)(n.code,{children:"SetSpeed.srv"})," with a ",(0,t.jsx)(n.code,{children:"float32 speed"})," request and a ",(0,t.jsx)(n.code,{children:"bool success"})," response). Implement a Python service server that accepts a speed command and simply logs it, returning ",(0,t.jsx)(n.code,{children:"True"}),". Implement a Python service client that sends speed requests and prints the success status."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"exercise-23-move-to-goal-action-with-cancellation",children:'Exercise 2.3: "Move to Goal" Action with Cancellation'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task:"})," Define a custom action (",(0,t.jsx)(n.code,{children:"MoveToGoal.action"})," with ",(0,t.jsx)(n.code,{children:"float32 target_x, target_y"})," as goal, ",(0,t.jsx)(n.code,{children:"bool success, float32 final_x, float32 final_y"})," as result, and ",(0,t.jsx)(n.code,{children:"float32 current_x, float32 current_y, float32 distance_to_goal"})," as feedback). Implement a Python action server that simulates moving to the goal, sends continuous feedback, and allows for preemption/cancellation. Implement a Python action client that sends a goal, displays feedback, and demonstrates how to send a cancellation request."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);