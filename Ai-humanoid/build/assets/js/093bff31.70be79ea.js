"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[881],{6763:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/advanced-scene-creation","title":"advanced scene creation","description":"Advanced scene creation in Isaac Sim involves sophisticated techniques for creating complex, dynamic, and realistic environments that go beyond basic static scenes. This chapter explores procedural generation, dynamic elements, environmental effects, and multi-robot scenarios that enable comprehensive testing of robotic systems under varied and challenging conditions.","source":"@site/docs/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/advanced-scene-creation.md","sourceDirName":"Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation","slug":"/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/advanced-scene-creation","permalink":"/docs/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/advanced-scene-creation","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/advanced-scene-creation.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"id":"advanced-scene-creation","title":"advanced scene creation","sidebar_label":"advanced scene creation","sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation","permalink":"/docs/category/chapter-3-nvidia-isaac-sim-photorealistic-simulation-and-synthetic-data-generation"},"next":{"title":"building simulation environments","permalink":"/docs/Module3-AI-Robot-Brain/Chapter3-NVIDIA Isaac Sim Photorealistic simulation and synthetic data generation/building-simulation-environments"}}');var a=t(4848),r=t(8453);const o={id:"advanced-scene-creation",title:"advanced scene creation",sidebar_label:"advanced scene creation",sidebar_position:0},s="3.2.5 Advanced Scene Creation",c={},l=[{value:"Procedural Environment Generation",id:"procedural-environment-generation",level:2},{value:"Procedural Architecture Generation",id:"procedural-architecture-generation",level:3},{value:"Procedural Urban Environment Generation",id:"procedural-urban-environment-generation",level:3},{value:"Procedural Nature Environment Generation",id:"procedural-nature-environment-generation",level:3},{value:"Dynamic Obstacles and Actors",id:"dynamic-obstacles-and-actors",level:2},{value:"Animated Characters and Pedestrians",id:"animated-characters-and-pedestrians",level:3},{value:"Moving Vehicles",id:"moving-vehicles",level:3},{value:"Interactive Objects",id:"interactive-objects",level:3},{value:"Environmental Effects and Weather Simulation",id:"environmental-effects-and-weather-simulation",level:2},{value:"Weather System Implementation",id:"weather-system-implementation",level:3},{value:"Time-of-Day Simulation",id:"time-of-day-simulation",level:3},{value:"Multi-Robot Simulation Scenarios",id:"multi-robot-simulation-scenarios",level:2},{value:"Coordinated Multi-Robot Environments",id:"coordinated-multi-robot-environments",level:3},{value:"Communication and Coordination Simulation",id:"communication-and-coordination-simulation",level:3},{value:"Scene Optimization and Performance",id:"scene-optimization-and-performance",level:2},{value:"Level of Detail (LOD) Systems",id:"level-of-detail-lod-systems",level:3},{value:"Occlusion Culling",id:"occlusion-culling",level:3},{value:"Multi-Resolution Shading",id:"multi-resolution-shading",level:3},{value:"Advanced Scene Management",id:"advanced-scene-management",level:2},{value:"Scene Streaming",id:"scene-streaming",level:3},{value:"Scene Variants",id:"scene-variants",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance Optimization Best Practices",id:"performance-optimization-best-practices",level:3},{value:"Realism Best Practices",id:"realism-best-practices",level:3},{value:"Collaboration Best Practices",id:"collaboration-best-practices",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"325-advanced-scene-creation",children:"3.2.5 Advanced Scene Creation"})}),"\n",(0,a.jsx)(n.p,{children:"Advanced scene creation in Isaac Sim involves sophisticated techniques for creating complex, dynamic, and realistic environments that go beyond basic static scenes. This chapter explores procedural generation, dynamic elements, environmental effects, and multi-robot scenarios that enable comprehensive testing of robotic systems under varied and challenging conditions."}),"\n",(0,a.jsx)(n.h2,{id:"procedural-environment-generation",children:"Procedural Environment Generation"}),"\n",(0,a.jsx)(n.p,{children:"Procedural generation enables the automatic creation of complex environments with minimal manual input, allowing for rapid generation of diverse scenarios for training and testing."}),"\n",(0,a.jsx)(n.h3,{id:"procedural-architecture-generation",children:"Procedural Architecture Generation"}),"\n",(0,a.jsx)(n.p,{children:"Creating complex architectural environments procedurally involves generating buildings, rooms, and structural elements algorithmically:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Example: Procedural building generation\nfrom pxr import Usd, UsdGeom, Gf\nimport random\n\ndef create_procedural_building(stage, building_path, width, depth, height, floors=3):\n    """Create a procedurally generated building"""\n\n    # Create main building structure\n    building_prim = stage.DefinePrim(building_path, "Xform")\n    building_xform = UsdGeom.Xformable(building_prim)\n\n    # Generate floors\n    for floor in range(floors):\n        floor_height = floor * 3.0  # Standard floor height\n        floor_path = f"{building_path}/Floor_{floor}"\n\n        # Create floor structure\n        create_floor_structure(stage, floor_path, width, depth, floor_height)\n\n    # Add architectural details\n    add_windows_and_doors(stage, building_path, width, depth, height, floors)\n    add_roof(stage, building_path, width, depth, floors)\n\ndef create_floor_structure(stage, floor_path, width, depth, height):\n    """Create the basic structure of a floor"""\n\n    # Create floor slab\n    floor_slab_path = f"{floor_path}/Slab"\n    floor_slab = UsdGeom.Mesh.Define(stage, floor_slab_path)\n\n    # Define floor geometry\n    points = [\n        Gf.Vec3f(-width/2, height, -depth/2),\n        Gf.Vec3f(width/2, height, -depth/2),\n        Gf.Vec3f(width/2, height, depth/2),\n        Gf.Vec3f(-width/2, height, depth/2)\n    ]\n    floor_slab.CreatePointsAttr(points)\n    floor_slab.CreateFaceVertexIndicesAttr([0, 1, 2, 3])\n    floor_slab.CreateFaceVertexCountsAttr([4])\n\n    # Create walls\n    create_room_layout(stage, floor_path, width, depth, height)\n\ndef create_room_layout(stage, floor_path, width, depth, floor_height):\n    """Create a procedural room layout within the floor"""\n\n    # Define room sizes and positions\n    room_width = width * random.uniform(0.6, 0.8)\n    room_depth = depth * random.uniform(0.6, 0.8)\n    room_x = random.uniform(-width/2 + room_width/2, width/2 - room_width/2)\n    room_z = random.uniform(-depth/2 + room_depth/2, depth/2 - room_depth/2)\n\n    # Create room structure\n    room_path = f"{floor_path}/Room_0"\n    room_prim = stage.DefinePrim(room_path, "Xform")\n\n    # Create walls for the room\n    wall_height = 2.5  # Standard wall height\n    create_room_walls(stage, f"{room_path}/Walls",\n                      room_x, room_z, room_width, room_depth,\n                      floor_height, wall_height)\n\ndef create_room_walls(stage, walls_path, center_x, center_z, width, depth, base_height, wall_height):\n    """Create walls for a room"""\n\n    wall_thickness = 0.2\n\n    # Define wall segments\n    wall_segments = [\n        # Front wall\n        (center_x, center_z + depth/2, width, wall_thickness, base_height, wall_height),\n        # Back wall\n        (center_x, center_z - depth/2, width, wall_thickness, base_height, wall_height),\n        # Left wall\n        (center_x - width/2, center_z, wall_thickness, depth, base_height, wall_height),\n        # Right wall\n        (center_x + width/2, center_z, wall_thickness, depth, base_height, wall_height)\n    ]\n\n    for i, (x, z, w, d, bh, wh) in enumerate(wall_segments):\n        wall_path = f"{walls_path}/Wall_{i}"\n        wall = UsdGeom.Cube.Define(stage, wall_path)\n        wall.GetSizeAttr().Set(1.0)\n\n        xform = UsdGeom.Xformable(wall.GetPrim())\n        xform.AddTranslateOp().Set(Gf.Vec3f(x, bh + wh/2, z))\n        xform.AddScaleOp().Set(Gf.Vec3f(w, wh, d))\n'})}),"\n",(0,a.jsx)(n.h3,{id:"procedural-urban-environment-generation",children:"Procedural Urban Environment Generation"}),"\n",(0,a.jsx)(n.p,{children:"Creating realistic urban environments involves generating streets, buildings, and infrastructure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_procedural_city(stage, city_path, grid_size=(10, 10), block_size=50.0):\n    """Create a procedural city with streets and buildings"""\n\n    city_prim = stage.DefinePrim(city_path, "Xform")\n\n    # Create street grid\n    create_street_grid(stage, f"{city_path}/Streets", grid_size, block_size)\n\n    # Place buildings in blocks\n    for i in range(grid_size[0]):\n        for j in range(grid_size[1]):\n            if not is_street_location(i, j):  # Check if this is a building location\n                building_path = f"{city_path}/Building_{i}_{j}"\n                building_width = random.uniform(20, 40)\n                building_depth = random.uniform(20, 40)\n                building_height = random.uniform(10, 50)\n\n                create_procedural_building(\n                    stage, building_path,\n                    building_width, building_depth, building_height,\n                    floors=int(building_height / 3)\n                )\n\ndef create_street_grid(stage, streets_path, grid_size, block_size):\n    """Create a grid of streets"""\n\n    street_width = 8.0\n    sidewalk_width = 3.0\n\n    for i in range(grid_size[0] + 1):\n        # Horizontal streets\n        street_path = f"{streets_path}/Street_H_{i}"\n        create_street_segment(stage, street_path,\n                             start_pos=(-grid_size[1]*block_size/2, 0, i*block_size - grid_size[0]*block_size/2),\n                             end_pos=(grid_size[1]*block_size/2, 0, i*block_size - grid_size[0]*block_size/2),\n                             width=street_width)\n\n    for j in range(grid_size[1] + 1):\n        # Vertical streets\n        street_path = f"{streets_path}/Street_V_{j}"\n        create_street_segment(stage, street_path,\n                             start_pos=(j*block_size - grid_size[1]*block_size/2, 0, -grid_size[0]*block_size/2),\n                             end_pos=(j*block_size - grid_size[1]*block_size/2, 0, grid_size[0]*block_size/2),\n                             width=street_width)\n\ndef create_street_segment(stage, path, start_pos, end_pos, width):\n    """Create a street segment"""\n\n    # Calculate street dimensions\n    length = ((end_pos[0] - start_pos[0])**2 + (end_pos[2] - start_pos[2])**2)**0.5\n\n    street = UsdGeom.Cube.Define(stage, path)\n    street.GetSizeAttr().Set(1.0)\n\n    center_x = (start_pos[0] + end_pos[0]) / 2\n    center_z = (start_pos[2] + end_pos[2]) / 2\n\n    xform = UsdGeom.Xformable(street.GetPrim())\n    xform.AddTranslateOp().Set(Gf.Vec3f(center_x, 0.05, center_z))  # Slightly above ground\n    xform.AddScaleOp().Set(Gf.Vec3f(length, 0.1, width))\n'})}),"\n",(0,a.jsx)(n.h3,{id:"procedural-nature-environment-generation",children:"Procedural Nature Environment Generation"}),"\n",(0,a.jsx)(n.p,{children:"Creating natural environments with terrain, vegetation, and water features:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_procedural_terrain(stage, terrain_path, size=(100, 100), resolution=1.0):\n    """Create a procedural terrain with elevation variations"""\n\n    import numpy as np\n\n    # Generate height map using Perlin noise\n    height_map = generate_perlin_heightmap(size[0], size[1], resolution)\n\n    # Create terrain geometry\n    terrain = UsdGeom.Mesh.Define(stage, terrain_path)\n\n    # Generate vertices and faces based on height map\n    vertices = []\n    faces = []\n    face_counts = []\n\n    width_samples = int(size[0] / resolution)\n    depth_samples = int(size[1] / resolution)\n\n    for z in range(depth_samples):\n        for x in range(width_samples):\n            y = height_map[x, z]\n            vertices.append(Gf.Vec3f(x * resolution, y, z * resolution))\n\n    # Generate faces (triangles)\n    for z in range(depth_samples - 1):\n        for x in range(width_samples - 1):\n            # First triangle\n            idx0 = z * width_samples + x\n            idx1 = z * width_samples + x + 1\n            idx2 = (z + 1) * width_samples + x\n            faces.extend([idx0, idx1, idx2])\n\n            # Second triangle\n            idx3 = (z + 1) * width_samples + x + 1\n            faces.extend([idx1, idx3, idx2])\n\n            face_counts.extend([3, 3])\n\n    terrain.CreatePointsAttr(vertices)\n    terrain.CreateFaceVertexIndicesAttr(faces)\n    terrain.CreateFaceVertexCountsAttr(face_counts)\n\ndef generate_procedural_forest(stage, forest_path, terrain_size, tree_density=0.01):\n    """Generate a forest with procedurally placed trees"""\n\n    import random\n    import math\n\n    num_trees = int(terrain_size[0] * terrain_size[1] * tree_density)\n\n    for i in range(num_trees):\n        # Random position within terrain\n        x = random.uniform(0, terrain_size[0])\n        z = random.uniform(0, terrain_size[1])\n\n        # Create tree at position\n        tree_path = f"{forest_path}/Tree_{i}"\n        tree_type = random.choice(["oak", "pine", "birch"])\n\n        create_procedural_tree(stage, tree_path, tree_type, Gf.Vec3f(x, 0, z))\n\ndef create_procedural_tree(stage, tree_path, tree_type, position):\n    """Create a procedurally generated tree"""\n\n    tree_prim = stage.DefinePrim(tree_path, "Xform")\n    xform = UsdGeom.Xformable(tree_prim)\n    xform.AddTranslateOp().Set(position)\n\n    # Create trunk\n    trunk_height = random.uniform(5, 15)\n    trunk_radius = random.uniform(0.3, 0.8)\n\n    trunk = UsdGeom.Cylinder.Define(stage, f"{tree_path}/Trunk")\n    trunk.GetRadiusAttr().Set(trunk_radius)\n    trunk.GetHeightAttr().Set(trunk_height)\n\n    trunk_xform = UsdGeom.Xformable(trunk.GetPrim())\n    trunk_xform.AddTranslateOp().Set(Gf.Vec3f(0, trunk_height/2, 0))\n\n    # Create foliage based on tree type\n    if tree_type == "oak":\n        create_oak_foliage(stage, f"{tree_path}/Foliage", trunk_height)\n    elif tree_type == "pine":\n        create_pine_foliage(stage, f"{tree_path}/Foliage", trunk_height)\n    else:  # birch\n        create_birch_foliage(stage, f"{tree_path}/Foliage", trunk_height)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"dynamic-obstacles-and-actors",children:"Dynamic Obstacles and Actors"}),"\n",(0,a.jsx)(n.p,{children:"Dynamic elements add realism and complexity to simulation environments, requiring proper physics configuration and behavior programming."}),"\n",(0,a.jsx)(n.h3,{id:"animated-characters-and-pedestrians",children:"Animated Characters and Pedestrians"}),"\n",(0,a.jsx)(n.p,{children:"Creating realistic human-like characters that interact with the environment:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_animated_pedestrian(stage, ped_path, start_pos, walk_path=None):\n    """Create an animated pedestrian character"""\n\n    # Create skeleton/structure\n    ped_prim = stage.DefinePrim(ped_path, "Xform")\n    xform = UsdGeom.Xformable(ped_prim)\n    xform.AddTranslateOp().Set(start_pos)\n\n    # Create body parts\n    create_humanoid_body(stage, ped_path)\n\n    # Add physics properties for interaction\n    configure_pedestrian_physics(stage, ped_path)\n\n    # If path specified, create animation along path\n    if walk_path:\n        create_path_animation(stage, ped_path, walk_path)\n\ndef create_humanoid_body(stage, ped_path):\n    """Create basic humanoid body structure"""\n\n    # Create body segments\n    body_parts = {\n        "pelvis": (0, 0.8, 0),\n        "torso": (0, 1.2, 0),\n        "head": (0, 1.7, 0),\n        "upper_leg_left": (-0.15, 0.6, 0),\n        "lower_leg_left": (-0.15, 0.2, 0),\n        "upper_leg_right": (0.15, 0.6, 0),\n        "lower_leg_right": (0.15, 0.2, 0),\n        "upper_arm_left": (-0.3, 1.3, 0),\n        "lower_arm_left": (-0.5, 1.1, 0),\n        "upper_arm_right": (0.3, 1.3, 0),\n        "lower_arm_right": (0.5, 1.1, 0)\n    }\n\n    for part_name, pos in body_parts.items():\n        part_path = f"{ped_path}/{part_name}"\n\n        if "leg" in part_name or "arm" in part_name:\n            # Create limb as capsule\n            limb = UsdGeom.Capsule.Define(stage, part_path)\n            limb.GetRadiusAttr().Set(0.08)\n            limb.GetHeightAttr().Set(0.4)\n        else:\n            # Create body part as box or sphere\n            if part_name == "head":\n                body_part = UsdGeom.Sphere.Define(stage, part_path)\n                body_part.GetRadiusAttr().Set(0.12)\n            else:\n                body_part = UsdGeom.Capsule.Define(stage, part_path)\n                body_part.GetRadiusAttr().Set(0.15 if part_name == "torso" else 0.12)\n                body_part.GetHeightAttr().Set(0.4 if part_name == "torso" else 0.3)\n\n        # Position the body part\n        part_xform = UsdGeom.Xformable(body_part.GetPrim())\n        part_xform.AddTranslateOp().Set(Gf.Vec3f(*pos))\n\ndef create_path_animation(stage, ped_path, path_points):\n    """Create animation for pedestrian following a path"""\n\n    # This would typically use Isaac Sim\'s animation system\n    # or be implemented through a ROS node that controls the pedestrian\n    pass\n'})}),"\n",(0,a.jsx)(n.h3,{id:"moving-vehicles",children:"Moving Vehicles"}),"\n",(0,a.jsx)(n.p,{children:"Creating realistic vehicle models with proper physics and control:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_procedural_vehicle(stage, vehicle_path, vehicle_type="car"):\n    """Create a procedural vehicle with physics properties"""\n\n    vehicle_prim = stage.DefinePrim(vehicle_path, "Xform")\n    xform = UsdGeom.Xformable(vehicle_prim)\n\n    if vehicle_type == "car":\n        create_car_structure(stage, vehicle_path)\n    elif vehicle_type == "truck":\n        create_truck_structure(stage, vehicle_path)\n    elif vehicle_type == "bus":\n        create_bus_structure(stage, vehicle_path)\n\n    # Add vehicle-specific physics\n    configure_vehicle_physics(stage, vehicle_path, vehicle_type)\n\ndef create_car_structure(stage, car_path):\n    """Create basic car structure"""\n\n    # Create chassis\n    chassis = UsdGeom.Cube.Define(stage, f"{car_path}/Chassis")\n    chassis.GetSizeAttr().Set(1.0)\n\n    chassis_xform = UsdGeom.Xformable(chassis.GetPrim())\n    chassis_xform.AddScaleOp().Set(Gf.Vec3f(4.0, 1.5, 2.0))  # Length, height, width\n\n    # Create wheels\n    wheel_positions = [\n        (1.5, 0.4, 0.9),   # Front right\n        (1.5, 0.4, -0.9),  # Front left\n        (-1.5, 0.4, 0.9),  # Rear right\n        (-1.5, 0.4, -0.9)  # Rear left\n    ]\n\n    for i, pos in enumerate(wheel_positions):\n        wheel_path = f"{car_path}/Wheel_{i}"\n        wheel = UsdGeom.Cylinder.Define(stage, wheel_path)\n        wheel.GetRadiusAttr().Set(0.35)\n        wheel.GetHeightAttr().Set(0.2)\n\n        wheel_xform = UsdGeom.Xformable(wheel.GetPrim())\n        wheel_xform.AddTranslateOp().Set(Gf.Vec3f(*pos))\n        wheel_xform.AddRotateYOp().Set(90)  # Wheels are oriented vertically\n\ndef configure_vehicle_physics(stage, vehicle_path, vehicle_type):\n    """Configure physics properties for vehicle"""\n\n    # Apply vehicle-specific physics properties\n    vehicle_mass = {"car": 1500, "truck": 3000, "bus": 12000}[vehicle_type]\n\n    # Configure chassis\n    chassis_path = f"{vehicle_path}/Chassis"\n    configure_rigid_body(stage, chassis_path, mass=vehicle_mass*0.7)  # 70% of mass on chassis\n\n    # Configure wheels with appropriate properties\n    for i in range(4):\n        wheel_path = f"{vehicle_path}/Wheel_{i}"\n        configure_rigid_body(stage, wheel_path, mass=vehicle_mass*0.05)  # 5% per wheel\n\n    # Add joint constraints to simulate suspension and steering\n    add_vehicle_joints(stage, vehicle_path, vehicle_type)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"interactive-objects",children:"Interactive Objects"}),"\n",(0,a.jsx)(n.p,{children:"Creating objects that respond to robot interaction:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_interactive_object(stage, obj_path, obj_type, position):\n    """Create an interactive object that can be manipulated by robots"""\n\n    obj_prim = stage.DefinePrim(obj_path, "Xform")\n    xform = UsdGeom.Xformable(obj_prim)\n    xform.AddTranslateOp().Set(position)\n\n    # Create object geometry based on type\n    if obj_type == "box":\n        geometry = UsdGeom.Cube.Define(stage, f"{obj_path}/Geometry")\n        geometry.GetSizeAttr().Set(0.3)\n        mass = 1.0\n    elif obj_type == "cylinder":\n        geometry = UsdGeom.Cylinder.Define(stage, f"{obj_path}/Geometry")\n        geometry.GetRadiusAttr().Set(0.15)\n        geometry.GetHeightAttr().Set(0.3)\n        mass = 0.8\n    elif obj_type == "sphere":\n        geometry = UsdGeom.Sphere.Define(stage, f"{obj_path}/Geometry")\n        geometry.GetRadiusAttr().Set(0.15)\n        mass = 0.6\n    elif obj_type == "bottle":\n        # Create a bottle shape with cylinder body and smaller neck\n        create_bottle_shape(stage, f"{obj_path}/Geometry")\n        mass = 0.3\n\n    # Configure physics properties\n    configure_rigid_body(stage, f"{obj_path}/Geometry", mass=mass)\n\n    # Add grasp affordances (for manipulation planning)\n    add_grasp_points(stage, obj_path, obj_type)\n\ndef create_bottle_shape(stage, bottle_path):\n    """Create a bottle-shaped object"""\n\n    # Bottle body (cylinder)\n    body = UsdGeom.Cylinder.Define(stage, f"{bottle_path}/Body")\n    body.GetRadiusAttr().Set(0.06)\n    body.GetHeightAttr().Set(0.25)\n\n    # Bottle neck (smaller cylinder)\n    neck = UsdGeom.Cylinder.Define(stage, f"{bottle_path}/Neck")\n    neck.GetRadiusAttr().Set(0.02)\n    neck.GetHeightAttr().Set(0.05)\n\n    neck_xform = UsdGeom.Xformable(neck.GetPrim())\n    neck_xform.AddTranslateOp().Set(Gf.Vec3f(0, 0.15, 0))  # Position neck on top of body\n\ndef add_grasp_points(stage, obj_path, obj_type):\n    """Add grasp affordance points to an object"""\n\n    # Define typical grasp points for different object types\n    grasp_points = {\n        "box": [\n            Gf.Vec3f(0.15, 0.15, 0.15),   # Corner grasp\n            Gf.Vec3f(0, 0.15, 0.15),      # Side grasp\n            Gf.Vec3f(0, 0.15, 0)          # Center grasp\n        ],\n        "cylinder": [\n            Gf.Vec3f(0, 0.15, 0.15),      # Side grasp\n            Gf.Vec3f(0.15, 0.15, 0),      # Radial grasp\n            Gf.Vec3f(0, 0.25, 0)          # Top grasp\n        ],\n        "sphere": [\n            Gf.Vec3f(0.15, 0, 0),         # Various points around sphere\n            Gf.Vec3f(0, 0.15, 0),\n            Gf.Vec3f(0, 0, 0.15)\n        ],\n        "bottle": [\n            Gf.Vec3f(0, 0.2, 0.06),       # Neck grasp\n            Gf.Vec3f(0.06, 0.1, 0),       # Body grasp\n            Gf.Vec3f(0, 0.1, 0.06)        # Side body grasp\n        ]\n    }\n\n    for i, point in enumerate(grasp_points.get(obj_type, [])):\n        grasp_point = UsdGeom.Xform.Define(stage, f"{obj_path}/GraspPoint_{i}")\n        grasp_xform = UsdGeom.Xformable(grasp_point.GetPrim())\n        grasp_xform.AddTranslateOp().Set(point)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"environmental-effects-and-weather-simulation",children:"Environmental Effects and Weather Simulation"}),"\n",(0,a.jsx)(n.p,{children:"Creating realistic environmental conditions that affect both physics and sensor simulation."}),"\n",(0,a.jsx)(n.h3,{id:"weather-system-implementation",children:"Weather System Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_weather_system(stage, weather_path, weather_type="clear"):\n    """Create a weather system that affects the environment"""\n\n    weather_prim = stage.DefinePrim(weather_path, "Xform")\n\n    if weather_type == "rain":\n        create_rain_system(stage, f"{weather_path}/Rain")\n    elif weather_type == "fog":\n        create_fog_system(stage, f"{weather_path}/Fog")\n    elif weather_type == "snow":\n        create_snow_system(stage, f"{weather_path}/Snow")\n    elif weather_type == "night":\n        create_night_system(stage, f"{weather_path}/Night")\n    else:  # clear/sunny\n        create_clear_system(stage, f"{weather_path}/Clear")\n\ndef create_rain_system(stage, rain_path):\n    """Create a rain weather effect"""\n\n    # Create atmospheric effects\n    create_atmospheric_fog(stage, f"{rain_path}/Atmosphere", density=0.05)\n\n    # Add rain particle system (conceptual - would use Isaac Sim\'s particle system)\n    create_rain_particles(stage, f"{rain_path}/Particles")\n\n    # Adjust lighting for overcast conditions\n    adjust_ambient_lighting(stage, f"{rain_path}/Lighting",\n                           intensity=0.3, color=(0.8, 0.8, 1.0))\n\n    # Add wetness effects to surfaces\n    apply_wetness_effects(stage, f"{rain_path}/Wetness")\n\ndef create_fog_system(stage, fog_path):\n    """Create fog/haze effects"""\n\n    # Create volume fog\n    fog_volume = UsdGeom.Cube.Define(stage, f"{fog_path}/Volume")\n    fog_volume.GetSizeAttr().Set(100.0)  # Large volume for scene fog\n\n    # Configure fog properties\n    # This would involve material properties and volume rendering in Isaac Sim\n    configure_fog_properties(stage, f"{fog_path}/Volume",\n                            density=0.02, color=(0.7, 0.7, 0.7, 0.3))\n\ndef adjust_ambient_lighting(stage, lighting_path, intensity=1.0, color=(1, 1, 1)):\n    """Adjust ambient lighting for weather conditions"""\n\n    # Create or modify dome light for ambient lighting\n    dome_light = UsdGeom.DomeLight.Define(stage, f"{lighting_path}/Dome")\n    dome_light.GetIntensityAttr().Set(intensity)\n    dome_light.GetColorAttr().Set(Gf.Vec3f(*color))\n\ndef apply_wetness_effects(stage, wetness_path):\n    """Apply wetness effects to surfaces"""\n\n    # This would involve material modifications\n    # to simulate water on surfaces\n    pass\n'})}),"\n",(0,a.jsx)(n.h3,{id:"time-of-day-simulation",children:"Time-of-Day Simulation"}),"\n",(0,a.jsx)(n.p,{children:"Simulating different lighting conditions throughout the day:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_time_of_day_system(stage, time_path, time_of_day="noon"):\n    """Create lighting conditions for different times of day"""\n\n    # Define sun positions and intensities for different times\n    time_config = {\n        "sunrise": {"elevation": 10, "intensity": 0.4, "color": (1.0, 0.7, 0.4)},\n        "morning": {"elevation": 30, "intensity": 0.7, "color": (1.0, 0.9, 0.8)},\n        "noon": {"elevation": 60, "intensity": 1.0, "color": (1.0, 1.0, 1.0)},\n        "afternoon": {"elevation": 45, "intensity": 0.9, "color": (1.0, 0.95, 0.9)},\n        "sunset": {"elevation": 10, "intensity": 0.5, "color": (1.0, 0.6, 0.3)},\n        "night": {"elevation": -30, "intensity": 0.05, "color": (0.2, 0.2, 0.4)}\n    }\n\n    config = time_config.get(time_of_day, time_config["noon"])\n\n    # Create directional light (sun)\n    sun_light = UsdGeom.DistantLight.Define(stage, f"{time_path}/Sun")\n    sun_light.GetIntensityAttr().Set(config["intensity"])\n    sun_light.GetColorAttr().Set(Gf.Vec3f(*config["color"]))\n\n    # Calculate sun direction based on elevation\n    import math\n    elevation_rad = math.radians(config["elevation"])\n    sun_direction = Gf.Vec3f(\n        math.cos(elevation_rad) * math.cos(math.radians(45)),  # Example azimuth\n        math.sin(elevation_rad),\n        math.cos(elevation_rad) * math.sin(math.radians(45))\n    )\n\n    sun_xform = UsdGeom.Xformable(sun_light.GetPrim())\n    sun_xform.AddRotateXYZOp().Set(Gf.Vec3f(\n        math.degrees(math.atan2(sun_direction[1],\n                               math.sqrt(sun_direction[0]**2 + sun_direction[2]**2))),\n        math.degrees(math.atan2(sun_direction[0], sun_direction[2])),\n        0\n    ))\n\n    # Add ambient lighting for night conditions\n    if time_of_day == "night":\n        create_ambient_night_lighting(stage, f"{time_path}/Ambient")\n'})}),"\n",(0,a.jsx)(n.h2,{id:"multi-robot-simulation-scenarios",children:"Multi-Robot Simulation Scenarios"}),"\n",(0,a.jsx)(n.p,{children:"Creating complex scenarios with multiple robots operating simultaneously."}),"\n",(0,a.jsx)(n.h3,{id:"coordinated-multi-robot-environments",children:"Coordinated Multi-Robot Environments"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_multi_robot_scenario(stage, scenario_path, num_robots=3, scenario_type="warehouse"):\n    """Create a multi-robot scenario environment"""\n\n    scenario_prim = stage.DefinePrim(scenario_path, "Xform")\n\n    # Create environment based on scenario type\n    if scenario_type == "warehouse":\n        create_warehouse_environment(stage, f"{scenario_path}/Environment")\n    elif scenario_type == "search_rescue":\n        create_search_rescue_environment(stage, f"{scenario_path}/Environment")\n    elif scenario_type == "patrol":\n        create_patrol_environment(stage, f"{scenario_path}/Environment")\n\n    # Create multiple robots with different roles\n    robot_configs = generate_robot_configs(num_robots, scenario_type)\n\n    for i, config in enumerate(robot_configs):\n        robot_path = f"{scenario_path}/Robot_{i}"\n        create_configured_robot(stage, robot_path, config)\n\ndef create_warehouse_environment(stage, env_path):\n    """Create a warehouse environment for multi-robot scenario"""\n\n    # Create warehouse structure\n    warehouse = UsdGeom.Cube.Define(stage, f"{env_path}/Warehouse")\n    warehouse.GetSizeAttr().Set(1.0)\n\n    warehouse_xform = UsdGeom.Xformable(warehouse.GetPrim())\n    warehouse_xform.AddScaleOp().Set(Gf.Vec3f(50, 10, 50))  # Large warehouse\n\n    # Add shelving units\n    create_warehouse_shelving(stage, f"{env_path}/Shelving")\n\n    # Add charging stations\n    create_charging_stations(stage, f"{env_path}/Charging")\n\n    # Add waypoints for navigation\n    create_navigation_waypoints(stage, f"{env_path}/Waypoints")\n\ndef create_configured_robot(stage, robot_path, config):\n    """Create a robot with specific configuration"""\n\n    # Create robot based on type in config\n    robot_type = config.get("type", "diff_drive")\n\n    if robot_type == "diff_drive":\n        create_differential_drive_robot(stage, robot_path, config)\n    elif robot_type == "omnidirectional":\n        create_omnidirectional_robot(stage, robot_path, config)\n    elif robot_type == "humanoid":\n        create_humanoid_robot(stage, robot_path, config)\n\n    # Position robot according to config\n    position = config.get("position", (0, 0, 0))\n    xform = UsdGeom.Xformable(stage.GetPrimAtPath(robot_path))\n    xform.AddTranslateOp().Set(Gf.Vec3f(*position))\n\ndef generate_robot_configs(num_robots, scenario_type):\n    """Generate configurations for multiple robots"""\n\n    configs = []\n\n    for i in range(num_robots):\n        if scenario_type == "warehouse":\n            config = {\n                "type": "diff_drive" if i < num_robots-1 else "humanoid",\n                "position": (i*3 - (num_robots-1)*1.5, 0.1, 0),  # Staggered positions\n                "role": "transporter" if i < num_robots-1 else "supervisor",\n                "tasks": ["transport", "inventory"] if i < num_robots-1 else ["supervise", "quality_check"]\n            }\n        elif scenario_type == "search_rescue":\n            config = {\n                "type": "omnidirectional" if i == 0 else "diff_drive",\n                "position": (i*5, 0.1, i*2),\n                "role": "leader" if i == 0 else "support",\n                "specialization": "mapping" if i == 0 else "medical_supply"\n            }\n        else:  # patrol\n            config = {\n                "type": "diff_drive",\n                "position": (i*10, 0.1, 0),\n                "role": "patrol",\n                "assigned_area": f"sector_{i+1}",\n                "patrol_route": f"route_{i+1}"\n            }\n\n        configs.append(config)\n\n    return configs\n'})}),"\n",(0,a.jsx)(n.h3,{id:"communication-and-coordination-simulation",children:"Communication and Coordination Simulation"}),"\n",(0,a.jsx)(n.p,{children:"Simulating realistic communication between robots:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_communication_system(stage, comm_path, num_robots, comm_range=50.0):\n    """Create a simulated communication system for multi-robot coordination"""\n\n    # Create communication network properties\n    comm_system = stage.DefinePrim(comm_path, "Xform")\n\n    # Define communication range and topology\n    for i in range(num_robots):\n        for j in range(i+1, num_robots):\n            robot_i_pos = get_robot_position(stage, f"Robot_{i}")\n            robot_j_pos = get_robot_position(stage, f"Robot_{j}")\n\n            distance = calculate_distance(robot_i_pos, robot_j_pos)\n\n            if distance <= comm_range:\n                # Create communication link\n                create_communication_link(stage,\n                                        f"{comm_path}/Link_{i}_{j}",\n                                        f"Robot_{i}", f"Robot_{j}",\n                                        distance)\n\ndef simulate_communication_delay(message, distance, speed_of_light=3e8):\n    """Simulate communication delay based on distance"""\n\n    # In realistic scenarios, use speed of radio waves (~speed of light)\n    # but also account for processing delays\n    propagation_delay = distance / speed_of_light\n    processing_delay = 0.001  # 1ms processing delay\n\n    total_delay = propagation_delay + processing_delay\n    return total_delay\n'})}),"\n",(0,a.jsx)(n.h2,{id:"scene-optimization-and-performance",children:"Scene Optimization and Performance"}),"\n",(0,a.jsx)(n.p,{children:"Advanced scenes require careful optimization to maintain real-time performance."}),"\n",(0,a.jsx)(n.h3,{id:"level-of-detail-lod-systems",children:"Level of Detail (LOD) Systems"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_lod_system(stage, object_path, lod_configs):\n    """Create a Level of Detail system for complex objects"""\n\n    # Create multiple versions of the same object with different detail levels\n    for i, config in enumerate(lod_configs):\n        lod_path = f"{object_path}/LOD_{i}"\n\n        if config["type"] == "high":\n            create_high_detail_version(stage, lod_path, config)\n        elif config["type"] == "medium":\n            create_medium_detail_version(stage, lod_path, config)\n        else:  # low\n            create_low_detail_version(stage, lod_path, config)\n\ndef setup_lod_switching(stage, master_path, lod_paths, distances):\n    """Set up automatic LOD switching based on distance"""\n\n    # This would involve Isaac Sim\'s LOD switching mechanisms\n    # Define distance thresholds for switching between LOD levels\n    pass\n'})}),"\n",(0,a.jsx)(n.h3,{id:"occlusion-culling",children:"Occlusion Culling"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def setup_occlusion_culling(stage, scene_path):\n    """Set up occlusion culling for complex scenes"""\n\n    # Define occluders (large objects that can block view)\n    # Set up occlusion queries\n    # Configure rendering pipeline for occlusion culling\n\n    # This is typically handled through Isaac Sim\'s rendering pipeline\n    pass\n'})}),"\n",(0,a.jsx)(n.h3,{id:"multi-resolution-shading",children:"Multi-Resolution Shading"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def configure_multi_resolution_shading(stage, camera_path):\n    """Configure variable rate shading for performance"""\n\n    # Set up different shading rates for different parts of the image\n    # Typically based on where the robot is looking or areas of interest\n\n    # This would use Isaac Sim\'s advanced rendering features\n    pass\n'})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-scene-management",children:"Advanced Scene Management"}),"\n",(0,a.jsx)(n.h3,{id:"scene-streaming",children:"Scene Streaming"}),"\n",(0,a.jsx)(n.p,{children:"For very large environments:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def setup_scene_streaming(stage, world_path, chunk_size=50.0):\n    """Set up scene streaming for large environments"""\n\n    # Divide large environment into chunks\n    # Implement loading/unloading based on robot position\n    # Manage resource allocation for streaming\n\n    # Define streaming boundaries\n    # Set up streaming triggers\n    # Configure memory management\n    pass\n'})}),"\n",(0,a.jsx)(n.h3,{id:"scene-variants",children:"Scene Variants"}),"\n",(0,a.jsx)(n.p,{children:"Using USD's variant system for different scene configurations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def create_scene_variants(stage, base_scene_path):\n    """Create scene variants for different configurations"""\n\n    # Create variant sets for different scene configurations\n    # For example: different weather conditions, lighting, or object arrangements\n\n    # Example: Weather variants\n    create_weather_variants(stage, f"{base_scene_path}/Weather")\n\n    # Example: Time of day variants\n    create_time_variants(stage, f"{base_scene_path}/TimeOfDay")\n\n    # Example: Season variants\n    create_season_variants(stage, f"{base_scene_path}/Season")\n\ndef create_weather_variants(stage, weather_path):\n    """Create weather condition variants"""\n\n    # Define variant set\n    variant_set = stage.GetPrimAtPath(weather_path)\n    variant_set.GetVariantSets().AddVariantSet("WeatherCondition")\n\n    # Define variants\n    variant_names = ["Clear", "Rainy", "Snowy", "Foggy"]\n\n    for variant_name in variant_names:\n        # Add variant to the set\n        pass\n'})}),"\n",(0,a.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Exercise 1"}),": Create a procedural warehouse environment with multiple robots performing coordinated tasks, including dynamic obstacles and interactive objects."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Exercise 2"}),": Implement a weather system that affects both the visual appearance and sensor performance in your scene."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Exercise 3"}),": Design a multi-robot search and rescue scenario with realistic environmental challenges and communication constraints."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Exercise 4"}),": Create a time-of-day simulation that shows how lighting conditions affect robot perception throughout the day."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"performance-optimization-best-practices",children:"Performance Optimization Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use Appropriate Detail"}),": Match geometric detail to viewing distance and importance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Implement LOD"}),": Use Level of Detail systems for complex objects"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimize Materials"}),": Use efficient material definitions and textures"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manage Poly Count"}),": Keep polygon counts reasonable for real-time performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use Instancing"}),": Reuse identical objects through instancing"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"realism-best-practices",children:"Realism Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Physical Accuracy"}),": Ensure physics properties match real-world values"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sensor Realism"}),": Configure sensors to match real hardware specifications"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Environmental Effects"}),": Include realistic weather and lighting variations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dynamic Elements"}),": Add appropriate moving objects and changing conditions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validation"}),": Regularly validate simulation results against real-world data"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"collaboration-best-practices",children:"Collaboration Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Modular Design"}),": Create reusable scene components"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Standardized Naming"}),": Use consistent naming conventions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Documentation"}),": Document scene structure and parameters"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Version Control"}),": Use version control for scene files"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validation Checks"}),": Implement validation for scene integrity"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Advanced scene creation in Isaac Sim enables the development of sophisticated, realistic environments that challenge robotic systems under diverse and complex conditions. Through procedural generation, dynamic elements, environmental effects, and multi-robot scenarios, developers can create comprehensive testing environments that closely mirror real-world challenges."}),"\n",(0,a.jsx)(n.p,{children:"The combination of advanced scene creation techniques with Isaac Sim's photorealistic rendering, accurate physics simulation, and realistic sensor modeling provides an unparalleled platform for robotics development and research. The ability to create varied, challenging environments with realistic conditions enables the development of robust robotic systems capable of operating effectively in the real world."}),"\n",(0,a.jsx)(n.p,{children:"As we continue through this module, we'll explore how these advanced scenes integrate with the broader Isaac Sim ecosystem, including the connection to ROS 2 and the generation of synthetic data for machine learning applications. The sophisticated scene creation capabilities form the foundation for the advanced perception and navigation systems we'll explore in subsequent chapters."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(6540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);