"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[9885],{8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var s=r(6540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}},8912:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-1-NodeCreation","title":"1-3-1-NodeCreation","description":"---","source":"@site/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3.1 NodeCreation.md","sourceDirName":"Module1-ROS/Chapter3-PythonAgentsWithRclpy","slug":"/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-1-NodeCreation","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-1-NodeCreation","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3.1 NodeCreation.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"1-3-1-NodeCreation","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3 Overview","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/"},"next":{"title":"Chapter 4: Launch Params Lifecycle","permalink":"/docs/category/chapter-4-launch-params-lifecycle"}}');var t=r(4848),a=r(8453);const i={id:"1-3-1-NodeCreation",sidebar_position:1},l=void 0,o={},c=[{value:"Introduction to rclpy",id:"introduction-to-rclpy",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Basic Node Structure",id:"basic-node-structure",level:2},{value:"Key Components Explained",id:"key-components-explained",level:3},{value:"Node Lifecycle Management",id:"node-lifecycle-management",level:2},{value:"Standard Lifecycle States",id:"standard-lifecycle-states",level:3},{value:"Lifecycle Best Practices",id:"lifecycle-best-practices",level:3},{value:"Parameter Management",id:"parameter-management",level:2},{value:"Declaring and Using Parameters",id:"declaring-and-using-parameters",level:3},{value:"Parameter Types and Validation",id:"parameter-types-and-validation",level:3},{value:"Key Parameter Concepts",id:"key-parameter-concepts",level:3},{value:"Python Agent Bridge Pattern",id:"python-agent-bridge-pattern",level:2},{value:"Basic Bridge Architecture",id:"basic-bridge-architecture",level:3},{value:"Bridge Pattern Benefits",id:"bridge-pattern-benefits",level:3},{value:"Advanced Bridge Features",id:"advanced-bridge-features",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h1,{id:"chapter-3-01-creating-python-ros-2-nodes-with-rclpy",children:"Chapter 3-01: Creating Python ROS 2 Nodes with rclpy"}),"\n",(0,t.jsx)(n.h2,{id:"introduction-to-rclpy",children:"Introduction to rclpy"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"rclpy"})," is the Python client library for ROS 2 (Robot Operating System 2) that provides a pure Python implementation of the ROS 2 client library. It allows Python developers to create ROS 2 nodes, publish and subscribe to topics, provide and use services, and work with actions."]}),"\n",(0,t.jsxs)(n.p,{children:["ROS 2 is a flexible framework for writing robot software that provides services such as hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more. ",(0,t.jsx)(n.code,{children:"rclpy"})," serves as the bridge between Python applications and the ROS 2 ecosystem, enabling seamless integration of Python-based AI algorithms with robot control systems."]}),"\n",(0,t.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Create and initialize Python ROS 2 nodes using ",(0,t.jsx)(n.code,{children:"rclpy"})]}),"\n",(0,t.jsx)(n.li,{children:"Understand the node lifecycle and management"}),"\n",(0,t.jsx)(n.li,{children:"Implement parameter handling in Python nodes"}),"\n",(0,t.jsx)(n.li,{children:"Bridge Python agents to ROS controllers using node patterns"}),"\n",(0,t.jsx)(n.li,{children:"Structure node code for RAG (Retrieval-Augmented Generation) indexing"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsx)(n.p,{children:"Before proceeding, ensure you have:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Basic Python programming knowledge"}),"\n",(0,t.jsx)(n.li,{children:"Understanding of ROS 2 concepts (covered in Chapters 1-2)"}),"\n",(0,t.jsx)(n.li,{children:"ROS 2 Humble Hawksbill installed and sourced"}),"\n",(0,t.jsx)(n.li,{children:"Basic familiarity with command-line tools"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"basic-node-structure",children:"Basic Node Structure"}),"\n",(0,t.jsxs)(n.p,{children:["The fundamental building block of any ROS 2 system is the node. A node in ",(0,t.jsx)(n.code,{children:"rclpy"})," is a Python class that inherits from ",(0,t.jsx)(n.code,{children:"rclpy.node.Node"}),". Here's the minimal structure:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\n\r\nclass MinimalPublisher(Node):\r\n    """\r\n    A minimal ROS 2 node example that demonstrates basic node structure.\r\n    This node publishes a simple string message to a topic at regular intervals.\r\n    """\r\n\r\n    def __init__(self):\r\n        # Initialize the parent Node class with a node name\r\n        super().__init__(\'minimal_publisher\')\r\n\r\n        # Create a publisher that sends String messages to the \'topic\' topic\r\n        self.publisher_ = self.create_publisher(String, \'topic\', 10)\r\n\r\n        # Set up a timer to publish messages every 0.5 seconds\r\n        timer_period = 0.5  # seconds\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n\r\n        # Counter for message numbering\r\n        self.i = 0\r\n\r\n    def timer_callback(self):\r\n        """Callback function that executes when the timer fires."""\r\n        msg = String()\r\n        msg.data = \'Hello World: %d\' % self.i\r\n        self.publisher_.publish(msg)\r\n        self.get_logger().info(\'Publishing: "%s"\' % msg.data)\r\n        self.i += 1\r\n\r\ndef main(args=None):\r\n    """\r\n    Main function that initializes the ROS 2 context, creates the node,\r\n    and starts spinning to process callbacks.\r\n    """\r\n    # Initialize the rclpy library\r\n    rclpy.init(args=args)\r\n\r\n    # Create an instance of the node\r\n    minimal_publisher = MinimalPublisher()\r\n\r\n    # Start spinning - this keeps the node alive and processes callbacks\r\n    rclpy.spin(minimal_publisher)\r\n\r\n    # Clean up when the node is shut down\r\n    minimal_publisher.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n# This allows the script to be run directly\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"key-components-explained",children:"Key Components Explained"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node Inheritance"}),": Your custom node class inherits from ",(0,t.jsx)(n.code,{children:"rclpy.node.Node"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initialization"}),": The ",(0,t.jsx)(n.code,{children:"__init__"})," method calls the parent's ",(0,t.jsx)(n.code,{children:"__init__"})," with a unique node name"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Publisher Creation"}),": ",(0,t.jsx)(n.code,{children:"create_publisher()"})," creates a publisher for sending messages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timer Setup"}),": ",(0,t.jsx)(n.code,{children:"create_timer()"})," creates a timer that calls a callback function at regular intervals"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Message Creation"}),": Messages are created as instances of specific message types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Logging"}),": ",(0,t.jsx)(n.code,{children:"get_logger().info()"})," provides logging capabilities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cleanup"}),": ",(0,t.jsx)(n.code,{children:"destroy_node()"})," and ",(0,t.jsx)(n.code,{children:"rclpy.shutdown()"})," ensure proper cleanup"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"node-lifecycle-management",children:"Node Lifecycle Management"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 nodes have a well-defined lifecycle that includes initialization, execution, and cleanup phases. Understanding the lifecycle is crucial for creating robust and reliable nodes."}),"\n",(0,t.jsx)(n.h3,{id:"standard-lifecycle-states",children:"Standard Lifecycle States"}),"\n",(0,t.jsx)(n.p,{children:"Nodes can exist in various states during their lifetime:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unconfigured"}),": Node is created but not yet configured"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inactive"}),": Node is configured but not yet active"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Active"}),": Node is running and processing callbacks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Finalized"}),": Node has been shut down and cleaned up"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass LifecyclePublisher(Node):\r\n    """\r\n    Example of a node with explicit lifecycle management.\r\n    This node demonstrates proper initialization and cleanup patterns.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'lifecycle_publisher\')\r\n\r\n        # Initialize publisher as None - will be created in configure method\r\n        self.pub = None\r\n        self.subscription = None\r\n\r\n    def setup_publisher(self):\r\n        """Configure the publisher for this node."""\r\n        if self.pub is None:\r\n            self.pub = self.create_publisher(String, \'lifecycle_chatter\', 10)\r\n            self.get_logger().info(\'Publisher created\')\r\n        else:\r\n            self.get_logger().info(\'Publisher already exists\')\r\n\r\n    def setup_subscriber(self):\r\n        """Configure the subscriber for this node."""\r\n        if self.subscription is None:\r\n            self.subscription = self.create_subscription(\r\n                String,\r\n                \'lifecycle_command\',\r\n                self.command_callback,\r\n                10\r\n            )\r\n            self.get_logger().info(\'Subscriber created\')\r\n        else:\r\n            self.get_logger().info(\'Subscriber already exists\')\r\n\r\n    def command_callback(self, msg):\r\n        """Handle incoming commands."""\r\n        self.get_logger().info(f\'Received command: {msg.data}\')\r\n        # Process the command based on its content\r\n        if msg.data == \'configure\':\r\n            self.setup_publisher()\r\n            self.setup_subscriber()\r\n        elif msg.data == \'publish\':\r\n            self.publish_message()\r\n\r\n    def publish_message(self):\r\n        """Publish a message if publisher is available."""\r\n        if self.pub is not None:\r\n            msg = String()\r\n            msg.data = f\'Message from lifecycle node at {self.get_clock().now()}\'\r\n            self.pub.publish(msg)\r\n            self.get_logger().info(f\'Published: {msg.data}\')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    lifecycle_publisher = LifecyclePublisher()\r\n\r\n    try:\r\n        rclpy.spin(lifecycle_publisher)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        # Properly destroy the node before shutting down\r\n        lifecycle_publisher.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"lifecycle-best-practices",children:"Lifecycle Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Initialize in ",(0,t.jsx)(n.code,{children:"__init__"})]}),": Set up class variables and basic configuration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Create publishers/subscribers after initialization"}),": Ensure the node is properly set up first"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle cleanup"}),": Always destroy publishers and subscribers when shutting down"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use try-finally blocks"}),": Ensure cleanup occurs even if exceptions happen"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check for None"}),": Always verify that publishers/subscribers exist before using them"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"parameter-management",children:"Parameter Management"}),"\n",(0,t.jsxs)(n.p,{children:["Nodes often need to accept parameters to configure their behavior at runtime. ",(0,t.jsx)(n.code,{children:"rclpy"})," provides a robust parameter system that allows nodes to be configured without code changes."]}),"\n",(0,t.jsx)(n.h3,{id:"declaring-and-using-parameters",children:"Declaring and Using Parameters"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom rcl_interfaces.msg import ParameterType\r\nfrom std_msgs.msg import String\r\nimport time\r\n\r\nclass ParameterNode(Node):\r\n    \"\"\"\r\n    A node that demonstrates parameter handling in ROS 2.\r\n    This node uses parameters to configure its behavior dynamically.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('parameter_node')\r\n\r\n        # Declare parameters with default values and descriptions\r\n        # Format: declare_parameter(parameter_name, default_value)\r\n        self.declare_parameter('robot_name', 'turtlebot')\r\n        self.declare_parameter('max_velocity', 1.0)\r\n        self.declare_parameter('control_frequency', 50)\r\n        self.declare_parameter('sensor_topic', '/sensors/laser_scan')\r\n        self.declare_parameter('publish_topic', '/cmd_vel')\r\n        self.declare_parameter('debug_mode', False)\r\n\r\n        # Access parameter values after declaration\r\n        self.robot_name = self.get_parameter('robot_name').value\r\n        self.max_velocity = self.get_parameter('max_velocity').value\r\n        self.control_frequency = self.get_parameter('control_frequency').value\r\n        self.sensor_topic = self.get_parameter('sensor_topic').value\r\n        self.publish_topic = self.get_parameter('publish_topic').value\r\n        self.debug_mode = self.get_parameter('debug_mode').value\r\n\r\n        # Create publisher based on parameter configuration\r\n        self.publisher = self.create_publisher(String, self.publish_topic, 10)\r\n\r\n        # Set up timer based on frequency parameter\r\n        timer_period = 1.0 / self.control_frequency\r\n        self.timer = self.create_timer(timer_period, self.publish_status)\r\n\r\n        # Log configuration\r\n        self.get_logger().info(f'Robot: {self.robot_name}')\r\n        self.get_logger().info(f'Max velocity: {self.max_velocity}')\r\n        self.get_logger().info(f'Control frequency: {self.control_frequency} Hz')\r\n        self.get_logger().info(f'Debug mode: {self.debug_mode}')\r\n\r\n        # Counter for messages\r\n        self.counter = 0\r\n\r\n    def publish_status(self):\r\n        \"\"\"Publish robot status based on current parameters.\"\"\"\r\n        msg = String()\r\n        msg.data = f'Status: {self.robot_name}, Counter: {self.counter}, Time: {time.time()}'\r\n        self.publisher.publish(msg)\r\n\r\n        if self.debug_mode:\r\n            self.get_logger().info(f'Debug: {msg.data}')\r\n\r\n        self.counter += 1\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    parameter_node = ParameterNode()\r\n\r\n    try:\r\n        rclpy.spin(parameter_node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        parameter_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parameter-types-and-validation",children:"Parameter Types and Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom rcl_interfaces.msg import ParameterDescriptor, ParameterType\r\nfrom rcl_interfaces.srv import SetParameters\r\nfrom std_msgs.msg import String\r\n\r\nclass AdvancedParameterNode(Node):\r\n    \"\"\"\r\n    A node demonstrating advanced parameter features including validation,\r\n    dynamic reconfiguration, and parameter callbacks.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('advanced_parameter_node')\r\n\r\n        # Declare parameters with descriptors for validation\r\n        velocity_descriptor = ParameterDescriptor(\r\n            type=ParameterType.PARAMETER_DOUBLE,\r\n            description='Maximum velocity for the robot',\r\n            additional_constraints='Must be between 0.1 and 10.0',\r\n            floating_point_range=[{\r\n                'from_value': 0.1,\r\n                'to_value': 10.0,\r\n                'step': 0.1\r\n            }]\r\n        )\r\n\r\n        name_descriptor = ParameterDescriptor(\r\n            type=ParameterType.PARAMETER_STRING,\r\n            description='Name of the robot',\r\n            additional_constraints='Must be alphanumeric and 3-20 characters'\r\n        )\r\n\r\n        # Declare parameters with descriptors\r\n        self.declare_parameter('max_velocity', 1.0, velocity_descriptor)\r\n        self.declare_parameter('robot_name', 'default_robot', name_descriptor)\r\n        self.declare_parameter('safety_enabled', True)\r\n\r\n        # Set up parameter change callback\r\n        self.add_on_set_parameters_callback(self.parameter_callback)\r\n\r\n        # Initialize values\r\n        self.max_velocity = self.get_parameter('max_velocity').value\r\n        self.robot_name = self.get_parameter('robot_name').value\r\n        self.safety_enabled = self.get_parameter('safety_enabled').value\r\n\r\n        # Create publisher\r\n        self.publisher = self.create_publisher(String, 'robot_status', 10)\r\n\r\n        # Log initial configuration\r\n        self.get_logger().info(f'Advanced Parameter Node initialized')\r\n        self.get_logger().info(f'Robot: {self.robot_name}, Max Velocity: {self.max_velocity}')\r\n\r\n    def parameter_callback(self, params):\r\n        \"\"\"\r\n        Callback function that validates parameter changes.\r\n        This function is called whenever parameters are set.\r\n        \"\"\"\r\n        for param in params:\r\n            if param.name == 'max_velocity':\r\n                # Validate velocity parameter\r\n                if param.value < 0.1 or param.value > 10.0:\r\n                    self.get_logger().error(f'Invalid velocity: {param.value}. Must be between 0.1 and 10.0')\r\n                    return SetParameters.Result(successful=False, reason='Velocity out of range')\r\n\r\n                # Update internal value\r\n                self.max_velocity = param.value\r\n                self.get_logger().info(f'Velocity updated to: {param.value}')\r\n\r\n            elif param.name == 'robot_name':\r\n                # Validate name parameter\r\n                if not (3 <= len(param.value) <= 20):\r\n                    self.get_logger().error(f'Invalid robot name length: {len(param.value)}. Must be 3-20 characters')\r\n                    return SetParameters.Result(successful=False, reason='Name length invalid')\r\n\r\n                # Update internal value\r\n                self.robot_name = param.value\r\n                self.get_logger().info(f'Robot name updated to: {param.value}')\r\n\r\n        # If we get here, all parameters were valid\r\n        return SetParameters.Result(successful=True)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    advanced_node = AdvancedParameterNode()\r\n\r\n    try:\r\n        rclpy.spin(advanced_node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        advanced_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-parameter-concepts",children:"Key Parameter Concepts"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Declaration"}),": Parameters must be declared before use with ",(0,t.jsx)(n.code,{children:"declare_parameter()"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Types"}),": ROS 2 supports various parameter types (int, double, string, bool, lists)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Default Values"}),": Always provide sensible defaults for parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation"}),": Use parameter callbacks to validate values before accepting them"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic Reconfiguration"}),": Parameters can be changed at runtime using ROS 2 tools"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"python-agent-bridge-pattern",children:"Python Agent Bridge Pattern"}),"\n",(0,t.jsxs)(n.p,{children:["One of the most important applications of ",(0,t.jsx)(n.code,{children:"rclpy"})," is bridging Python-based AI agents to ROS-based robot controllers. This pattern enables AI algorithms implemented in Python to interact with physical robot systems running ROS controllers."]}),"\n",(0,t.jsx)(n.h3,{id:"basic-bridge-architecture",children:"Basic Bridge Architecture"}),"\n",(0,t.jsx)(n.p,{children:"The bridge pattern involves creating a ROS 2 node that acts as an intermediary between:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Python Agent"}),": AI algorithms, planning systems, or decision-making components"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bridge Node"}),": ROS 2 node that translates between Python agent outputs and ROS messages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROS Controllers"}),": Robot control systems that execute commands and provide feedback"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String, Float32\r\nfrom geometry_msgs.msg import Twist\r\nfrom sensor_msgs.msg import LaserScan\r\nimport numpy as np\r\nimport time\r\n\r\nclass PythonAgentBridge(Node):\r\n    \"\"\"\r\n    A bridge node that connects Python AI agents to ROS-based robot controllers.\r\n    This node demonstrates how to integrate AI decision-making with robot control.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('python_agent_bridge')\r\n\r\n        # Bridge configuration parameters\r\n        self.declare_parameter('agent_frequency', 10)  # Hz\r\n        self.declare_parameter('safety_distance', 0.5)  # meters\r\n        self.declare_parameter('max_linear_velocity', 1.0)\r\n        self.declare_parameter('max_angular_velocity', 1.0)\r\n\r\n        # Get parameter values\r\n        self.agent_frequency = self.get_parameter('agent_frequency').value\r\n        self.safety_distance = self.get_parameter('safety_distance').value\r\n        self.max_linear_vel = self.get_parameter('max_linear_velocity').value\r\n        self.max_angular_vel = self.get_parameter('max_angular_velocity').value\r\n\r\n        # Publisher to send commands to robot controller\r\n        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)\r\n\r\n        # Subscriber to receive sensor feedback from robot\r\n        self.laser_subscriber = self.create_subscription(\r\n            LaserScan, '/scan', self.laser_callback, 10\r\n        )\r\n\r\n        # Subscriber for high-level commands from Python agent\r\n        self.agent_command_subscriber = self.create_subscription(\r\n            String, '/agent_commands', self.agent_command_callback, 10\r\n        )\r\n\r\n        # Timer for AI decision-making loop\r\n        timer_period = 1.0 / self.agent_frequency\r\n        self.agent_timer = self.create_timer(timer_period, self.agent_decision_loop)\r\n\r\n        # State variables for the bridge\r\n        self.latest_laser_data = None\r\n        self.latest_agent_command = None\r\n        self.safety_mode = False\r\n        self.agent_enabled = True\r\n\r\n        # Log initialization\r\n        self.get_logger().info('Python Agent Bridge initialized')\r\n        self.get_logger().info(f'Agent frequency: {self.agent_frequency} Hz')\r\n        self.get_logger().info(f'Safety distance: {self.safety_distance} m')\r\n\r\n    def laser_callback(self, msg):\r\n        \"\"\"Handle incoming laser scan data from the robot.\"\"\"\r\n        self.latest_laser_data = msg\r\n        self.get_logger().debug(f'Received laser scan with {len(msg.ranges)} ranges')\r\n\r\n        # Check for obstacles within safety distance\r\n        if self.latest_laser_data:\r\n            min_range = min(self.latest_laser_data.ranges)\r\n            if min_range < self.safety_distance:\r\n                self.safety_mode = True\r\n                self.get_logger().warn(f'Safety distance violated: {min_range:.2f}m < {self.safety_distance:.2f}m')\r\n            else:\r\n                self.safety_mode = False\r\n\r\n    def agent_command_callback(self, msg):\r\n        \"\"\"Handle high-level commands from the Python agent.\"\"\"\r\n        self.latest_agent_command = msg.data\r\n        self.get_logger().info(f'Received agent command: {msg.data}')\r\n\r\n        # Process special commands\r\n        if msg.data == 'enable':\r\n            self.agent_enabled = True\r\n            self.get_logger().info('Agent enabled')\r\n        elif msg.data == 'disable':\r\n            self.agent_enabled = False\r\n            self.get_logger().info('Agent disabled')\r\n        elif msg.data == 'emergency_stop':\r\n            self.emergency_stop()\r\n        elif msg.data.startswith('set_frequency:'):\r\n            try:\r\n                new_freq = float(msg.data.split(':')[1])\r\n                self.set_agent_frequency(new_freq)\r\n            except ValueError:\r\n                self.get_logger().error(f'Invalid frequency command: {msg.data}')\r\n\r\n    def agent_decision_loop(self):\r\n        \"\"\"Main AI decision-making loop that runs at agent_frequency.\"\"\"\r\n        if not self.agent_enabled:\r\n            return\r\n\r\n        # Safety check - if in safety mode, stop the robot\r\n        if self.safety_mode:\r\n            self.emergency_stop()\r\n            return\r\n\r\n        # Process sensor data and make decisions\r\n        if self.latest_laser_data:\r\n            # Example AI decision based on sensor data\r\n            cmd_vel = self.make_navigation_decision()\r\n\r\n            # Publish the command to the robot controller\r\n            if cmd_vel:\r\n                self.cmd_vel_publisher.publish(cmd_vel)\r\n                self.get_logger().debug(f'Sent command: linear={cmd_vel.linear.x}, angular={cmd_vel.angular.z}')\r\n\r\n    def make_navigation_decision(self):\r\n        \"\"\"\r\n        Example AI decision-making function.\r\n        This function analyzes sensor data and returns navigation commands.\r\n        \"\"\"\r\n        if not self.latest_laser_data:\r\n            return None\r\n\r\n        # Get ranges in front of the robot (narrow forward sector)\r\n        front_ranges = self.latest_laser_data.ranges[330:] + self.latest_laser_data.ranges[:30]\r\n\r\n        # Filter out invalid ranges (inf or nan)\r\n        valid_ranges = [r for r in front_ranges if r != float('inf') and not np.isnan(r)]\r\n\r\n        if not valid_ranges:\r\n            # If no valid ranges, go forward slowly\r\n            cmd = Twist()\r\n            cmd.linear.x = 0.2\r\n            cmd.angular.z = 0.0\r\n            return cmd\r\n\r\n        # Find minimum distance in front\r\n        min_front_distance = min(valid_ranges) if valid_ranges else float('inf')\r\n\r\n        # Simple navigation algorithm\r\n        cmd = Twist()\r\n\r\n        if min_front_distance < self.safety_distance * 1.5:  # Buffer zone\r\n            # Too close to obstacle, turn away\r\n            cmd.linear.x = 0.0\r\n            cmd.angular.z = 0.5  # Turn right\r\n        elif min_front_distance < self.safety_distance * 3:\r\n            # Moderate distance, go forward slowly\r\n            cmd.linear.x = 0.3\r\n            cmd.angular.z = 0.0\r\n        else:\r\n            # Safe distance, go forward at normal speed\r\n            cmd.linear.x = 0.8\r\n            cmd.angular.z = 0.0\r\n\r\n        return cmd\r\n\r\n    def emergency_stop(self):\r\n        \"\"\"Send emergency stop command to robot.\"\"\"\r\n        cmd = Twist()\r\n        cmd.linear.x = 0.0\r\n        cmd.angular.z = 0.0\r\n        self.cmd_vel_publisher.publish(cmd)\r\n        self.get_logger().warn('Emergency stop command sent')\r\n\r\n    def set_agent_frequency(self, new_frequency):\r\n        \"\"\"Dynamically adjust the agent decision frequency.\"\"\"\r\n        if 1.0 <= new_frequency <= 100.0:  # Reasonable range\r\n            self.agent_frequency = new_frequency\r\n            # Update the timer period\r\n            old_period = self.agent_timer.timer_period_ns\r\n            new_period = int(1.0 / new_frequency * 1e9)  # Convert to nanoseconds\r\n            self.agent_timer.change_timer_period(new_period)\r\n            self.get_logger().info(f'Agent frequency changed from {1e9/old_period:.1f}Hz to {new_frequency:.1f}Hz')\r\n        else:\r\n            self.get_logger().error(f'Invalid frequency: {new_frequency}. Must be between 1.0 and 100.0 Hz')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    bridge_node = PythonAgentBridge()\r\n\r\n    try:\r\n        rclpy.spin(bridge_node)\r\n        self.get_logger().info('Python Agent Bridge spinning...')\r\n    except KeyboardInterrupt:\r\n        bridge_node.get_logger().info('Interrupted, shutting down...')\r\n    finally:\r\n        bridge_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"bridge-pattern-benefits",children:"Bridge Pattern Benefits"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decoupling"}),": AI agents and robot controllers can be developed independently"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flexibility"}),": Different AI algorithms can be swapped without changing robot controllers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Safety"}),": The bridge can implement safety checks and emergency procedures"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability"}),": Multiple agents can interact with the same robot through the bridge"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Debugging"}),": Communication between agent and robot can be monitored and logged"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"advanced-bridge-features",children:"Advanced Bridge Features"}),"\n",(0,t.jsx)(n.p,{children:"The example above demonstrates several advanced features:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameter-based configuration"})," for runtime adjustability"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Safety systems"})," that can override agent decisions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic frequency adjustment"})," for performance tuning"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor data processing"})," for AI decision-making"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Emergency stop capabilities"})," for safety"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.p,{children:["In this section, we've covered the fundamentals of creating Python ROS 2 nodes using ",(0,t.jsx)(n.code,{children:"rclpy"}),". You've learned:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Basic node structure"})," and initialization patterns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node lifecycle management"})," for robust operation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameter handling"})," for configurable behavior"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Python agent bridge patterns"})," for connecting AI algorithms to robot controllers"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These concepts form the foundation for building more complex ROS 2 systems that integrate Python-based AI with robot control systems."}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Basic Node Creation"}),": Create a node that publishes the current timestamp to a topic every second. Include parameters for controlling the publishing frequency."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameter Validation"}),': Extend the parameter example to include validation for a robot\'s operational mode (e.g., "navigation", "manipulation", "inspection") using parameter callbacks.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Simple Bridge Implementation"}),': Create a bridge node that takes high-level commands (e.g., "go forward", "turn left", "stop") from a Python agent and converts them to Twist messages for a robot controller.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Safety-Enhanced Bridge"}),": Modify your bridge implementation to include safety checks based on sensor data (e.g., stop if obstacles are too close)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameter Tuning"}),": Implement a bridge node where the AI decision-making parameters (like safety distance, speeds, etc.) can be adjusted at runtime using ROS 2 parameter tools."]}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);