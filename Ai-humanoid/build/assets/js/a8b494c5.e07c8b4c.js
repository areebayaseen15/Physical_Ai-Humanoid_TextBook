"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[2545],{1894:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-3-Services","title":"1 3.3 Services","description":"Introduction to Services in ROS 2","source":"@site/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3.3 Services.md","sourceDirName":"Module1-ROS/Chapter3-PythonAgentsWithRclpy","slug":"/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-3-Services","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-3-Services","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3.3 Services.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"id":"1-3-3-Services","title":"1 3.3 Services","sidebar_label":"1 3.3 Services","sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"1 3.2 PublishSubscribe","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-2-PublishSubscribe"},"next":{"title":"1 3.4 Actions","permalink":"/docs/Module1-ROS/Chapter3-PythonAgentsWithRclpy/1-3-4-Actions"}}');var t=s(4848),i=s(8453);const o={id:"1-3-3-Services",title:"1 3.3 Services",sidebar_label:"1 3.3 Services",sidebar_position:0},l="Chapter 3-03: Python Service Clients and Servers with rclpy",a={},c=[{value:"Introduction to Services in ROS 2",id:"introduction-to-services-in-ros-2",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Creating Service Servers",id:"creating-service-servers",level:2},{value:"Basic Service Server Implementation",id:"basic-service-server-implementation",level:3},{value:"Parameterized Service Server",id:"parameterized-service-server",level:3},{value:"Advanced Service Server with Error Handling",id:"advanced-service-server-with-error-handling",level:3},{value:"Service Server Best Practices",id:"service-server-best-practices",level:3},{value:"Creating Service Clients",id:"creating-service-clients",level:2},{value:"Basic Service Client Implementation",id:"basic-service-client-implementation",level:3},{value:"Advanced Service Client with Error Handling",id:"advanced-service-client-with-error-handling",level:3},{value:"Service Client with Retry Logic",id:"service-client-with-retry-logic",level:3},{value:"Service Client Best Practices",id:"service-client-best-practices",level:3},{value:"Working with Custom Service Types",id:"working-with-custom-service-types",level:2},{value:"Defining Custom Service Types",id:"defining-custom-service-types",level:3},{value:"Implementing Custom Services",id:"implementing-custom-services",level:3},{value:"Complex Custom Service Example",id:"complex-custom-service-example",level:3},{value:"Custom Service Best Practices",id:"custom-service-best-practices",level:3},{value:"Python Agent Bridge for Services",id:"python-agent-bridge-for-services",level:2},{value:"Service Bridge Architecture",id:"service-bridge-architecture",level:3},{value:"Advanced Service Bridge with Multiple Agents",id:"advanced-service-bridge-with-multiple-agents",level:3},{value:"Service Bridge Benefits",id:"service-bridge-benefits",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-3-03-python-service-clients-and-servers-with-rclpy",children:"Chapter 3-03: Python Service Clients and Servers with rclpy"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction-to-services-in-ros-2",children:"Introduction to Services in ROS 2"}),"\n",(0,t.jsx)(n.p,{children:"Services in ROS 2 (Robot Operating System 2) provide a synchronous communication pattern between nodes, where one node (the service client) sends a request to another node (the service server) and waits for a response. This request-response pattern is fundamentally different from the publish-subscribe pattern, as it establishes a direct, synchronous connection between the client and server."}),"\n",(0,t.jsx)(n.p,{children:"Services are ideal for operations that require immediate responses or have well-defined request-response semantics, such as robot configuration, sensor calibration, or executing specific actions with guaranteed completion. Unlike topics, which are asynchronous and decoupled, services create a tight coupling between client and server during the duration of the request."}),"\n",(0,t.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create service servers that respond to requests from clients"}),"\n",(0,t.jsx)(n.li,{children:"Create service clients that send requests and handle responses"}),"\n",(0,t.jsx)(n.li,{children:"Implement custom service types for specific applications"}),"\n",(0,t.jsx)(n.li,{children:"Handle service errors and timeouts gracefully"}),"\n",(0,t.jsx)(n.li,{children:"Bridge Python AI agents to ROS controllers using service communication"}),"\n",(0,t.jsx)(n.li,{children:"Structure service communication content for RAG (Retrieval-Augmented Generation) indexing"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service"}),": A synchronous communication pattern with request-response semantics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Server"}),": A node that provides a service and responds to requests"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Client"}),": A node that sends requests to a service server"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Type"}),": Defines the structure of requests and responses"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronous"}),": The client waits for a response before continuing"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"creating-service-servers",children:"Creating Service Servers"}),"\n",(0,t.jsxs)(n.p,{children:["Service servers in ROS 2 provide functionality that clients can request synchronously. Creating a service server in ",(0,t.jsx)(n.code,{children:"rclpy"})," involves using the ",(0,t.jsx)(n.code,{children:"create_service()"})," method of a node instance, which requires a service type and a callback function to process requests."]}),"\n",(0,t.jsx)(n.h3,{id:"basic-service-server-implementation",children:"Basic Service Server Implementation"}),"\n",(0,t.jsxs)(n.p,{children:["First, let's define a simple service type. In a real project, this would be in a ",(0,t.jsx)(n.code,{children:".srv"})," file:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# In your_robot_package/srv/AddTwoInts.srv\nint64 a\nint64 b\n---\nint64 sum\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then implement the service server:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts  # Standard example service\n\nclass BasicServiceServer(Node):\n    \"\"\"\n    A basic service server that demonstrates the fundamental concepts of\n    creating and implementing a service in ROS 2 using rclpy.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('basic_service_server')\n\n        # Create the service with the service type and callback function\n        self.srv = self.create_service(\n            AddTwoInts,\n            'add_two_ints',\n            self.add_two_ints_callback\n        )\n\n        self.get_logger().info('Basic Service Server initialized')\n\n    def add_two_ints_callback(self, request, response):\n        \"\"\"\n        Callback function that processes service requests.\n        This function receives a request object and returns a response object.\n        \"\"\"\n        # Perform the service operation\n        response.sum = request.a + request.b\n\n        # Log the operation\n        self.get_logger().info(\n            f'Incoming request: {request.a} + {request.b} = {response.sum}'\n        )\n\n        # Return the response (must return the response object)\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    service_server = BasicServiceServer()\n\n    try:\n        rclpy.spin(service_server)\n    except KeyboardInterrupt:\n        service_server.get_logger().info('Interrupted, shutting down...')\n    finally:\n        service_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parameterized-service-server",children:"Parameterized Service Server"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\nfrom std_srvs.srv import SetBool\nimport time\n\nclass ParameterizedServiceServer(Node):\n    \"\"\"\n    A service server that uses parameters to configure its behavior.\n    This demonstrates how to make service servers configurable at runtime.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('parameterized_service_server')\n\n        # Declare parameters for service configuration\n        self.declare_parameter('max_calculation_time', 5.0)  # seconds\n        self.declare_parameter('service_enabled', True)\n        self.declare_parameter('service_name', 'parameterized_calculation')\n\n        # Get parameter values\n        self.max_calc_time = self.get_parameter('max_calculation_time').value\n        self.service_enabled = self.get_parameter('service_enabled').value\n        self.service_name = self.get_parameter('service_name').value\n\n        # Create services with configurable names\n        self.calc_service = self.create_service(\n            AddTwoInts,\n            f'{self.service_name}_add',\n            self.calculation_callback\n        )\n\n        self.config_service = self.create_service(\n            SetBool,\n            f'{self.service_name}_config',\n            self.config_callback\n        )\n\n        # Track service statistics\n        self.request_count = 0\n        self.error_count = 0\n\n        # Log configuration\n        self.get_logger().info(f'Parameterized Service Server initialized')\n        self.get_logger().info(f'Service name: {self.service_name}')\n        self.get_logger().info(f'Max calculation time: {self.max_calc_time}s')\n        self.get_logger().info(f'Service enabled: {self.service_enabled}')\n\n    def calculation_callback(self, request, response):\n        \"\"\"Handle calculation requests with time constraints.\"\"\"\n        start_time = time.time()\n\n        # Check if service is enabled\n        if not self.service_enabled:\n            response.success = False\n            response.message = 'Service is currently disabled'\n            self.error_count += 1\n            return response\n\n        # Simulate computation time (in a real service, this would be actual work)\n        # Add a small delay to simulate processing\n        time.sleep(0.1)\n\n        # Perform the calculation\n        try:\n            result = request.a + request.b\n\n            # Check for computation timeout\n            if time.time() - start_time > self.max_calc_time:\n                response.success = False\n                response.message = f'Calculation took too long: {time.time() - start_time:.2f}s'\n                self.error_count += 1\n                return response\n\n            response.sum = result\n            response.success = True\n            response.message = f'Calculated in {time.time() - start_time:.3f}s'\n\n            self.request_count += 1\n            self.get_logger().info(\n                f'Calculation: {request.a} + {request.b} = {result} '\n                f'(Time: {time.time() - start_time:.3f}s)'\n            )\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Calculation error: {str(e)}'\n            self.error_count += 1\n            self.get_logger().error(f'Calculation error: {e}')\n\n        return response\n\n    def config_callback(self, request, response):\n        \"\"\"Handle configuration requests.\"\"\"\n        if request.data:\n            self.service_enabled = True\n            response.success = True\n            response.message = 'Service enabled'\n            self.get_logger().info('Service enabled via configuration')\n        else:\n            self.service_enabled = False\n            response.success = True\n            response.message = 'Service disabled'\n            self.get_logger().info('Service disabled via configuration')\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    param_server = ParameterizedServiceServer()\n\n    try:\n        rclpy.spin(param_server)\n    except KeyboardInterrupt:\n        param_server.get_logger().info(\n            f'Shutting down. Stats - Requests: {param_server.request_count}, '\n            f'Errors: {param_server.error_count}'\n        )\n    finally:\n        param_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-service-server-with-error-handling",children:"Advanced Service Server with Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\nfrom std_srvs.srv import Trigger\nfrom rclpy.qos import QoSProfile\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\nimport time\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor\nimport math\n\nclass AdvancedServiceServer(Node):\n    \"\"\"\n    An advanced service server with comprehensive error handling,\n    threading support, and multiple service types.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_service_server')\n\n        # Create multiple services with different callback groups\n        default_callback_group = MutuallyExclusiveCallbackGroup()\n        computation_callback_group = MutuallyExclusiveCallbackGroup()\n\n        # Basic calculation service\n        self.calc_service = self.create_service(\n            AddTwoInts,\n            'advanced_calculation',\n            self.advanced_calculation_callback,\n            callback_group=default_callback_group\n        )\n\n        # Trigger service for simple operations\n        self.trigger_service = self.create_service(\n            Trigger,\n            'system_trigger',\n            self.trigger_callback,\n            callback_group=default_callback_group\n        )\n\n        # Initialize thread pool for long-running operations\n        self.executor = ThreadPoolExecutor(max_workers=3)\n\n        # Service statistics\n        self.stats = {\n            'total_requests': 0,\n            'successful_requests': 0,\n            'failed_requests': 0,\n            'total_calculation_time': 0.0\n        }\n\n        self.get_logger().info('Advanced Service Server initialized')\n\n    def advanced_calculation_callback(self, request, response):\n        \"\"\"Handle advanced calculations with error handling.\"\"\"\n        start_time = time.time()\n        self.stats['total_requests'] += 1\n\n        try:\n            # Validate inputs\n            if request.a < -1000000 or request.a > 1000000:\n                raise ValueError(f'Input a out of range: {request.a}')\n            if request.b < -1000000 or request.b > 1000000:\n                raise ValueError(f'Input b out of range: {request.b}')\n\n            # Perform calculation\n            result = self.perform_calculation(request.a, request.b)\n\n            # Update statistics\n            calc_time = time.time() - start_time\n            self.stats['total_calculation_time'] += calc_time\n            self.stats['successful_requests'] += 1\n\n            response.sum = result\n            response.success = True\n            response.message = f'Calculated in {calc_time:.3f}s. Avg: {self.stats[\"total_calculation_time\"]/self.stats[\"successful_requests\"]:.3f}s'\n\n            self.get_logger().info(\n                f'Advanced calc: {request.a} + {request.b} = {result} '\n                f'(Time: {calc_time:.3f}s)'\n            )\n\n        except ValueError as e:\n            self.stats['failed_requests'] += 1\n            response.success = False\n            response.message = f'Input validation error: {str(e)}'\n            self.get_logger().warn(f'Input validation error: {e}')\n\n        except OverflowError:\n            self.stats['failed_requests'] += 1\n            response.success = False\n            response.message = 'Calculation would cause overflow'\n            self.get_logger().error('Calculation overflow detected')\n\n        except Exception as e:\n            self.stats['failed_requests'] += 1\n            response.success = False\n            response.message = f'Unexpected error: {str(e)}'\n            self.get_logger().error(f'Unexpected error in calculation: {e}')\n\n        return response\n\n    def perform_calculation(self, a, b):\n        \"\"\"Perform the actual calculation with additional logic.\"\"\"\n        # In a real system, this might involve complex algorithms\n        result = a + b\n\n        # Example of additional processing that might be needed\n        if result < 0:\n            result = abs(result)  # Example: always return positive\n        elif result > 1000000:\n            result = result % 1000000  # Example: wrap around for large numbers\n\n        return result\n\n    def trigger_callback(self, request, response):\n        \"\"\"Handle trigger requests.\"\"\"\n        self.get_logger().info('Trigger service called')\n\n        # Perform trigger action\n        action_result = self.perform_trigger_action()\n\n        if action_result:\n            response.success = True\n            response.message = 'Trigger action completed successfully'\n        else:\n            response.success = False\n            response.message = 'Trigger action failed'\n\n        return response\n\n    def perform_trigger_action(self):\n        \"\"\"Perform the actual trigger action.\"\"\"\n        # Simulate some action (in real system, this could be hardware control)\n        time.sleep(0.05)  # Simulate processing time\n        return True\n\n    def get_stats_callback(self, request, response):\n        \"\"\"Return service statistics.\"\"\"\n        response.success = True\n        response.message = (\n            f'Total: {self.stats[\"total_requests\"]}, '\n            f'Successful: {self.stats[\"successful_requests\"]}, '\n            f'Failed: {self.stats[\"failed_requests\"]}, '\n            f'Avg time: {self.stats[\"total_calculation_time\"]/max(1, self.stats[\"successful_requests\"]):.3f}s'\n        )\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    advanced_server = AdvancedServiceServer()\n\n    try:\n        rclpy.spin(advanced_server)\n    except KeyboardInterrupt:\n        advanced_server.get_logger().info('Interrupted, shutting down...')\n        # Print final statistics\n        stats = advanced_server.stats\n        if stats['successful_requests'] > 0:\n            avg_time = stats['total_calculation_time'] / stats['successful_requests']\n            advanced_server.get_logger().info(\n                f'Final stats - Total: {stats[\"total_requests\"]}, '\n                f'Successful: {stats[\"successful_requests\"]}, '\n                f'Failed: {stats[\"failed_requests\"]}, '\n                f'Avg time: {avg_time:.3f}s'\n            )\n    finally:\n        advanced_server.executor.shutdown(wait=True)\n        advanced_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-server-best-practices",children:"Service Server Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Always implement proper error handling in service callbacks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Input Validation"}),": Validate all incoming request parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timeout Management"}),": Consider implementing timeouts for long-running operations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Management"}),": Properly manage resources and avoid blocking the main thread"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Logging"}),": Log service calls for debugging and monitoring"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Threading"}),": Use appropriate threading models for CPU-intensive operations"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"creating-service-clients",children:"Creating Service Clients"}),"\n",(0,t.jsxs)(n.p,{children:["Service clients in ROS 2 send requests to service servers and wait for responses. Creating a service client in ",(0,t.jsx)(n.code,{children:"rclpy"})," involves using the ",(0,t.jsx)(n.code,{children:"create_client()"})," method of a node instance, followed by making asynchronous service calls."]}),"\n",(0,t.jsx)(n.h3,{id:"basic-service-client-implementation",children:"Basic Service Client Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\nimport time\n\nclass BasicServiceClient(Node):\n    \"\"\"\n    A basic service client that demonstrates how to create and use\n    service clients in ROS 2 using rclpy.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('basic_service_client')\n\n        # Create the service client\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n\n        # Wait for the service to be available\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n\n        # Create a request object\n        self.request = AddTwoInts.Request()\n\n        # Timer to make periodic service calls\n        self.timer = self.create_timer(2.0, self.send_request)\n\n        self.get_logger().info('Basic Service Client initialized')\n\n    def send_request(self):\n        \"\"\"Send a request to the service server.\"\"\"\n        # Set the request parameters\n        self.request.a = 42\n        self.request.b = 36\n\n        # Make the service call asynchronously\n        self.future = self.cli.call_async(self.request)\n\n        # Add a callback to handle the response\n        self.future.add_done_callback(self.service_callback)\n\n        self.get_logger().info(f'Requesting {self.request.a} + {self.request.b}')\n\n    def service_callback(self, future):\n        \"\"\"Handle the service response.\"\"\"\n        try:\n            response = future.result()\n            self.get_logger().info(\n                f'Result of {self.request.a} + {self.request.b} = {response.sum}'\n            )\n        except Exception as e:\n            self.get_logger().error(f'Service call failed: {e}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    service_client = BasicServiceClient()\n\n    try:\n        rclpy.spin(service_client)\n    except KeyboardInterrupt:\n        service_client.get_logger().info('Interrupted, shutting down...')\n    finally:\n        service_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-service-client-with-error-handling",children:"Advanced Service Client with Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\nfrom std_srvs.srv import Trigger\nimport time\nimport random\nfrom concurrent.futures import TimeoutError\n\nclass AdvancedServiceClient(Node):\n    \"\"\"\n    An advanced service client with comprehensive error handling,\n    timeout management, and multiple service support.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_service_client')\n\n        # Create multiple service clients\n        self.calc_client = self.create_client(AddTwoInts, 'advanced_calculation')\n        self.trigger_client = self.create_client(Trigger, 'system_trigger')\n\n        # Wait for services to be available\n        self.wait_for_services()\n\n        # Initialize request objects\n        self.calc_request = AddTwoInts.Request()\n        self.trigger_request = Trigger.Request()\n\n        # Client configuration parameters\n        self.declare_parameter('request_frequency', 1.0)  # Hz\n        self.declare_parameter('timeout_seconds', 5.0)\n        self.declare_parameter('max_retries', 3)\n\n        self.request_frequency = self.get_parameter('request_frequency').value\n        self.timeout_seconds = self.get_parameter('timeout_seconds').value\n        self.max_retries = self.get_parameter('max_retries').value\n\n        # Set up timer for periodic requests\n        timer_period = 1.0 / self.request_frequency\n        self.timer = self.create_timer(timer_period, self.make_requests)\n\n        # Track client statistics\n        self.stats = {\n            'total_requests': 0,\n            'successful_requests': 0,\n            'failed_requests': 0,\n            'timed_out_requests': 0\n        }\n\n        # Request tracking for retry mechanism\n        self.pending_requests = {}  # Maps request_id to request info\n\n        self.get_logger().info('Advanced Service Client initialized')\n\n    def wait_for_services(self):\n        \"\"\"Wait for required services to become available.\"\"\"\n        services = [\n            (self.calc_client, 'advanced_calculation'),\n            (self.trigger_client, 'system_trigger')\n        ]\n\n        for client, service_name in services:\n            while not client.wait_for_service(timeout_sec=1.0):\n                self.get_logger().info(f'Service {service_name} not available, waiting...')\n\n    def make_requests(self):\n        \"\"\"Make periodic service requests.\"\"\"\n        # Make a calculation request with random values\n        self.calc_request.a = random.randint(1, 100)\n        self.calc_request.b = random.randint(1, 100)\n\n        # Make the service call\n        self.stats['total_requests'] += 1\n        request_id = f'calc_{self.stats[\"total_requests\"]}'\n\n        future = self.calc_client.call_async(self.calc_request)\n        future.add_done_callback(lambda f: self.handle_calc_response(f, request_id))\n\n        self.get_logger().info(f'Sending calculation request {request_id}: {self.calc_request.a} + {self.calc_request.b}')\n\n        # Occasionally make a trigger request\n        if self.stats['total_requests'] % 5 == 0:\n            trigger_id = f'trigger_{self.stats[\"total_requests\"] // 5}'\n            trigger_future = self.trigger_client.call_async(self.trigger_request)\n            trigger_future.add_done_callback(lambda f: self.handle_trigger_response(f, trigger_id))\n\n    def handle_calc_response(self, future, request_id):\n        \"\"\"Handle calculation service response.\"\"\"\n        try:\n            response = future.result()\n\n            if response.success:\n                self.stats['successful_requests'] += 1\n                self.get_logger().info(\n                    f'Request {request_id} successful: {response.message}'\n                )\n            else:\n                self.stats['failed_requests'] += 1\n                self.get_logger().warn(\n                    f'Request {request_id} failed: {response.message}'\n                )\n\n        except TimeoutError:\n            self.stats['timed_out_requests'] += 1\n            self.get_logger().error(f'Request {request_id} timed out')\n\n        except Exception as e:\n            self.stats['failed_requests'] += 1\n            self.get_logger().error(f'Request {request_id} error: {e}')\n\n        # Log statistics periodically\n        if self.stats['total_requests'] % 10 == 0:\n            self.log_statistics()\n\n    def handle_trigger_response(self, future, request_id):\n        \"\"\"Handle trigger service response.\"\"\"\n        try:\n            response = future.result()\n\n            if response.success:\n                self.get_logger().info(f'Trigger {request_id} successful: {response.message}')\n            else:\n                self.get_logger().warn(f'Trigger {request_id} failed: {response.message}')\n\n        except Exception as e:\n            self.get_logger().error(f'Trigger {request_id} error: {e}')\n\n    def log_statistics(self):\n        \"\"\"Log client statistics.\"\"\"\n        success_rate = (self.stats['successful_requests'] /\n                       max(1, self.stats['total_requests'])) * 100\n\n        self.get_logger().info(\n            f'Statistics - Total: {self.stats[\"total_requests\"]}, '\n            f'Successful: {self.stats[\"successful_requests\"]} ({success_rate:.1f}%), '\n            f'Failed: {self.stats[\"failed_requests\"]}, '\n            f'Timed out: {self.stats[\"timed_out_requests\"]}'\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    advanced_client = AdvancedServiceClient()\n\n    try:\n        rclpy.spin(advanced_client)\n    except KeyboardInterrupt:\n        advanced_client.get_logger().info('Interrupted, shutting down...')\n        advanced_client.log_statistics()\n    finally:\n        advanced_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-client-with-retry-logic",children:"Service Client with Retry Logic"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\nimport time\nimport threading\nfrom collections import defaultdict\n\nclass RetryServiceClient(Node):\n    \"\"\"\n    A service client with sophisticated retry logic and request tracking.\n    This demonstrates how to handle unreliable services and implement resilience.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('retry_service_client')\n\n        # Create service client\n        self.client = self.create_client(AddTwoInts, 'unreliable_calculation')\n\n        # Wait for service\n        while not self.client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting...')\n\n        # Configuration\n        self.declare_parameter('request_interval', 3.0)  # seconds between requests\n        self.declare_parameter('max_retries', 5)\n        self.declare_parameter('retry_delay', 1.0)  # seconds between retries\n\n        self.request_interval = self.get_parameter('request_interval').value\n        self.max_retries = self.get_parameter('max_retries').value\n        self.retry_delay = self.get_parameter('retry_delay').value\n\n        # Request tracking\n        self.request_queue = []\n        self.pending_requests = {}  # Maps request_id to request info\n        self.retry_counts = defaultdict(int)\n\n        # Request object\n        self.request = AddTwoInts.Request()\n\n        # Timer for sending requests\n        self.timer = self.create_timer(self.request_interval, self.send_next_request)\n\n        # Thread for retry management\n        self.retry_thread = threading.Thread(target=self.retry_manager, daemon=True)\n        self.retry_thread.start()\n\n        self.get_logger().info('Retry Service Client initialized')\n\n    def send_next_request(self):\n        \"\"\"Send the next request in the queue.\"\"\"\n        # Generate a new request\n        self.request.a = int(time.time()) % 100\n        self.request.b = int(time.time() * 100) % 100\n        request_id = f'request_{int(time.time() * 1000)}'\n\n        # Send the request\n        future = self.client.call_async(self.request)\n        future.add_done_callback(lambda f: self.handle_response(f, request_id))\n\n        # Track the request\n        self.pending_requests[request_id] = {\n            'request': (self.request.a, self.request.b),\n            'timestamp': time.time(),\n            'future': future\n        }\n\n        self.get_logger().info(f'Sent request {request_id}: {self.request.a} + {self.request.b}')\n\n    def handle_response(self, future, request_id):\n        \"\"\"Handle service response.\"\"\"\n        try:\n            response = future.result()\n\n            if response.success:\n                self.get_logger().info(\n                    f'Request {request_id} succeeded: {response.message}'\n                )\n                # Remove from pending requests\n                if request_id in self.pending_requests:\n                    del self.pending_requests[request_id]\n                    if request_id in self.retry_counts:\n                        del self.retry_counts[request_id]\n            else:\n                self.get_logger().warn(\n                    f'Request {request_id} failed: {response.message}'\n                )\n                self.handle_failed_request(request_id)\n\n        except Exception as e:\n            self.get_logger().error(f'Request {request_id} error: {e}')\n            self.handle_failed_request(request_id)\n\n    def handle_failed_request(self, request_id):\n        \"\"\"Handle a failed request by scheduling a retry.\"\"\"\n        if request_id not in self.pending_requests:\n            return\n\n        current_retry = self.retry_counts[request_id] + 1\n\n        if current_retry <= self.max_retries:\n            self.retry_counts[request_id] = current_retry\n            retry_time = time.time() + self.retry_delay\n\n            self.get_logger().info(\n                f'Scheduling retry {current_retry}/{self.max_retries} for {request_id}'\n            )\n\n            # In a real system, you might want to use a more sophisticated scheduling mechanism\n            # For now, we'll handle retries in the retry_manager thread\n            self.pending_requests[request_id]['retry_time'] = retry_time\n            self.pending_requests[request_id]['retry_count'] = current_retry\n        else:\n            self.get_logger().error(\n                f'Request {request_id} failed after {self.max_retries} retries'\n            )\n            # Remove from tracking\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n\n    def retry_manager(self):\n        \"\"\"Background thread to manage retries.\"\"\"\n        while rclpy.ok():\n            current_time = time.time()\n            requests_to_retry = []\n\n            # Find requests that are ready for retry\n            for req_id, req_info in self.pending_requests.items():\n                if 'retry_time' in req_info and req_info['retry_time'] <= current_time:\n                    requests_to_retry.append(req_id)\n\n            # Retry the requests\n            for req_id in requests_to_retry:\n                if req_id in self.pending_requests:\n                    req_info = self.pending_requests[req_id]\n                    original_request = req_info['request']\n\n                    # Create new request with original values\n                    retry_request = AddTwoInts.Request()\n                    retry_request.a = original_request[0]\n                    retry_request.b = original_request[1]\n\n                    # Send retry\n                    future = self.client.call_async(retry_request)\n                    future.add_done_callback(lambda f: self.handle_response(f, req_id))\n\n                    # Update tracking\n                    self.pending_requests[req_id] = {\n                        'request': original_request,\n                        'timestamp': time.time(),\n                        'future': future\n                    }\n\n                    self.get_logger().info(\n                        f'Retrying request {req_id} (attempt {req_info.get(\"retry_count\", 1) + 1})'\n                    )\n\n            # Sleep to avoid busy waiting\n            time.sleep(0.1)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    retry_client = RetryServiceClient()\n\n    try:\n        rclpy.spin(retry_client)\n    except KeyboardInterrupt:\n        retry_client.get_logger().info('Interrupted, shutting down...')\n    finally:\n        retry_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-client-best-practices",children:"Service Client Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Availability"}),": Always check if services are available before making calls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous Calls"}),": Use ",(0,t.jsx)(n.code,{children:"call_async()"})," to avoid blocking the main thread"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Handle exceptions and service failures gracefully"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timeout Management"}),": Implement appropriate timeouts for service calls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Retry Logic"}),": Consider implementing retry mechanisms for unreliable services"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Management"}),": Properly manage futures and avoid resource leaks"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"working-with-custom-service-types",children:"Working with Custom Service Types"}),"\n",(0,t.jsxs)(n.p,{children:["While ROS 2 provides standard service types in packages like ",(0,t.jsx)(n.code,{children:"std_srvs"})," and ",(0,t.jsx)(n.code,{children:"example_interfaces"}),", you'll often need to define custom service types for your specific application. Custom services enable precise request-response communication between nodes and are essential for building specialized robotic applications."]}),"\n",(0,t.jsx)(n.h3,{id:"defining-custom-service-types",children:"Defining Custom Service Types"}),"\n",(0,t.jsxs)(n.p,{children:["Service types are defined in ",(0,t.jsx)(n.code,{children:".srv"})," files with the following format:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# In your_robot_package/srv/RobotControl.srv\n# Request part (before ---)\nfloat64 linear_velocity\nfloat64 angular_velocity\nbool enable_motors\n---\n# Response part (after ---)\nbool success\nstring message\nfloat64 execution_time\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# In your_robot_package/srv/GetRobotPose.srv\n# Request part\nstring robot_name\n---\n# Response part\nfloat64 x\nfloat64 y\nfloat64 theta\nbool success\nstring message\n"})}),"\n",(0,t.jsx)(n.h3,{id:"implementing-custom-services",children:"Implementing Custom Services"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Service server implementation\nimport rclpy\nfrom rclpy.node import Node\nfrom your_robot_package.srv import RobotControl, GetRobotPose\nimport time\n\nclass CustomServiceServer(Node):\n    \"\"\"\n    A service server that implements custom service types for robot control.\n    This demonstrates how to work with custom service definitions in Python.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('custom_service_server')\n\n        # Create services with custom types\n        self.control_service = self.create_service(\n            RobotControl,\n            'robot_control',\n            self.control_callback\n        )\n\n        self.pose_service = self.create_service(\n            GetRobotPose,\n            'get_robot_pose',\n            self.pose_callback\n        )\n\n        # Simulated robot state\n        self.robot_state = {\n            'x': 0.0,\n            'y': 0.0,\n            'theta': 0.0,\n            'linear_vel': 0.0,\n            'angular_vel': 0.0,\n            'motors_enabled': True\n        }\n\n        self.get_logger().info('Custom Service Server initialized')\n\n    def control_callback(self, request, response):\n        \"\"\"Handle robot control requests.\"\"\"\n        start_time = time.time()\n\n        try:\n            # Validate inputs\n            if abs(request.linear_velocity) > 2.0:\n                response.success = False\n                response.message = 'Linear velocity exceeds maximum (2.0 m/s)'\n                return response\n\n            if abs(request.angular_velocity) > 1.0:\n                response.success = False\n                response.message = 'Angular velocity exceeds maximum (1.0 rad/s)'\n                return response\n\n            # Update robot state based on request\n            self.robot_state['linear_vel'] = request.linear_velocity\n            self.robot_state['angular_vel'] = request.angular_velocity\n            self.robot_state['motors_enabled'] = request.enable_motors\n\n            # Simulate command execution (in real system, this would control hardware)\n            if request.enable_motors:\n                # Update position based on velocity (simplified simulation)\n                self.robot_state['x'] += request.linear_velocity * 0.1  # 0.1s simulation\n                self.robot_state['y'] += request.angular_velocity * 0.05  # Simplified\n\n            execution_time = time.time() - start_time\n\n            response.success = True\n            response.message = f'Control command executed successfully. Motors: {request.enable_motors}'\n            response.execution_time = execution_time\n\n            self.get_logger().info(\n                f'Control command: v={request.linear_velocity}, w={request.angular_velocity}, '\n                f'enabled={request.enable_motors}. Execution time: {execution_time:.3f}s'\n            )\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Control error: {str(e)}'\n            self.get_logger().error(f'Control error: {e}')\n\n        return response\n\n    def pose_callback(self, request, response):\n        \"\"\"Handle robot pose requests.\"\"\"\n        try:\n            # In a real system, you might look up the robot by name\n            # For this example, we'll use a fixed robot or return default values\n\n            if request.robot_name == '' or request.robot_name == 'robot_1':\n                response.x = self.robot_state['x']\n                response.y = self.robot_state['y']\n                response.theta = self.robot_state['theta']\n                response.success = True\n                response.message = f'Pose for {request.robot_name or \"default robot\"}'\n            else:\n                response.x = 0.0\n                response.y = 0.0\n                response.theta = 0.0\n                response.success = False\n                response.message = f'Robot {request.robot_name} not found'\n\n            self.get_logger().info(\n                f'Pose request for {request.robot_name}: ({response.x}, {response.y}, {response.theta})'\n            )\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Pose error: {str(e)}'\n            self.get_logger().error(f'Pose error: {e}')\n\n        return response\n\n# Service client implementation\nclass CustomServiceClient(Node):\n    \"\"\"\n    A service client that uses custom service types for robot communication.\n    This demonstrates how to call custom services from Python.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('custom_service_client')\n\n        # Create clients for custom services\n        self.control_client = self.create_client(RobotControl, 'robot_control')\n        self.pose_client = self.create_client(GetRobotPose, 'get_robot_pose')\n\n        # Wait for services\n        while not self.control_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Control service not available, waiting...')\n\n        while not self.pose_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Pose service not available, waiting...')\n\n        # Request objects\n        self.control_request = RobotControl.Request()\n        self.pose_request = GetRobotPose.Request()\n\n        # Timer for demonstration\n        self.timer = self.create_timer(3.0, self.demo_service_calls)\n\n        self.get_logger().info('Custom Service Client initialized')\n\n    def demo_service_calls(self):\n        \"\"\"Demonstrate calls to custom services.\"\"\"\n        # Make a control request\n        self.control_request.linear_velocity = 0.5\n        self.control_request.angular_velocity = 0.1\n        self.control_request.enable_motors = True\n\n        future = self.control_client.call_async(self.control_request)\n        future.add_done_callback(self.control_response_callback)\n\n        self.get_logger().info('Sent control request')\n\n        # Make a pose request\n        self.pose_request.robot_name = 'robot_1'\n        pose_future = self.pose_client.call_async(self.pose_request)\n        pose_future.add_done_callback(self.pose_response_callback)\n\n        self.get_logger().info('Sent pose request')\n\n    def control_response_callback(self, future):\n        \"\"\"Handle control service response.\"\"\"\n        try:\n            response = future.result()\n            if response.success:\n                self.get_logger().info(f'Control successful: {response.message}')\n            else:\n                self.get_logger().warn(f'Control failed: {response.message}')\n        except Exception as e:\n            self.get_logger().error(f'Control response error: {e}')\n\n    def pose_response_callback(self, future):\n        \"\"\"Handle pose service response.\"\"\"\n        try:\n            response = future.result()\n            if response.success:\n                self.get_logger().info(\n                    f'Pose: ({response.x:.2f}, {response.y:.2f}, {response.theta:.2f}) - {response.message}'\n                )\n            else:\n                self.get_logger().warn(f'Pose request failed: {response.message}')\n        except Exception as e:\n            self.get_logger().error(f'Pose response error: {e}')\n\ndef main_server(args=None):\n    rclpy.init(args=args)\n    server = CustomServiceServer()\n\n    try:\n        rclpy.spin(server)\n    except KeyboardInterrupt:\n        server.get_logger().info('Server interrupted')\n    finally:\n        server.destroy_node()\n        rclpy.shutdown()\n\ndef main_client(args=None):\n    rclpy.init(args=args)\n    client = CustomServiceClient()\n\n    try:\n        rclpy.spin(client)\n    except KeyboardInterrupt:\n        client.get_logger().info('Client interrupted')\n    finally:\n        client.destroy_node()\n        rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"complex-custom-service-example",children:"Complex Custom Service Example"}),"\n",(0,t.jsx)(n.p,{children:"For more complex applications, you might need services with nested message types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# In your_robot_package/srv/ExecuteTrajectory.srv\n# Request\nstring trajectory_id\ngeometry_msgs/Point[] waypoints\nfloat64[] velocities\nfloat64 timeout\nbool blocking\n---\n# Response\nbool success\nstring message\nbuiltin_interfaces/Time execution_start\nbuiltin_interfaces/Time execution_end\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom your_robot_package.srv import ExecuteTrajectory\nfrom geometry_msgs.msg import Point\nfrom builtin_interfaces.msg import Time\nimport time\n\nclass TrajectoryServiceServer(Node):\n    \"\"\"\n    A service server for executing complex robot trajectories.\n    This demonstrates working with complex custom service types.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('trajectory_service_server')\n\n        self.service = self.create_service(\n            ExecuteTrajectory,\n            'execute_trajectory',\n            self.trajectory_callback\n        )\n\n        self.get_logger().info('Trajectory Service Server initialized')\n\n    def trajectory_callback(self, request, response):\n        \"\"\"Handle trajectory execution requests.\"\"\"\n        start_time = self.get_clock().now().to_msg()\n\n        try:\n            # Validate trajectory\n            if len(request.waypoints) == 0:\n                response.success = False\n                response.message = 'Trajectory has no waypoints'\n                return response\n\n            if len(request.velocities) != len(request.waypoints):\n                response.success = False\n                response.message = 'Number of velocities must match number of waypoints'\n                return response\n\n            # Simulate trajectory execution\n            self.get_logger().info(\n                f'Executing trajectory {request.trajectory_id} '\n                f'with {len(request.waypoints)} waypoints'\n            )\n\n            # In a real system, this would execute the actual trajectory\n            # For simulation, we'll just wait\n            if request.blocking:\n                # Simulate execution time based on number of waypoints\n                execution_duration = len(request.waypoints) * 0.5  # 0.5s per waypoint\n                if execution_duration > request.timeout:\n                    response.success = False\n                    response.message = f'Trajectory would take {execution_duration}s, exceeds timeout {request.timeout}s'\n                    return response\n\n                time.sleep(min(execution_duration, request.timeout))\n\n            # Set response\n            response.success = True\n            response.message = f'Trajectory {request.trajectory_id} executed successfully'\n            response.execution_start = start_time\n            response.execution_end = self.get_clock().now().to_msg()\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Trajectory execution error: {str(e)}'\n            self.get_logger().error(f'Trajectory error: {e}')\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    server = TrajectoryServiceServer()\n\n    try:\n        rclpy.spin(server)\n    except KeyboardInterrupt:\n        server.get_logger().info('Trajectory server interrupted')\n    finally:\n        server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"custom-service-best-practices",children:"Custom Service Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Design"}),": Design services with clear request-response semantics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Include success/failure indicators in responses"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timeout Considerations"}),": Consider whether operations should be blocking or non-blocking"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation"}),": Validate all request parameters before processing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documentation"}),": Document service interfaces clearly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Versioning"}),": Consider how service changes will affect compatibility"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"python-agent-bridge-for-services",children:"Python Agent Bridge for Services"}),"\n",(0,t.jsx)(n.p,{children:"Service communication provides an excellent mechanism for connecting Python AI agents to ROS controllers, especially for operations that require guaranteed responses or have clear request-response semantics. This pattern enables AI agents to request specific actions from robot controllers and receive confirmation of completion."}),"\n",(0,t.jsx)(n.h3,{id:"service-bridge-architecture",children:"Service Bridge Architecture"}),"\n",(0,t.jsx)(n.p,{children:"The service bridge architecture uses synchronous communication for operations that require immediate confirmation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool, Trigger\nfrom your_robot_package.srv import RobotControl, GetRobotPose\nimport time\nimport threading\nfrom queue import Queue\n\nclass ServiceBridgeNode(Node):\n    \"\"\"\n    A bridge node that connects Python AI agents to ROS controllers using services.\n    This demonstrates synchronous communication for guaranteed operations.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('service_bridge')\n\n        # Declare bridge configuration parameters\n        self.declare_parameter('service_timeout', 5.0)\n        self.declare_parameter('max_concurrent_requests', 10)\n        self.declare_parameter('bridge_enabled', True)\n\n        # Get parameter values\n        self.service_timeout = self.get_parameter('service_timeout').value\n        self.max_concurrent_requests = self.get_parameter('max_concurrent_requests').value\n        self.bridge_enabled = self.get_parameter('bridge_enabled').value\n\n        # Create service clients for robot control\n        self.motor_control_client = self.create_client(SetBool, '/motors/enable')\n        self.control_client = self.create_client(RobotControl, '/robot/control')\n        self.pose_client = self.create_client(GetRobotPose, '/robot/get_pose')\n        self.trigger_client = self.create_client(Trigger, '/robot/emergency_stop')\n\n        # Create services for AI agent interface\n        self.agent_control_service = self.create_service(\n            SetBool, '/agent/control', self.agent_control_callback\n        )\n        self.agent_command_service = self.create_service(\n            RobotControl, '/agent/command', self.agent_command_callback\n        )\n        self.agent_pose_service = self.create_service(\n            GetRobotPose, '/agent/get_pose', self.agent_pose_callback\n        )\n\n        # Wait for robot services to be available\n        self.wait_for_robot_services()\n\n        # Initialize request objects\n        self.set_bool_request = SetBool.Request()\n        self.control_request = RobotControl.Request()\n        self.pose_request = GetRobotPose.Request()\n        self.trigger_request = Trigger.Request()\n\n        # Agent state tracking\n        self.agent_state = {\n            'enabled': True,\n            'last_command_time': time.time(),\n            'command_count': 0,\n            'error_count': 0\n        }\n\n        # Thread-safe request queue\n        self.request_queue = Queue(maxsize=self.max_concurrent_requests)\n\n        self.get_logger().info('Service Bridge Node initialized')\n        self.get_logger().info(f'Service timeout: {self.service_timeout}s')\n\n    def wait_for_robot_services(self):\n        \"\"\"Wait for all robot services to become available.\"\"\"\n        services = [\n            (self.motor_control_client, '/motors/enable'),\n            (self.control_client, '/robot/control'),\n            (self.pose_client, '/robot/get_pose'),\n            (self.trigger_client, '/robot/emergency_stop')\n        ]\n\n        for client, service_name in services:\n            while not client.wait_for_service(timeout_sec=1.0):\n                self.get_logger().info(f'Waiting for robot service: {service_name}...')\n\n    def agent_control_callback(self, request, response):\n        \"\"\"Handle agent control requests from Python AI.\"\"\"\n        if not self.bridge_enabled:\n            response.success = False\n            response.message = 'Bridge is disabled'\n            return response\n\n        try:\n            self.agent_state['enabled'] = request.data\n            status = 'enabled' if request.data else 'disabled'\n            response.success = True\n            response.message = f'Agent {status} successfully'\n\n            self.get_logger().info(f'Agent control: {status}')\n        except Exception as e:\n            response.success = False\n            response.message = f'Control error: {str(e)}'\n            self.get_logger().error(f'Agent control error: {e}')\n\n        return response\n\n    def agent_command_callback(self, request, response):\n        \"\"\"Handle robot command requests from Python AI.\"\"\"\n        if not self.bridge_enabled:\n            response.success = False\n            response.message = 'Bridge is disabled'\n            return response\n\n        if not self.agent_state['enabled']:\n            response.success = False\n            response.message = 'Agent is disabled'\n            return response\n\n        try:\n            # Forward the command to the robot\n            self.control_request.linear_velocity = request.linear_velocity\n            self.control_request.angular_velocity = request.angular_velocity\n            self.control_request.enable_motors = request.enable_motors\n\n            # Make the service call to the robot\n            future = self.control_client.call_async(self.control_request)\n\n            # Wait for response (this makes it synchronous from the agent's perspective)\n            rclpy.spin_until_future_complete(self, future, timeout_sec=self.service_timeout)\n\n            if future.done():\n                robot_response = future.result()\n                response.success = robot_response.success\n                response.message = robot_response.message\n                response.execution_time = robot_response.execution_time\n\n                # Update agent state\n                self.agent_state['last_command_time'] = time.time()\n                self.agent_state['command_count'] += 1\n\n                if robot_response.success:\n                    self.get_logger().info(f'Command executed: {robot_response.message}')\n                else:\n                    self.agent_state['error_count'] += 1\n                    self.get_logger().warn(f'Command failed: {robot_response.message}')\n            else:\n                response.success = False\n                response.message = f'Command timed out after {self.service_timeout}s'\n                self.agent_state['error_count'] += 1\n                self.get_logger().error(f'Command timeout: {response.message}')\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Command error: {str(e)}'\n            self.agent_state['error_count'] += 1\n            self.get_logger().error(f'Command error: {e}')\n\n        return response\n\n    def agent_pose_callback(self, request, response):\n        \"\"\"Handle pose request from Python AI.\"\"\"\n        if not self.bridge_enabled:\n            response.success = False\n            response.message = 'Bridge is disabled'\n            return response\n\n        try:\n            # Forward the pose request to the robot\n            self.pose_request.robot_name = request.robot_name\n\n            # Make the service call to the robot\n            future = self.pose_client.call_async(self.pose_request)\n            rclpy.spin_until_future_complete(self, future, timeout_sec=self.service_timeout)\n\n            if future.done():\n                robot_response = future.result()\n                response.x = robot_response.x\n                response.y = robot_response.y\n                response.theta = robot_response.theta\n                response.success = robot_response.success\n                response.message = robot_response.message\n            else:\n                response.success = False\n                response.message = f'Pose request timed out after {self.service_timeout}s'\n                self.get_logger().error(response.message)\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Pose request error: {str(e)}'\n            self.get_logger().error(f'Pose request error: {e}')\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    bridge = ServiceBridgeNode()\n\n    try:\n        rclpy.spin(bridge)\n    except KeyboardInterrupt:\n        bridge.get_logger().info(\n            f'Service bridge interrupted. Stats - Commands: {bridge.agent_state[\"command_count\"]}, '\n            f'Errors: {bridge.agent_state[\"error_count\"]}'\n        )\n    finally:\n        bridge.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-service-bridge-with-multiple-agents",children:"Advanced Service Bridge with Multiple Agents"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool, Trigger\nfrom your_robot_package.srv import RobotControl, GetRobotPose\nimport time\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor\nfrom collections import defaultdict\n\nclass AdvancedServiceBridgeNode(Node):\n    \"\"\"\n    An advanced service bridge supporting multiple AI agents with priority management\n    and sophisticated request handling.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_service_bridge')\n\n        # Declare advanced parameters\n        self.declare_parameter('max_concurrent_agents', 5)\n        self.declare_parameter('agent_timeout', 10.0)\n        self.declare_parameter('priority_levels', 3)  # 0=low, 1=normal, 2=high\n\n        # Get parameter values\n        self.max_agents = self.get_parameter('max_concurrent_agents').value\n        self.agent_timeout = self.get_parameter('agent_timeout').value\n        self.priority_levels = self.get_parameter('priority_levels').value\n\n        # Create service clients for robot\n        self.control_client = self.create_client(RobotControl, '/robot/control')\n        self.pose_client = self.create_client(GetRobotPose, '/robot/get_pose')\n        self.emergency_client = self.create_client(Trigger, '/robot/emergency_stop')\n\n        # Create services for agents\n        self.agent_command_service = self.create_service(\n            RobotControl, '/multi_agent/command', self.multi_agent_command_callback\n        )\n        self.agent_status_service = self.create_service(\n            GetRobotPose, '/multi_agent/status', self.multi_agent_status_callback\n        )\n\n        # Wait for robot services\n        self.wait_for_robot_services()\n\n        # Initialize requests\n        self.control_request = RobotControl.Request()\n        self.pose_request = GetRobotPose.Request()\n        self.trigger_request = Trigger.Request()\n\n        # Agent management\n        self.active_agents = {}  # Maps agent_id to agent info\n        self.agent_priorities = defaultdict(lambda: 1)  # Default to normal priority\n        self.request_queue = defaultdict(list)  # Priority level to request queue\n\n        # Thread pool for handling requests\n        self.executor = ThreadPoolExecutor(max_workers=10)\n\n        self.get_logger().info('Advanced Service Bridge initialized')\n\n    def wait_for_robot_services(self):\n        \"\"\"Wait for all robot services to be available.\"\"\"\n        services = [\n            (self.control_client, '/robot/control'),\n            (self.pose_client, '/robot/get_pose'),\n            (self.emergency_client, '/robot/emergency_stop')\n        ]\n\n        for client, service_name in services:\n            while not client.wait_for_service(timeout_sec=1.0):\n                self.get_logger().info(f'Waiting for {service_name}...')\n\n    def multi_agent_command_callback(self, request, response):\n        \"\"\"Handle commands from multiple agents with priority management.\"\"\"\n        # Extract agent ID from request (in a real system, this might come from service name or additional field)\n        agent_id = getattr(request, 'agent_id', 'default_agent')\n\n        # Check if agent is registered and get priority\n        priority = self.agent_priorities[agent_id]\n\n        # Validate request\n        if abs(request.linear_velocity) > 2.0 or abs(request.angular_velocity) > 1.0:\n            response.success = False\n            response.message = 'Invalid velocity values'\n            return response\n\n        # Add to appropriate priority queue\n        request_item = {\n            'agent_id': agent_id,\n            'request': request,\n            'timestamp': time.time(),\n            'priority': priority\n        }\n\n        self.request_queue[priority].append(request_item)\n\n        # Process high priority requests first\n        self.process_requests_by_priority()\n\n        response.success = True\n        response.message = f'Command queued for agent {agent_id} (priority: {priority})'\n        return response\n\n    def process_requests_by_priority(self):\n        \"\"\"Process requests starting with highest priority.\"\"\"\n        # Process queues from highest to lowest priority\n        for priority_level in sorted(self.request_queue.keys(), reverse=True):\n            if self.request_queue[priority_level]:\n                request_item = self.request_queue[priority_level].pop(0)\n                # Process the request in a separate thread\n                self.executor.submit(self.execute_robot_command, request_item)\n\n    def execute_robot_command(self, request_item):\n        \"\"\"Execute a robot command in a separate thread.\"\"\"\n        agent_id = request_item['agent_id']\n        request = request_item['request']\n\n        try:\n            # Forward to robot\n            self.control_request.linear_velocity = request.linear_velocity\n            self.control_request.angular_velocity = request.angular_velocity\n            self.control_request.enable_motors = request.enable_motors\n\n            future = self.control_client.call_async(self.control_request)\n\n            # Wait for robot response\n            rclpy.spin_until_future_complete(self, future, timeout_sec=self.agent_timeout)\n\n            if future.done():\n                robot_response = future.result()\n                self.get_logger().info(\n                    f'Agent {agent_id} command completed: {robot_response.message}'\n                )\n            else:\n                self.get_logger().error(f'Agent {agent_id} command timed out')\n\n        except Exception as e:\n            self.get_logger().error(f'Agent {agent_id} command error: {e}')\n\n    def multi_agent_status_callback(self, request, response):\n        \"\"\"Handle status requests from multiple agents.\"\"\"\n        agent_id = getattr(request, 'agent_id', 'default_agent')\n\n        try:\n            # Get robot status\n            future = self.pose_client.call_async(self.pose_request)\n            rclpy.spin_until_future_complete(self, future, timeout_sec=self.agent_timeout)\n\n            if future.done():\n                robot_response = future.result()\n                response.x = robot_response.x\n                response.y = robot_response.y\n                response.theta = robot_response.theta\n                response.success = robot_response.success\n                response.message = f'Status for agent {agent_id}: {robot_response.message}'\n            else:\n                response.success = False\n                response.message = f'Status request for {agent_id} timed out'\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Status request error for {agent_id}: {str(e)}'\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    advanced_bridge = AdvancedServiceBridgeNode()\n\n    try:\n        rclpy.spin(advanced_bridge)\n    except KeyboardInterrupt:\n        advanced_bridge.get_logger().info('Advanced bridge interrupted')\n    finally:\n        advanced_bridge.executor.shutdown(wait=True)\n        advanced_bridge.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-bridge-benefits",children:"Service Bridge Benefits"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Guaranteed Responses"}),": Services ensure that operations complete and return results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronous Operations"}),": Ideal for operations requiring immediate confirmation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Clear success/failure semantics with detailed error messages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Priority Management"}),": Can implement sophisticated request prioritization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Management"}),": Better control over resource allocation and access"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.p,{children:["In this section, we've explored services in ROS 2 using ",(0,t.jsx)(n.code,{children:"rclpy"}),". You've learned:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service server creation"})," and implementation with proper error handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service client implementation"})," with asynchronous calls and response handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Custom service types"})," for specialized applications"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service communication patterns"})," for synchronous robot control"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Python agent bridge patterns"})," for connecting AI algorithms to robot controllers using services"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Services provide a crucial synchronous communication mechanism that complements the asynchronous publish-subscribe pattern, enabling guaranteed operations and immediate responses that are essential for many robotic applications."}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Custom Service Creation"}),": Define and implement a custom service for robot calibration that takes sensor parameters and returns calibration results."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Service Client with Retry"}),": Create a service client that implements sophisticated retry logic for unreliable services with exponential backoff."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Multi-Agent Service Bridge"}),": Implement a service bridge that can handle requests from multiple AI agents with different priority levels."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Service Composition"}),": Create a service that composes multiple other services to perform complex operations (e.g., navigate to position and then perform an action)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Service Performance Monitoring"}),": Implement a service that tracks and reports performance metrics for other services in the system."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Safety-Enhanced Service"}),": Create a robot control service that includes safety checks and validation before executing commands."]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(6540);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);