"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[5800],{7721:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>c,metadata:()=>o,toc:()=>s});const o=JSON.parse('{"id":"Module1-ROS/Chapter2-Nodes,TopicsService,Action/1-2-4-Actions","title":"2.4 - Actions","description":"---","source":"@site/docs/Module1-ROS/Chapter2-Nodes,TopicsService,Action/1-2.4 Actions.md","sourceDirName":"Module1-ROS/Chapter2-Nodes,TopicsService,Action","slug":"/Module1-ROS/Chapter2-Nodes,TopicsService,Action/1-2-4-Actions","permalink":"/docs/Module1-ROS/Chapter2-Nodes,TopicsService,Action/1-2-4-Actions","draft":false,"unlisted":false,"editUrl":"https://github.com/areebayaseen15/Ai-Humanoid-textbook/edit/main/docs/Module1-ROS/Chapter2-Nodes,TopicsService,Action/1-2.4 Actions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"1-2-4-Actions","sidebar_position":4,"title":"2.4 - Actions"},"sidebar":"tutorialSidebar","previous":{"title":"2.3 - Services","permalink":"/docs/Module1-ROS/Chapter2-Nodes,TopicsService,Action/1-2-3-Services"},"next":{"title":"Chapter 2 Overview","permalink":"/docs/Module1-ROS/Chapter2-Nodes,TopicsService,Action/"}}');var t=r(4848),i=r(8453);const c={id:"1-2-4-Actions",sidebar_position:4,title:"2.4 - Actions"},a=void 0,l={},s=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Basic Action Server Implementation",id:"basic-action-server-implementation",level:2},{value:"Basic Action Client Implementation",id:"basic-action-client-implementation",level:2},{value:"Custom Action Definition",id:"custom-action-definition",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h1,{id:"24-actions-asynchronous-goal-oriented-tasks",children:"2.4 Actions: Asynchronous Goal-Oriented Tasks"}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Explain the asynchronous goal/feedback/result communication model for long-running tasks."}),"\n",(0,t.jsxs)(n.li,{children:["Implement ROS 2 action servers and clients in Python using ",(0,t.jsx)(n.code,{children:"rclpy"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Define and use custom ROS IDL action types."}),"\n",(0,t.jsx)(n.li,{children:"Understand how to manage asynchronous execution, handle feedback, and implement task cancellation."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROS 2 Actions"}),": Asynchronous goal/feedback/result communication pattern"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action Server"}),": Node that executes long-running tasks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action Client"}),": Node that sends goals and receives feedback/results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal"}),": Request sent to an action server"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback"}),": Periodic updates during task execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result"}),": Final outcome of the task"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task Cancellation"}),": Mechanism to stop long-running tasks"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This section provides a detailed explanation of actions for long-running, asynchronous tasks. It covers the components: goal, feedback, and result. Step-by-step guidance on implementing Python action servers and clients with ",(0,t.jsx)(n.code,{children:"rclpy"})," is provided, including how to handle goal acceptance, continuous feedback publishing, and result processing. Critical aspects like task cancellation and asynchronous programming patterns (e.g., using ",(0,t.jsx)(n.code,{children:"Future"})," objects) are covered. The creation of custom ",(0,t.jsx)(n.code,{children:".action"})," files using ROS IDL is demonstrated."]}),"\n",(0,t.jsx)(n.h2,{id:"basic-action-server-implementation",children:"Basic Action Server Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.action import ActionServer, ActionClient, CancelResponse, GoalResponse\r\nfrom rclpy.node import Node\r\nfrom rclpy.callback_groups import ReentrantCallbackGroup\r\nfrom rclpy.executors import MultiThreadedExecutor\r\n\r\n# Assuming custom action type in my_robot_controller/action/Fibonacci.action\r\n# int32 order\r\n# ---\r\n# int32[] sequence\r\n# ---\r\n# int32[] partial_sequence\r\nfrom my_robot_controller.action import Fibonacci # Import custom action\r\n\r\nimport time\r\n\r\nclass FibonacciActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__('fibonacci_action_server')\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci',\r\n            self.execute_callback,\r\n            goal_callback=self.goal_callback,\r\n            handle_accepted_callback=self.handle_accepted_callback,\r\n            cancel_callback=self.cancel_callback,\r\n            callback_group=ReentrantCallbackGroup() # Use reentrant group for concurrent callbacks\r\n        )\r\n        self.get_logger().info('Fibonacci Action Server Ready.')\r\n\r\n    def goal_callback(self, goal_request):\r\n        self.get_logger().info(f'Received goal request with order {goal_request.order}')\r\n        # Validate goal request\r\n        if goal_request.order > 1000: # Example validation\r\n            self.get_logger().warn('Goal order too high, rejecting.')\r\n            return GoalResponse.REJECT\r\n        return GoalResponse.ACCEPT\r\n\r\n    def handle_accepted_callback(self, goal_handle):\r\n        self.get_logger().info('Goal accepted, executing...')\r\n        # Start a new thread for execution to avoid blocking the main executor\r\n        # In a real robot, this would offload to a control loop\r\n        import threading\r\n        thread = threading.Thread(target=self.execute_callback, args=(goal_handle,))\r\n        thread.start()\r\n\r\n    def cancel_callback(self, goal_handle):\r\n        self.get_logger().info('Received cancel request')\r\n        # Implement logic to stop the long-running task if possible\r\n        return CancelResponse.ACCEPT\r\n\r\n    def execute_callback(self, goal_handle):\r\n        self.get_logger().info('Executing goal...')\r\n        feedback_msg = Fibonacci.Feedback()\r\n        feedback_msg.partial_sequence = [0, 1]\r\n\r\n        # Fibonacci sequence generation\r\n        for i in range(1, goal_handle.request.order):\r\n            if goal_handle.is_cancel_requested:\r\n                goal_handle.canceled()\r\n                self.get_logger().info('Goal canceled by client.')\r\n                return Fibonacci.Result()\r\n\r\n            feedback_msg.partial_sequence.append(\r\n                feedback_msg.partial_sequence[i] + feedback_msg.partial_sequence[i-1]\r\n            )\r\n            self.get_logger().info(f'Feedback: {feedback_msg.partial_sequence[-1]}')\r\n            goal_handle.publish_feedback(feedback_msg)\r\n            time.sleep(0.5) # Simulate work\r\n\r\n        goal_handle.succeed()\r\n        result = Fibonacci.Result()\r\n        result.sequence = feedback_msg.partial_sequence\r\n        self.get_logger().info('Goal succeeded.')\r\n        return result\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    executor = MultiThreadedExecutor()\r\n    action_server_node = FibonacciActionServer()\r\n    executor.add_node(action_server_node)\r\n\r\n    try:\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        executor.shutdown()\r\n        action_server_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"basic-action-client-implementation",children:"Basic Action Client Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.action import ActionClient\r\nfrom rclpy.node import Node\r\n\r\n# Assuming custom action type in my_robot_controller/action/Fibonacci.action\r\nfrom my_robot_controller.action import Fibonacci # Import custom action\r\n\r\nimport time\r\nimport sys\r\n\r\nclass FibonacciActionClient(Node):\r\n    def __init__(self):\r\n        super().__init__('fibonacci_action_client')\r\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\r\n\r\n    def send_goal(self, order):\r\n        self.get_logger().info('Waiting for action server...')\r\n        self._action_client.wait_for_server()\r\n\r\n        goal_msg = Fibonacci.Goal()\r\n        goal_msg.order = order\r\n\r\n        self.get_logger().info(f'Sending goal request: {order}')\r\n\r\n        self._send_goal_future = self._action_client.send_goal_async(\r\n            goal_msg,\r\n            feedback_callback=self.feedback_callback)\r\n\r\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\r\n\r\n    def goal_response_callback(self, future):\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info('Goal rejected :(')\r\n            return\r\n\r\n        self.get_logger().info('Goal accepted :)')\r\n\r\n        self._get_result_future = goal_handle.get_result_async()\r\n        self._get_result_future.add_done_callback(self.get_result_callback)\r\n\r\n    def get_result_callback(self, future):\r\n        result = future.result().result\r\n        self.get_logger().info(f'Result: {result.sequence}')\r\n        rclpy.shutdown() # Shutdown rclpy once result is received\r\n\r\n    def feedback_callback(self, feedback_msg):\r\n        self.get_logger().info(f'Received feedback: {feedback_msg.feedback.partial_sequence[-1]}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    if len(sys.argv) != 2:\r\n        print('Usage: ros2 run <package_name> fibonacci_action_client <order>')\r\n        return\r\n\r\n    action_client_node = FibonacciActionClient()\r\n    action_client_node.send_goal(int(sys.argv[1]))\r\n\r\n    rclpy.spin(action_client_node) # Spin until rclpy.shutdown() is called in get_result_callback\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"custom-action-definition",children:"Custom Action Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# In my_robot_controller/action/MoveToGoal.action\r\n# float32 target_x\r\n# float32 target_y\r\n# ---\r\n# bool success\r\n# float32 final_x\r\n# float32 final_y\r\n# ---\r\n# float32 current_x\r\n# float32 current_y\r\n# float32 distance_to_goal\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>a});var o=r(6540);const t={},i=o.createContext(t);function c(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);